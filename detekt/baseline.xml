<?xml version='1.0' encoding='UTF-8'?>
<SmellBaseline>
    <ManuallySuppressedIssues>
        <ID>MatchingDeclarationName:Widgets.kt$CustomScrollRegion : Widget</ID>
    </ManuallySuppressedIssues>
    <CurrentIssues>
        <ID>AnnotationSpacing:HttpClientConnectionSpecsTest.kt$HttpClientConnectionSpecsTest$@Test</ID>
        <ID>AnnotationSpacing:NetworkResponse.kt$@OptIn(ExperimentalContracts::class)</ID>
        <ID>AnnotationSpacing:ProteusClient.kt$ProteusClient$@Suppress("TooManyFunctions")</ID>
        <ID>AnnotationSpacing:SendButtonMessageUseCase.kt$SendButtonMessageUseCase$@Suppress("LongParameterList")</ID>
        <ID>AnnotationSpacing:SendEditTextMessageUseCase.kt$SendEditTextMessageUseCase$@Suppress("LongParameterList")</ID>
        <ID>AnnotationSpacing:SendKnockUseCase.kt$SendKnockUseCase$@Suppress("LongParameterList")</ID>
        <ID>AnnotationSpacing:SendTextMessageUseCase.kt$SendTextMessageUseCase$@Suppress("LongParameterList")</ID>
        <ID>ArgumentListWrapping:ACMEApi.kt$ACMEApiImpl$("getACMEDirectories: Url cannot be empty")</ID>
        <ID>ArgumentListWrapping:ACMEApi.kt$ACMEApiImpl$("sendACMERequest: Url cannot be empty")</ID>
        <ID>ArgumentListWrapping:ACMEApi.kt$ACMEApiImpl$(IllegalArgumentException("getACMEDirectories: Url cannot be empty"))</ID>
        <ID>ArgumentListWrapping:ACMEApi.kt$ACMEApiImpl$(IllegalArgumentException("sendACMERequest: Url cannot be empty"))</ID>
        <ID>ArgumentListWrapping:ACMEApi.kt$ACMEApiImpl$(KaliumException.GenericError(IllegalArgumentException("getACMEDirectories: Url cannot be empty")))</ID>
        <ID>ArgumentListWrapping:ACMEApi.kt$ACMEApiImpl$(KaliumException.GenericError(IllegalArgumentException("sendACMERequest: Url cannot be empty")))</ID>
        <ID>ArgumentListWrapping:AcceptConnectionRequestUseCase.kt$AcceptConnectionRequestUseCaseImpl$("An error occurred when accepting the connection request from ${userId.toLogString()}: $it")</ID>
        <ID>ArgumentListWrapping:AccessTokenDTOJson.kt$AccessTokenDTOJson$( AccessTokenDTO( userId = "user_id", value = "Nlrhltkj-NgJUjEVevHz8Ilgy_pyWCT2b0kQb-GlnamyswanghN9DcC3an5RUuA7sh1_nC3hv2ZzMRlIhPM7Ag==.v=1.k=1.d=1637254939." + "t=a.l=.u=75ebeb16-a860-4be4-84a7-157654b492cf.c=18401233206926541098", expiresIn = 900, tokenType = "Bearer" ), jsonProvider )</ID>
        <ID>ArgumentListWrapping:AccessTokenRefresherTest.kt$AccessTokenRefresherTest$(userId = TestUser.USER_ID, TEST_REFRESH_RESULT.accessToken, TEST_REFRESH_RESULT.refreshToken, null)</ID>
        <ID>ArgumentListWrapping:AccountRepositoryTest.kt$AccountRepositoryTest.Arrangement$(Unit, mapOf(), 200)</ID>
        <ID>ArgumentListWrapping:AccountsDAO.kt$AccountsDAOImpl$(mapper = mapper::fromPersistentWebSocketStatus)</ID>
        <ID>ArgumentListWrapping:AccountsDAO.kt$AccountsDAOImpl$(queriesContext)</ID>
        <ID>ArgumentListWrapping:ActivationRequestJson.kt$ActivationRequestJson$( RegisterApi.ActivationParam.Email(email = "user@domain.de", code = "123456"), jsonProvider )</ID>
        <ID>ArgumentListWrapping:AddAuthenticatedUserUseCase.kt$AddAuthenticatedUserUseCase$( { Result.Failure.Generic(it) }, { doesValidSessionExist -> when (doesValidSessionExist) { true -> onUserExist(serverConfigId, ssoId, authTokens, proxyCredentials, replace) false -> storeUser(serverConfigId, ssoId, authTokens, proxyCredentials) } } )</ID>
        <ID>ArgumentListWrapping:AddAuthenticatedUserUseCaseTest.kt$AddAuthenticatedUserUseCaseTest$(TEST_SERVER_CONFIG.id, TEST_SSO_ID, newSession, proxyCredentials, Either.Right(Unit))</ID>
        <ID>ArgumentListWrapping:AddAuthenticatedUserUseCaseTest.kt$AddAuthenticatedUserUseCaseTest$(Unit)</ID>
        <ID>ArgumentListWrapping:AddAuthenticatedUserUseCaseTest.kt$AddAuthenticatedUserUseCaseTest.Arrangement$(serverConfigId, ssoId, accountTokens, proxyCredentials)</ID>
        <ID>ArgumentListWrapping:AddAuthenticatedUserUseCaseTest.kt$AddAuthenticatedUserUseCaseTest.Arrangement$(sessionRepository)</ID>
        <ID>ArgumentListWrapping:AddUserToConversationAction.kt$AddUserToConversationAction$(monkeyConversation.conversationId, participants.map { it.internalId })</ID>
        <ID>ArgumentListWrapping:AddUserToConversationAction.kt$AddUserToConversationAction$(sender)</ID>
        <ID>ArgumentListWrapping:AddUserToConversationEventAction.kt$AddUserToConversationEventAction$(1u, UserCount.fixed(eventConfig.newMembers.count().toUInt()))</ID>
        <ID>ArgumentListWrapping:AddUserToConversationEventAction.kt$AddUserToConversationEventAction$(ActionType.AddUsersToConversation(1u, UserCount.fixed(eventConfig.newMembers.count().toUInt())), {})</ID>
        <ID>ArgumentListWrapping:AddUserToConversationEventAction.kt$AddUserToConversationEventAction$(eventConfig.newMembers.count().toUInt())</ID>
        <ID>ArgumentListWrapping:Administration.kt$(text = "Please init the monkey first through the /set api", status = HttpStatusCode.UnprocessableEntity)</ID>
        <ID>ArgumentListWrapping:ApiTest.kt$ApiTest$("charset", "UTF-8")</ID>
        <ID>ArgumentListWrapping:ApiTest.kt$ApiTest$(ByteReadChannel(responseBody), statusCode, assertion, headers, networkStateObserver)</ID>
        <ID>ArgumentListWrapping:ApiTest.kt$ApiTest$(ContentType.Application.JoseJson.withParameter("charset", "UTF-8"))</ID>
        <ID>ArgumentListWrapping:ApiTest.kt$ApiTest$(expected = expectedHost, actual = this.url.host)</ID>
        <ID>ArgumentListWrapping:ApiTest.kt$ApiTest$(pathAndQuery, this.url.encodedPathAndQuery)</ID>
        <ID>ArgumentListWrapping:ApiTest.kt$ApiTest$(responseBody)</ID>
        <ID>ArgumentListWrapping:ApiTest.kt$ApiTest$(this.url.parameters[name], hasValue)</ID>
        <ID>ArgumentListWrapping:ApplicationMessageHandler.kt$ApplicationMessageHandlerImpl$(content, signaling.conversationId, signaling.senderUserId)</ID>
        <ID>ArgumentListWrapping:ApplicationMessageHandler.kt$ApplicationMessageHandlerImpl$(content, signaling.conversationId, signaling.senderUserId, signaling.date)</ID>
        <ID>ArgumentListWrapping:ApplicationMessageHandler.kt$ApplicationMessageHandlerImpl$(message.conversationId, quotedReference.quotedMessageId)</ID>
        <ID>ArgumentListWrapping:ApplicationMessageHandlerTest.kt$ApplicationMessageHandlerTest$( 1000, "some-image.jpg", "image/jpg", AssetContent.AssetMetadata.Image(200, 200), AssetContent.RemoteData( ByteArray(16), ByteArray(16), "assetid", null, null, null ) )</ID>
        <ID>ArgumentListWrapping:ApplicationMessageHandlerTest.kt$ApplicationMessageHandlerTest$( ByteArray(16), ByteArray(16), "assetid", null, null, null )</ID>
        <ID>ArgumentListWrapping:ApproveLegalHoldRequestUseCaseTest.kt$ApproveLegalHoldRequestUseCaseTest.Arrangement$(teamRepository, selfTeamIdProvider)</ID>
        <ID>ArgumentListWrapping:Asset.kt$( "audio/mp3", "audio/mp4", "audio/mpeg", "audio/ogg", "audio/wav", "audio/x-wav", "audio/x-pn-wav", "audio/x-m4a" )</ID>
        <ID>ArgumentListWrapping:AssetApiV0.kt$AssetApiV0$("""ASSETS 401: "WWWAuthenticate header": "${httpResponse.headers[HttpHeaders.WWWAuthenticate]}"""")</ID>
        <ID>ArgumentListWrapping:AssetMapper.kt$AssetMapperImpl$(width = metadataType.value.width, height = metadataType.value.height)</ID>
        <ID>ArgumentListWrapping:AssetMessageHandler.kt$AssetMessageHandlerImpl$("The previously persisted message has a different sender id than the one we are trying to process")</ID>
        <ID>ArgumentListWrapping:AssetRepository.kt$AssetDataSource$( assetId, assetName.fileExtension() ?: getExtensionFromMimeType(mimeType) )</ID>
        <ID>ArgumentListWrapping:AssetRepository.kt$AssetDataSource$(EncryptionFailure.WrongAssetHash)</ID>
        <ID>ArgumentListWrapping:AssetRepository.kt$AssetDataSource$(assetId = assetId, assetDomain = assetDomain, assetName = assetId, assetToken = null, mimeType = null)</ID>
        <ID>ArgumentListWrapping:AssetRepository.kt$AssetDataSource$(assetId, assetDomain, persistentAssetDataPath, assetDataSize)</ID>
        <ID>ArgumentListWrapping:AssetRepository.kt$AssetDataSource$(assetId, extension)</ID>
        <ID>ArgumentListWrapping:AssetRepository.kt$AssetDataSource$(assetName = buildFileName(assetId, extension))</ID>
        <ID>ArgumentListWrapping:AssetRepository.kt$AssetDataSource$(assetResponse.key, assetResponse.domain, decodedDataPath, uploadAssetData.dataSize, extension)</ID>
        <ID>ArgumentListWrapping:AssetRepository.kt$AssetDataSource$(tempEncryptedDataPath, encryptedDataSize, mimeType, false, RetentionType.PERSISTENT)</ID>
        <ID>ArgumentListWrapping:AssetRepositoryTest.kt$AssetRepositoryTest$("${assetKey.value}.${assetName.fileExtension()}")</ID>
        <ID>ArgumentListWrapping:AssetRepositoryTest.kt$AssetRepositoryTest$(assetKey, stubAssetEntity(assetKey.value, assetPath, assetRawData.size.toLong()))</ID>
        <ID>ArgumentListWrapping:AssetRepositoryTest.kt$AssetRepositoryTest$(assetKey, stubAssetEntity(assetKey.value, dummyPath, expectedImage.size.toLong()))</ID>
        <ID>ArgumentListWrapping:AssetRepositoryTest.kt$AssetRepositoryTest$(assetKey.value, assetPath, assetRawData.size.toLong())</ID>
        <ID>ArgumentListWrapping:AssetRepositoryTest.kt$AssetRepositoryTest$(assetKey.value, dummyPath, expectedImage.size.toLong())</ID>
        <ID>ArgumentListWrapping:AuthTokenStorage.kt$AuthTokenStorageImpl$(authTokenEntity.userId)</ID>
        <ID>ArgumentListWrapping:AuthTokenStorage.kt$AuthTokenStorageImpl$(proxyCredentialsKey(authTokenEntity.userId), it, ProxyCredentialsEntity.serializer())</ID>
        <ID>ArgumentListWrapping:AuthTokenStorageTest.kt$AuthTokenStorageTest$(accessToken = "new_access_token", tokenType = "new_token_type", refreshToken = "new_refresh_token")</ID>
        <ID>ArgumentListWrapping:AuthTokenStorageTest.kt$AuthTokenStorageTest.Companion$("user_id", "user_domain")</ID>
        <ID>ArgumentListWrapping:AuthTokenStorageTest.kt$AuthTokenStorageTest.Companion$(UserIDEntity("user_id", "user_domain"), "access_token", "refresh_token", "token_type", "label")</ID>
        <ID>ArgumentListWrapping:AuthenticatedNetworkContainerV0.kt$AuthenticatedNetworkContainerV0$(networkClient, websocketClient, backendConfig)</ID>
        <ID>ArgumentListWrapping:AuthenticatedNetworkContainerV2.kt$AuthenticatedNetworkContainerV2$(networkClient, websocketClient, backendConfig)</ID>
        <ID>ArgumentListWrapping:AuthenticatedNetworkContainerV3.kt$AuthenticatedNetworkContainerV3$(networkClient, websocketClient, backendConfig)</ID>
        <ID>ArgumentListWrapping:AuthenticatedNetworkContainerV4.kt$AuthenticatedNetworkContainerV4$(networkClient, websocketClient, backendConfig)</ID>
        <ID>ArgumentListWrapping:AuthenticatedNetworkContainerV5.kt$AuthenticatedNetworkContainerV5$(networkClient, websocketClient, backendConfig)</ID>
        <ID>ArgumentListWrapping:AuthenticatedNetworkContainerV6.kt$AuthenticatedNetworkContainerV6$(networkClient, websocketClient, backendConfig)</ID>
        <ID>ArgumentListWrapping:AuthenticationScope.kt$AuthenticationScope$(it)</ID>
        <ID>ArgumentListWrapping:AuthenticationScope.kt$AuthenticationScope$(unauthenticatedNetworkContainer.sso, unauthenticatedNetworkContainer.domainLookupApi)</ID>
        <ID>ArgumentListWrapping:BackupCoder.kt$BackupCoder$(userId, decodedHeader.salt, decodedHeader.opslimit, decodedHeader.memlimit)</ID>
        <ID>ArgumentListWrapping:BackupUtils.kt$("There was an error trying to extract the provided compressed file", e)</ID>
        <ID>ArgumentListWrapping:BackupUtils.kt$("There was an error trying to validate the provided compressed file", e)</ID>
        <ID>ArgumentListWrapping:BackupUtils.kt$(RuntimeException("There was an error trying to extract the provided compressed file", e))</ID>
        <ID>ArgumentListWrapping:BackupUtils.kt$(RuntimeException("There was an error trying to validate the provided compressed file", e))</ID>
        <ID>ArgumentListWrapping:BackupUtils.kt$(StorageFailure.Generic(RuntimeException("There was an error trying to extract the provided compressed file", e)))</ID>
        <ID>ArgumentListWrapping:BackupUtils.kt$(StorageFailure.Generic(RuntimeException("There was an error trying to validate the provided compressed file", e)))</ID>
        <ID>ArgumentListWrapping:BaseDatabaseTest.kt$BaseDatabaseTest$(ApplicationProvider.getApplicationContext())</ID>
        <ID>ArgumentListWrapping:BaseDatabaseTest.kt$BaseDatabaseTest$(NSCachesDirectory, NSUserDomainMask, null, true, null)</ID>
        <ID>ArgumentListWrapping:BaseProteusClientTest.kt$BaseProteusClientTest$(proteusStore.value, ioContext = testCoroutineScheduler, defaultContext = testCoroutineScheduler)</ID>
        <ID>ArgumentListWrapping:CallDAOImpl.kt$CallDAOImpl$(queriesContext)</ID>
        <ID>ArgumentListWrapping:CallManagerImpl.kt$CallManagerImpl$(callRepository, callMapper, qualifiedIdMapper, scope, kaliumConfigs)</ID>
        <ID>ArgumentListWrapping:CallRepositoryTest.kt$CallRepositoryTest$(TestKaliumDispatcher.default)</ID>
        <ID>ArgumentListWrapping:CallingParticipantsOrder.kt$CallingParticipantsOrderImpl$(otherParticipants, false)</ID>
        <ID>ArgumentListWrapping:CallsScope.kt$CallsScope$(callManager, KaliumDispatcherImpl)</ID>
        <ID>ArgumentListWrapping:CallsScope.kt$CallsScope$(userConfigRepository, callRepository)</ID>
        <ID>ArgumentListWrapping:ChaCha20CoderTest.kt$ChaCha20CoderTest$(encryptedDataSource, decryptedDataOutputSink, passphrase, userId)</ID>
        <ID>ArgumentListWrapping:ChaCha20Decryptor.kt$ChaCha20Decryptor$("Error while decrypting the backup data with ChaCha20. Probably the provided password is wrong:\n $e}")</ID>
        <ID>ArgumentListWrapping:ChaCha20Decryptor.kt$ChaCha20Decryptor$("There was an error decoding backup header data. Stored hashed userId differs from the provided one:\n $e}")</ID>
        <ID>ArgumentListWrapping:ChaCha20Encryptor.kt$ChaCha20Encryptor$("There was an error decoding backup header data. Stored hashed userId differs from the provided one:\n $e}")</ID>
        <ID>ArgumentListWrapping:ClassifiedDomainsConfigHandler.kt$ClassifiedDomainsConfigHandler$(classifiedDomainsEnabled, classifiedDomainsConfig.config.domains)</ID>
        <ID>ArgumentListWrapping:ClearConversationContentUseCaseTest.kt$ClearConversationContentUseCaseTest.Arrangement$("an error")</ID>
        <ID>ArgumentListWrapping:ClearConversationContentUseCaseTest.kt$ClearConversationContentUseCaseTest.Arrangement$(CoreFailure.Unknown(Throwable("an error")))</ID>
        <ID>ArgumentListWrapping:ClearConversationContentUseCaseTest.kt$ClearConversationContentUseCaseTest.Arrangement$(Throwable("an error"))</ID>
        <ID>ArgumentListWrapping:ClearConversationContentUseCaseTest.kt$ClearConversationContentUseCaseTest.Arrangement$(Unit)</ID>
        <ID>ArgumentListWrapping:ClearConversationContentUseCaseTest.kt$ClearConversationContentUseCaseTest.Arrangement$(if (isSuccessFull) Either.Right(Unit) else Either.Left(CoreFailure.Unknown(Throwable("an error"))))</ID>
        <ID>ArgumentListWrapping:ClearUsersTypingEventsUseCaseTest.kt$ClearUsersTypingEventsUseCaseTest.Arrangement$(TypingIndicatorIncomingRepository::class)</ID>
        <ID>ArgumentListWrapping:ClientApiV0Test.kt$ClientApiV0Test$( "", statusCode = HttpStatusCode.Created, assertion = { assertDelete() assertPathEqual("/push/tokens/$pid") } )</ID>
        <ID>ArgumentListWrapping:ClientApiV0Test.kt$ClientApiV0Test$( RegisterTokenJson.registerTokenResponse, statusCode = HttpStatusCode.Created, assertion = { assertPost() assertJsonBodyContent(VALID_PUSH_TOKEN_REQUEST.rawJson) } )</ID>
        <ID>ArgumentListWrapping:ClientDAOImpl.kt$ClientDAOImpl$(queriesContext)</ID>
        <ID>ArgumentListWrapping:ClientDAOTest.kt$ClientDAOTest$(user.id, "id1", deviceType = null, isValid = true, isProteusVerified = false, isMLSCapable = true)</ID>
        <ID>ArgumentListWrapping:ClientDAOTest.kt$ClientDAOTest.Companion$(ConversationEntity.AccessRole.NON_TEAM_MEMBER, ConversationEntity.AccessRole.TEAM_MEMBER)</ID>
        <ID>ArgumentListWrapping:ClientFingerprintUseCase.kt$ClientFingerprintUseCaseImpl$(CryptoSessionId(userId.toCrypto(), CryptoClientId(clientId.value)))</ID>
        <ID>ArgumentListWrapping:ClientFingerprintUseCase.kt$ClientFingerprintUseCaseImpl$(clientId.value)</ID>
        <ID>ArgumentListWrapping:ClientFingerprintUseCase.kt$ClientFingerprintUseCaseImpl$(userId.toCrypto(), CryptoClientId(clientId.value))</ID>
        <ID>ArgumentListWrapping:ClientRegistrationStorageImpl.kt$ClientRegistrationStorageImpl$(CLIENT_REGISTRATION_BLOCKED_BY_E2EI)</ID>
        <ID>ArgumentListWrapping:ClientRegistrationStorageImpl.kt$ClientRegistrationStorageImpl$(HAS_REGISTERED_MLS_CLIENT_KEY)</ID>
        <ID>ArgumentListWrapping:ClientRegistrationStorageImpl.kt$ClientRegistrationStorageImpl$(REGISTERED_CLIENT_ID_KEY)</ID>
        <ID>ArgumentListWrapping:ClientRegistrationStorageImpl.kt$ClientRegistrationStorageImpl$(retainedClientId, RETAINED_CLIENT_ID_KEY)</ID>
        <ID>ArgumentListWrapping:ClientRegistrationStorageImpl.kt$ClientRegistrationStorageImpl$(true.toString(), HAS_REGISTERED_MLS_CLIENT_KEY)</ID>
        <ID>ArgumentListWrapping:ClientRegistrationStorageTest.kt$ClientRegistrationStorageTest$(dispatcher)</ID>
        <ID>ArgumentListWrapping:ClientRemoteRepositoryTest.kt$ClientRemoteRepositoryTest.Companion$( senderId = "7239", client = "cliId", token = "7239", transport = "GCM" )</ID>
        <ID>ArgumentListWrapping:ClientRepository.kt$ClientDataSource$(body)</ID>
        <ID>ArgumentListWrapping:ClientRepository.kt$ClientDataSource$(token)</ID>
        <ID>ArgumentListWrapping:ClientRepositoryTest.kt$ClientRepositoryTest$(it)</ID>
        <ID>ArgumentListWrapping:ClientRepositoryTest.kt$ClientRepositoryTest$(user1ClientsList.map { arrangement.clientMapper.fromClientEntity(it) }, it[userId1.toModel()])</ID>
        <ID>ArgumentListWrapping:ClientRepositoryTest.kt$ClientRepositoryTest.Arrangement$( clientRemoteRepository, clientRegistrationStorage, clientDAO, newClientDAO, selfUserId, clientApi, clientMapper )</ID>
        <ID>ArgumentListWrapping:ClientRepositoryTest.kt$ClientRepositoryTest.Companion$( 420, "forbidden", "forbidden" )</ID>
        <ID>ArgumentListWrapping:ClientScope.kt$ClientScope$(clientRepository, clientIdProvider)</ID>
        <ID>ArgumentListWrapping:ClientScope.kt$ClientScope$(proteusClientProvider, preKeyRepository)</ID>
        <ID>ArgumentListWrapping:CodeUpdatedHandler.kt$CodeUpdateHandlerImpl$( event.conversationId.toDao(), event.link(serverConfigLinks.accounts), event.isPasswordProtected )</ID>
        <ID>ArgumentListWrapping:CommitBundleEventReceiver.kt$CommitBundleEventReceiverImpl$("Unexpected event received by commit bundle: ${event.toLogString()}")</ID>
        <ID>ArgumentListWrapping:CommonAndroidConfig.kt$(ExperimentalKotlinGradlePluginApi::class)</ID>
        <ID>ArgumentListWrapping:CompositeMessageDAO.kt$CompositeMessageDAOImpl$(context)</ID>
        <ID>ArgumentListWrapping:ConnectionDAOImpl.kt$ConnectionDAOImpl$(queriesContext)</ID>
        <ID>ArgumentListWrapping:ConnectionRepository.kt$ConnectionDataSource$(connection)</ID>
        <ID>ArgumentListWrapping:ConnectionRepository.kt$ConnectionDataSource$(conversationId.toDao())</ID>
        <ID>ArgumentListWrapping:ConnectionRepository.kt$ConnectionDataSource$(it)</ID>
        <ID>ArgumentListWrapping:ConnectionRepositoryTest.kt$ConnectionRepositoryTest$(UserId(userId.value, userId.domain), ConnectionState.ACCEPTED)</ID>
        <ID>ArgumentListWrapping:ConnectionRepositoryTest.kt$ConnectionRepositoryTest$(UserId(userId.value, userId.domain), ConnectionState.NOT_CONNECTED)</ID>
        <ID>ArgumentListWrapping:ConnectionRepositoryTest.kt$ConnectionRepositoryTest$(UserId(userId.value, userId.domain), ConnectionState.PENDING)</ID>
        <ID>ArgumentListWrapping:ConnectionRepositoryTest.kt$ConnectionRepositoryTest$(userId.value, userId.domain)</ID>
        <ID>ArgumentListWrapping:ConnectionRepositoryTest.kt$ConnectionRepositoryTest.Arrangement$("An error the server threw!")</ID>
        <ID>ArgumentListWrapping:ConnectionRepositoryTest.kt$ConnectionRepositoryTest.Arrangement$(KaliumException.GenericError(RuntimeException("An error the server threw!")))</ID>
        <ID>ArgumentListWrapping:ConnectionRepositoryTest.kt$ConnectionRepositoryTest.Arrangement$(RuntimeException("An error the server threw!"))</ID>
        <ID>ArgumentListWrapping:ConnectionScope.kt$ConnectionScope$(connectionRepository)</ID>
        <ID>ArgumentListWrapping:ConnectionScope.kt$ConnectionScope$(connectionRepository, userRepository)</ID>
        <ID>ArgumentListWrapping:ConversationApiV0.kt$ConversationApiV0$(ConversationMemberRemovedResponse.Unchanged, response)</ID>
        <ID>ArgumentListWrapping:ConversationApiV0.kt$ConversationApiV0$(UpdateConversationAccessResponse.AccessUnchanged, httpResponse)</ID>
        <ID>ArgumentListWrapping:ConversationApiV0Test.kt$ConversationApiV0Test$( "", statusCode = HttpStatusCode.NoContent )</ID>
        <ID>ArgumentListWrapping:ConversationApiV0Test.kt$ConversationApiV0Test$( "", statusCode = HttpStatusCode.NoContent, assertion = { assertPost() assertPathEqual("$PATH_CONVERSATIONS/$PATH_JOIN") } )</ID>
        <ID>ArgumentListWrapping:ConversationApiV0Test.kt$ConversationApiV0Test$( "", statusCode = HttpStatusCode.NoContent, assertion = { assertPut() assertPathEqual("/conversations/anta.wire.link/ebafd3d4-1548-49f2-ac4e-b2757e6ca44b/access") assertJsonBodyContent(UPDATE_ACCESS_ROLE_REQUEST.rawJson) } )</ID>
        <ID>ArgumentListWrapping:ConversationApiV0Test.kt$ConversationApiV0Test$( "", statusCode = HttpStatusCode.NoContent, assertion = { assertPut() assertPathEqual("/conversations/conversationDomain/conversationId/members/userDomain/userId") } )</ID>
        <ID>ArgumentListWrapping:ConversationApiV0Test.kt$ConversationApiV0Test$( "", statusCode = HttpStatusCode.NoContent, assertion = { assertPut() assertPathEqual("/conversations/conversationDomain/conversationId/name") } )</ID>
        <ID>ArgumentListWrapping:ConversationApiV0Test.kt$ConversationApiV0Test$( AddServiceResponseJson.valid.rawJson, statusCode = HttpStatusCode.Created, assertion = { assertPost() assertPathEqual("conversations/${conversationId.value}/bots") assertNoQueryParams() } )</ID>
        <ID>ArgumentListWrapping:ConversationApiV0Test.kt$ConversationApiV0Test$( EventContentDTOJson.validAccessUpdate.rawJson, statusCode = HttpStatusCode.OK )</ID>
        <ID>ArgumentListWrapping:ConversationApiV0Test.kt$ConversationApiV0Test$( EventContentDTOJson.validAccessUpdateWithDeprecatedAccessRoleField.rawJson, statusCode = HttpStatusCode.OK )</ID>
        <ID>ArgumentListWrapping:ConversationApiV0Test.kt$ConversationApiV0Test$( EventContentDTOJson.validMemberJoin.rawJson, statusCode = HttpStatusCode.OK, assertion = { assertPost() assertPathEqual("$PATH_CONVERSATIONS/$PATH_JOIN") } )</ID>
        <ID>ArgumentListWrapping:ConversationApiV0Test.kt$ConversationApiV0Test$( EventContentDTOJson.validMemberJoin.rawJson, statusCode = HttpStatusCode.OK, assertion = { assertPost() assertPathEqual("$PATH_CONVERSATIONS/${conversationId.value}/$PATH_MEMBERS/$PATH_V2") } )</ID>
        <ID>ArgumentListWrapping:ConversationApiV0Test.kt$ConversationApiV0Test$( EventContentDTOJson.validMemberLeave.rawJson, statusCode = HttpStatusCode.OK, assertion = { assertDelete() assertPathEqual( "$PATH_CONVERSATIONS/${conversationId.domain}/${conversationId.value}/$PATH_MEMBERS/${userId.domain}/${userId.value}" ) } )</ID>
        <ID>ArgumentListWrapping:ConversationApiV0Test.kt$ConversationApiV0Test$( EventContentDTOJson.validNullAccessRole, statusCode = HttpStatusCode.OK )</ID>
        <ID>ArgumentListWrapping:ConversationApiV0Test.kt$ConversationApiV0Test$( MEMBER_UPDATE_REQUEST.serializableData, ConversationId(conversationId, domain) )</ID>
        <ID>ArgumentListWrapping:ConversationApiV0Test.kt$ConversationApiV0Test$( setOf(ConversationAccessDTO.PRIVATE), setOf(ConversationAccessRoleDTO.TEAM_MEMBER) )</ID>
        <ID>ArgumentListWrapping:ConversationApiV0Test.kt$ConversationApiV0Test$( setOf(ConversationAccessDTO.PRIVATE, ConversationAccessDTO.INVITE), setOf() )</ID>
        <ID>ArgumentListWrapping:ConversationApiV0Test.kt$ConversationApiV0Test$("$PATH_CONVERSATIONS/${conversationId.domain}/${conversationId.value}/${PATH_RECEIPT_MODE}")</ID>
        <ID>ArgumentListWrapping:ConversationApiV0Test.kt$ConversationApiV0Test$("ebafd3d4-1548-49f2-ac4e-b2757e6ca44b", "anta.wire.link")</ID>
        <ID>ArgumentListWrapping:ConversationApiV0Test.kt$ConversationApiV0Test$(ConversationId("ebafd3d4-1548-49f2-ac4e-b2757e6ca44b", "anta.wire.link"), accessRoles)</ID>
        <ID>ArgumentListWrapping:ConversationApiV0Test.kt$ConversationApiV0Test$(SendTypingStatusNotificationRequestJson.createValid(TypingIndicatorStatus.STOPPED).rawJson)</ID>
        <ID>ArgumentListWrapping:ConversationApiV0Test.kt$ConversationApiV0Test$(TypingIndicatorStatus.STOPPED)</ID>
        <ID>ArgumentListWrapping:ConversationApiV2Test.kt$ConversationApiV2Test$( ConversationDetailsResponse.withNullReceiptMode.rawJson, statusCode = HttpStatusCode.OK )</ID>
        <ID>ArgumentListWrapping:ConversationApiV2Test.kt$ConversationApiV2Test$( EventContentDTOJson.validMemberJoin.rawJson, statusCode = HttpStatusCode.OK, assertion = { assertPost() assertPathEqual("$PATH_CONVERSATIONS/${conversationId.domain}/${conversationId.value}/$PATH_MEMBERS") } )</ID>
        <ID>ArgumentListWrapping:ConversationApiV4.kt$ConversationApiV4$("$PATH_CONVERSATIONS/${conversationId.domain}/${conversationId.value}/$PATH_TYPING_NOTIFICATION")</ID>
        <ID>ArgumentListWrapping:ConversationApiV4Test.kt$ConversationApiV4Test$("${PATH_CONVERSATIONS}/${conversationId.domain}/${conversationId.value}/${PATH_MEMBERS}")</ID>
        <ID>ArgumentListWrapping:ConversationApiV4Test.kt$ConversationApiV4Test$("${PATH_CONVERSATIONS}/${conversationId.domain}/${conversationId.value}/${PATH_TYPING_NOTIFICATION}")</ID>
        <ID>ArgumentListWrapping:ConversationApiV4Test.kt$ConversationApiV4Test$(FederationConflictResponse(conflictingBackends))</ID>
        <ID>ArgumentListWrapping:ConversationApiV4Test.kt$ConversationApiV4Test$(SendTypingStatusNotificationRequestJson.createValid(TypingIndicatorStatus.STARTED).rawJson)</ID>
        <ID>ArgumentListWrapping:ConversationApiV4Test.kt$ConversationApiV4Test$(TypingIndicatorStatus.STARTED)</ID>
        <ID>ArgumentListWrapping:ConversationApiV4Test.kt$ConversationApiV4Test$(conflictingBackends)</ID>
        <ID>ArgumentListWrapping:ConversationApiV5.kt$ConversationApiV5$( UpdateConversationProtocolResponse.ProtocolUnchanged, httpResponse )</ID>
        <ID>ArgumentListWrapping:ConversationApiV5Test.kt$ConversationApiV5Test$("${PATH_CONVERSATIONS}/${conversationId.domain}/${conversationId.value}/${PATH_PROTOCOL}")</ID>
        <ID>ArgumentListWrapping:ConversationDAOImpl.kt$ConversationDAOImpl$(coroutineContext)</ID>
        <ID>ArgumentListWrapping:ConversationDAOImpl.kt$ConversationDAOImpl$(qualifiedID, conversationMapper::mapProtocolInfo)</ID>
        <ID>ArgumentListWrapping:ConversationDAOImpl.kt$ConversationDAOImpl$(qualifiedID, conversationMapper::toModel)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$( (result?.protocolInfo as ConversationEntity.ProtocolInfo.MLS).groupState, ConversationEntity.GroupState.PENDING_WELCOME_MESSAGE )</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$( accessRole = listOf(ConversationEntity.AccessRole.TEAM_MEMBER), access = listOf(ConversationEntity.Access.INVITE) )</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$( conversationEntity1.id, "${mySelfId.value}@${mySelfId.domain}" )</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$( expectedUserA.copy(clientId = clientCA1), conversationDAO.getE2EIConversationClientInfoByClientId(clientCA1) )</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$( expectedUserA.copy(clientId = clientCA2), conversationDAO.getE2EIConversationClientInfoByClientId(clientCA2) )</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$( expectedUserB.copy(clientId = clientCB1), conversationDAO.getE2EIConversationClientInfoByClientId(clientCB1) )</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$( expectedUserB.copy(clientId = clientCB2), conversationDAO.getE2EIConversationClientInfoByClientId(clientCB2) )</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$((conversationEntity2.protocolInfo as ConversationEntity.ProtocolInfo.MLS).groupId)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$((conversationEntity6.protocolInfo as ConversationEntity.ProtocolInfo.Mixed).groupId)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(ConversationEntity.Access.INVITE)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(ConversationEntity.AccessRole.TEAM_MEMBER)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(ConversationEntity.Type.GROUP, ConversationEntity.Protocol.PROTEUS, teamId)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(SupportedProtocolEntity.PROTEUS)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(activeOneOnOneConversationId = conversationEntity2.id, name = null)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(clientCA1)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(clientCA2)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(clientCB1)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(clientCB2)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(clientId = clientCA1)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(clientId = clientCA2)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(clientId = clientCB1)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(clientId = clientCB2)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(conversationEntity1.copy(id = userA.id, type = ConversationEntity.Type.ONE_ON_ONE))</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(conversationEntity1.copy(id = userA.id, type = ConversationEntity.Type.SELF))</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(conversationEntity1.copy(id = userB.id, type = ConversationEntity.Type.ONE_ON_ONE))</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(conversationEntity1.copy(receiptMode = ConversationEntity.ReceiptMode.ENABLED))</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(conversationEntity4.copy(protocolInfo = ConversationEntity.ProtocolInfo.Proteus))</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(conversationProtocolInfo.groupId)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(expected, conversationDAO.observeConversationByGroupID(conversationProtocolInfo.groupId).first()?.protocolInfo)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(groupId = "groupAB")</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(id = conversationId, type = ConversationEntity.Type.CONNECTION_PENDING)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(id = userA.id, type = ConversationEntity.Type.ONE_ON_ONE)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(id = userA.id, type = ConversationEntity.Type.SELF)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(id = userB.id, type = ConversationEntity.Type.ONE_ON_ONE)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(insertedClient.copy(user1.id, id = clientId), insertedClient.copy(user1.id, id = "id1"))</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(insertedClient.copy(userA.id, id = clientCA1), insertedClient.copy(userA.id, id = clientCA2))</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(insertedClient.copy(userB.id, id = clientCB1), insertedClient.copy(userB.id, id = clientCB2))</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(listOf(insertedClient.copy(user1.id, id = clientId), insertedClient.copy(user1.id, id = "id1")))</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(listOf(insertedClient.copy(userA.id, id = clientCA1), insertedClient.copy(userA.id, id = clientCA2)))</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(listOf(insertedClient.copy(userB.id, id = clientCB1), insertedClient.copy(userB.id, id = clientCB2)))</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(name = null, type = ConversationEntity.Type.GROUP, hasIncompleteMetadata = false)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(protocolInfo = ConversationEntity.ProtocolInfo.Proteus)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(receiptMode = ConversationEntity.ReceiptMode.ENABLED)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(supportedProtocols = setOf(SupportedProtocolEntity.PROTEUS))</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(team, user3.copy(supportedProtocols = setOf(SupportedProtocolEntity.PROTEUS)), conversationEntity5.id)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(user1.id, id = "id1")</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(user1.id, id = clientId)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(user1.id, protocol = ConversationEntity.Protocol.MLS)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(user1.id, protocol = ConversationEntity.Protocol.PROTEUS)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(user2.copy(activeOneOnOneConversationId = conversationEntity2.id, name = null))</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(userA.id, id = clientCA1)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(userA.id, id = clientCA2)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(userB.id, id = clientCB1)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest$(userB.id, id = clientCB2)</ID>
        <ID>ArgumentListWrapping:ConversationDAOTest.kt$ConversationDAOTest.Companion$(ConversationEntity.AccessRole.NON_TEAM_MEMBER, ConversationEntity.AccessRole.TEAM_MEMBER)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepository.kt$ConversationGroupRepositoryImpl$( conversationEntity.id, conversationResponse )</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepository.kt$ConversationGroupRepositoryImpl$( conversationEntity.id.toModel(), lastUsersAttempt.failedUsers, lastUsersAttempt.failType )</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepository.kt$ConversationGroupRepositoryImpl$( conversationEntity.id.toModel(), protocolSpecificAdditionFailures.toList(), FailedToAdd.Type.Unknown )</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepository.kt$ConversationGroupRepositoryImpl$( conversationId, (validUsers + failedUsers), failType )</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepository.kt$ConversationGroupRepositoryImpl$( conversationId, lastUsersAttempt.failedUsers, lastUsersAttempt.failType )</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepository.kt$ConversationGroupRepositoryImpl$( conversationId, userIdList + lastUsersAttempt.failedUsers, failType )</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepository.kt$ConversationGroupRepositoryImpl$( conversationResponse, mlsGroupState = ConversationEntity.GroupState.PENDING_CREATION, selfTeamId )</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepository.kt$ConversationGroupRepositoryImpl$(GroupID(groupId), userIdList)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepository.kt$ConversationGroupRepositoryImpl$(GroupID(protocol.groupId), listOf(selfUserId))</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepository.kt$ConversationGroupRepositoryImpl$(apiResult.value, selfTeamId, usersList, lastUsersAttempt)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepository.kt$ConversationGroupRepositoryImpl$(failedUsers, failType)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepository.kt$ConversationGroupRepositoryImpl$(groupId)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepository.kt$ConversationGroupRepositoryImpl$(it.usersWithConsent, it.usersWithoutConsent + it.usersFailed, FailedToAdd.Type.LegalHold)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepository.kt$ConversationGroupRepositoryImpl$(name, validUsers, options, LastUsersAttempt.Failed(failedUsers, failType))</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepository.kt$ConversationGroupRepositoryImpl$(protocol.groupId)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepository.kt$ConversationGroupRepositoryImpl$(selfUserId)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepository.kt$ConversationGroupRepositoryImpl$(validUsers, conversationId, LastUsersAttempt.Failed(failedUsers, failType))</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$( TestConversation.USER_1.copy(domain = failedDomain), TestUser.OTHER_FEDERATED_USER_ID )</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(CONVERSATION_RESPONSE, emptyMap(), 201)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(ERROR_MISSING_LEGALHOLD_CONSENT, API_SUCCESS_MEMBER_ADDED)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(ListUsersLegalHoldConsent(usersWithConsent, usersWithoutConsent, usersFailed))</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(MLSAdditionResult(setOf(TestUser.USER_ID), notAddedUsers = missingMembersFromMLSGroup))</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(MessageContent.MemberChange.FailedToAdd.Type.Federation)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(NetworkResponse.Success(CONVERSATION_RESPONSE, emptyMap(), 201))</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(NetworkResponse.Success(conversationResponse, emptyMap(), 201))</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(TestConversation.USER_1, TestUser.OTHER_FEDERATED_USER_ID_2, TestUser.OTHER_FEDERATED_USER_ID)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(TestConversation.USER_1.copy(domain = failedDomain), TestUser.OTHER_FEDERATED_USER_ID)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(TestUser.USER_ID)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(anything(), eq(listOf(unreachableUserId)), eq(MessageContent.MemberChange.FailedToAdd.Type.Federation))</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(arrangement.newGroupConversationSystemMessagesCreator::conversationFailedToAddMembers)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(arrayOf(ERROR_MISSING_LEGALHOLD_CONSENT, API_SUCCESS_MEMBER_ADDED))</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(arrayOf(NetworkResponse.Success(CONVERSATION_RESPONSE, emptyMap(), 201)))</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(arrayOf(NetworkResponse.Success(conversationResponse, emptyMap(), 201)))</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(conversationResponse, emptyMap(), 201)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(domain = failedDomain)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(expectedInitialUsersNotFromUnreachableInformed, TestConversation.ID)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(listOf(unreachableUserId))</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(setOf(TestUser.USER_ID), notAddedUsers = missingMembersFromMLSGroup)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(unreachableUserId)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(usersWithConsent, usersWithoutConsent, usersFailed)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest.Arrangement$(JoinExistingMLSConversationUseCase::class)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest.Arrangement$(newGroupConversationSystemMessagesCreator::conversationStarted, fun1&lt;ConversationEntity>())</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest.Companion$(CoreFailure.MissingKeyPackages(setOf(TestUser.OTHER_FEDERATED_USER_ID)))</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest.Companion$(TestUser.OTHER_FEDERATED_USER_ID)</ID>
        <ID>ArgumentListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest.Companion$(setOf(TestUser.OTHER_FEDERATED_USER_ID))</ID>
        <ID>ArgumentListWrapping:ConversationMapper.kt$ConversationMapperImpl$(userAvailabilityStatus)</ID>
        <ID>ArgumentListWrapping:ConversationMapperTest.kt$ConversationMapperTest$(response, mlsGroupState = null, SELF_USER_TEAM_ID)</ID>
        <ID>ArgumentListWrapping:ConversationMapperTest.kt$ConversationMapperTest.Companion$("other1", "domain1")</ID>
        <ID>ArgumentListWrapping:ConversationMapperTest.kt$ConversationMapperTest.Companion$(ConversationMemberDTO.Other(service = null, id = UserId("other1", "domain1"), conversationRole = "wire_admin"))</ID>
        <ID>ArgumentListWrapping:ConversationMapperTest.kt$ConversationMapperTest.Companion$(service = null, id = UserId("other1", "domain1"), conversationRole = "wire_admin")</ID>
        <ID>ArgumentListWrapping:ConversationMessageTimerEventHandlerTest.kt$ConversationMessageTimerEventHandlerTest$( eq(Message.System( event.id, MessageContent.ConversationMessageTimerChanged( messageTimer = event.messageTimer ), event.conversationId, event.timestampIso, event.senderUserId, Message.Status.Sent, Message.Visibility.VISIBLE, expirationData = null )))</ID>
        <ID>ArgumentListWrapping:ConversationMetaDataDAOTest.kt$ConversationMetaDataDAOTest.Companion$(ConversationEntity.AccessRole.NON_TEAM_MEMBER, ConversationEntity.AccessRole.TEAM_MEMBER)</ID>
        <ID>ArgumentListWrapping:ConversationPool.kt$ConversationPool$( conversation.conversationId, creator.internalId, conversation.members().map { it.internalId }, protocol )</ID>
        <ID>ArgumentListWrapping:ConversationPool.kt$ConversationPool$(conversation.conversationId, creator.internalId, monkeyList.map { it.internalId }, protocol)</ID>
        <ID>ArgumentListWrapping:ConversationPool.kt$ConversationPool$(name, protocol, userCount, coreLogic, monkeyPool, preset)</ID>
        <ID>ArgumentListWrapping:ConversationRepository.kt$ConversationDataSource$( memberMapper.fromApiModelToDaoModel(conversation.members), idMapper.fromApiToDao(conversation.id) )</ID>
        <ID>ArgumentListWrapping:ConversationRepository.kt$ConversationDataSource$( members.map(memberMapper::toDaoModel), conversationID.toDao() )</ID>
        <ID>ArgumentListWrapping:ConversationRepository.kt$ConversationDataSource$(conversation, lastMessageMap[conversation.id]?.let { messageMapper.fromEntityToMessagePreview(it) }, unreadEvents.firstOrNull { it.conversationId == conversation.id }?.unreadEvents?.mapKeys { when (it.key) { UnreadEventTypeEntity.KNOCK -> UnreadEventType.KNOCK UnreadEventTypeEntity.MISSED_CALL -> UnreadEventType.MISSED_CALL UnreadEventTypeEntity.MENTION -> UnreadEventType.MENTION UnreadEventTypeEntity.REPLY -> UnreadEventType.REPLY UnreadEventTypeEntity.MESSAGE -> UnreadEventType.MESSAGE } } )</ID>
        <ID>ArgumentListWrapping:ConversationRepository.kt$ConversationDataSource$(conversationId = conversationId.toDao(), notified = true)</ID>
        <ID>ArgumentListWrapping:ConversationRepository.kt$ConversationDataSource$(conversationId = conversationIdEntity, notified = false)</ID>
        <ID>ArgumentListWrapping:ConversationRepository.kt$ConversationDataSource$(idMapper.fromGroupIDEntity(it), originatedFromEvent)</ID>
        <ID>ArgumentListWrapping:ConversationRepository.kt$ConversationDataSource$(isArchived, archivedStatusTimestamp)</ID>
        <ID>ArgumentListWrapping:ConversationRepository.kt$ConversationDataSource$(it)</ID>
        <ID>ArgumentListWrapping:ConversationRepository.kt$ConversationDataSource$(member.id.toDao(), conversationID.toDao(), conversationRoleMapper.toDAO(member.role))</ID>
        <ID>ArgumentListWrapping:ConversationRepository.kt$ConversationDataSource$(member.role)</ID>
        <ID>ArgumentListWrapping:ConversationRepository.kt$ConversationDataSource$(otherUserId.toDao(), protocol.toDao())</ID>
        <ID>ArgumentListWrapping:ConversationRepository.kt$ConversationRepository.Companion$( conversationId, firstMessageId, text, mentions )</ID>
        <ID>ArgumentListWrapping:ConversationRepository.kt$ConversationRepository.Companion$( conversationId, temp.toOkioPath(), byteArray.size.toLong(), "image", type, width, height, 0L )</ID>
        <ID>ArgumentListWrapping:ConversationRepository.kt$ConversationRepository.Companion$( conversationId, text, mentions, quotedMessageId )</ID>
        <ID>ArgumentListWrapping:ConversationRepository.kt$ConversationRepository.Companion$( conversationId, text, mentions, quotedMessageId, buttons )</ID>
        <ID>ArgumentListWrapping:ConversationRepository.kt$ConversationRepository.Companion$("Instance ${instance.instanceId}: Send button action confirmation for button $buttonId")</ID>
        <ID>ArgumentListWrapping:ConversationRepository.kt$ConversationRepository.Companion$(Response.Status.OK)</ID>
        <ID>ArgumentListWrapping:ConversationRepository.kt$ConversationRepository.Companion$(SendTextResponse(instance.instanceId, "", ""))</ID>
        <ID>ArgumentListWrapping:ConversationRepository.kt$ConversationRepository.Companion$(conversationId, referenceMessageId, buttonId)</ID>
        <ID>ArgumentListWrapping:ConversationRepository.kt$ConversationRepository.Companion$(instance.instanceId, "", "")</ID>
        <ID>ArgumentListWrapping:ConversationRepositoryTest.kt$ConversationRepositoryTest$( id = conversationIdEntity, type = ConversationEntity.Type.ONE_ON_ONE, otherUserId = QualifiedIDEntity("otherUser", "domain") )</ID>
        <ID>ArgumentListWrapping:ConversationRepositoryTest.kt$ConversationRepositoryTest$(federatedDomain)</ID>
        <ID>ArgumentListWrapping:ConversationRepositoryTest.kt$ConversationRepositoryTest$(selfDomain, federatedDomain)</ID>
        <ID>ArgumentListWrapping:ConversationRepositoryTest.kt$ConversationRepositoryTest.Companion$( UpdateConversationProtocolResponse.ProtocolUnchanged, emptyMap(), 204 )</ID>
        <ID>ArgumentListWrapping:ConversationRepositoryTest.kt$ConversationRepositoryTest.Companion$( UpdateConversationProtocolResponse.ProtocolUpdated( EventContentDTO.Conversation.ProtocolUpdate( TestConversation.NETWORK_ID, ConversationProtocolDTO(ConvProtocol.MIXED), TestUser.NETWORK_ID ) ), emptyMap(), 200 )</ID>
        <ID>ArgumentListWrapping:ConversationResources.kt$ConversationResources$("id")</ID>
        <ID>ArgumentListWrapping:ConversationResponse.kt$ConversationMemberDTO.Self$("otr_muted_status")</ID>
        <ID>ArgumentListWrapping:ConversationResponse.kt$ConversationMemberDTO.Self$(with = MutedStatusSerializer::class)</ID>
        <ID>ArgumentListWrapping:ConversationResponseJson.kt$ConversationResponseJson$( conversationResponse, conversationResponseSerializer )</ID>
        <ID>ArgumentListWrapping:ConversationResponseJson.kt$ConversationResponseJson$( conversationResponse, conversationResponseSerializerWithDeprecatedAccessRole )</ID>
        <ID>ArgumentListWrapping:ConversationScope.kt$ConversationScope$(conversationGroupRepository, userRepository, refreshUsersWithoutMetadata)</ID>
        <ID>ArgumentListWrapping:ConversationScope.kt$ConversationScope$(conversationRepository = conversationRepository, userSessionCoroutineScope = scope)</ID>
        <ID>ArgumentListWrapping:ConversationStatusMapperTest.kt$ConversationStatusMapperTest$(MutedConversationStatus.OnlyMentionsAndRepliesAllowed)</ID>
        <ID>ArgumentListWrapping:ConversationStatusMapperTest.kt$ConversationStatusMapperTest$(MutedConversationStatus.OnlyMentionsAndRepliesAllowed, 1649708697237L)</ID>
        <ID>ArgumentListWrapping:ConversationTest.kt$ConversationTest$(Conversation.AccessRole.NON_TEAM_MEMBER)</ID>
        <ID>ArgumentListWrapping:ConversationTest.kt$ConversationTest$(accessRole = listOf(Conversation.AccessRole.NON_TEAM_MEMBER))</ID>
        <ID>ArgumentListWrapping:ConversationTest.kt$ConversationTest$(guestAllowed = false, servicesAllowed = false, nonTeamMembersAllowed = false)</ID>
        <ID>ArgumentListWrapping:CoreCryptoCentral.kt$CoreCryptoCentralImpl$( (enrollment as E2EIClientImpl).wireE2eIdentity, certificateChain, newMLSKeyPackageCount )</ID>
        <ID>ArgumentListWrapping:CoreCryptoCentralImpl.kt$("Not yet implemented")</ID>
        <ID>ArgumentListWrapping:CoreFailure.kt$(NetworkFailure.FederatedBackendFailure.ConflictingBackends(exception.errorResponse.nonFederatingBackends))</ID>
        <ID>ArgumentListWrapping:CoreFailure.kt$(NetworkFailure.FederatedBackendFailure.FailedDomains(exception.errorResponse.unreachableBackends))</ID>
        <ID>ArgumentListWrapping:CoreFailure.kt$(NetworkFailure.FederatedBackendFailure.FederationDenied(exception.errorResponse.label))</ID>
        <ID>ArgumentListWrapping:CoreFailure.kt$(NetworkFailure.FederatedBackendFailure.FederationNotEnabled(exception.errorResponse.label))</ID>
        <ID>ArgumentListWrapping:CoreFailure.kt$(exception.errorResponse.label)</ID>
        <ID>ArgumentListWrapping:CoreFailure.kt$(exception.errorResponse.nonFederatingBackends)</ID>
        <ID>ArgumentListWrapping:CoreFailure.kt$(exception.errorResponse.unreachableBackends)</ID>
        <ID>ArgumentListWrapping:CoreLogic.kt$CoreLogic$( rootPath = rootPath, kaliumConfigs = kaliumConfigs, userAgent = userAgent )</ID>
        <ID>ArgumentListWrapping:CreateBackupUseCase.kt$CreateBackupUseCaseImpl$( { error -> CreateBackupResult.Failure(error) }, { (backupFilePath, backupSize) -> val isBackupEncrypted = password.isNotEmpty() if (isBackupEncrypted) { encryptAndCompressFile(backupFilePath, password) } else CreateBackupResult.Success(backupFilePath, backupSize, backupFilePath.name) })</ID>
        <ID>ArgumentListWrapping:CreateBackupUseCase.kt$CreateBackupUseCaseImpl$("Failed to compress encrypted backup file")</ID>
        <ID>ArgumentListWrapping:CreateBackupUseCase.kt$CreateBackupUseCaseImpl$(RuntimeException("Failed to compress encrypted backup file"))</ID>
        <ID>ArgumentListWrapping:CreateBackupUseCase.kt$CreateBackupUseCaseImpl$(StorageFailure.Generic(RuntimeException("Failed to compress encrypted backup file")))</ID>
        <ID>ArgumentListWrapping:CreateBackupUseCase.kt$CreateBackupUseCaseImpl$(finalBackupFilePath, backupEncryptedCompressedDataSize, finalBackupFilePath.name)</ID>
        <ID>ArgumentListWrapping:CreateBackupUseCaseTest.kt$CreateBackupUseCaseTest$(dispatcher.default)</ID>
        <ID>ArgumentListWrapping:CreateBackupUseCaseTest.kt$CreateBackupUseCaseTest$(result.backupFilePath)</ID>
        <ID>ArgumentListWrapping:CreateBackupUseCaseTest.kt$CreateBackupUseCaseTest$(source(result.backupFilePath), extractedFilesPath, ExtractFilesParam.All, fakeFileSystem)</ID>
        <ID>ArgumentListWrapping:CreateConversationAction.kt$CreateConversationAction$(sender)</ID>
        <ID>ArgumentListWrapping:CreateConversationAction.kt$CreateConversationAction$(this.config.team, this.config.userCount, this.config.protocol, monkeyPool)</ID>
        <ID>ArgumentListWrapping:CreateConversationAction.kt$CreateConversationAction$(this.config.userCount, this.config.protocol, monkeyPool)</ID>
        <ID>ArgumentListWrapping:CreateGroupCommand.kt$CreateGroupCommand$("Failed to retrieve connections: ${it.storageFailure}")</ID>
        <ID>ArgumentListWrapping:CreateGroupCommand.kt$CreateGroupCommand$(ConversationOptions.Protocol.MLS)</ID>
        <ID>ArgumentListWrapping:CreateGroupCommand.kt$CreateGroupCommand$(help = "Protocol for sending messages")</ID>
        <ID>ArgumentListWrapping:CreateGroupConversationUseCase.kt$CreateGroupConversationUseCase$(creatorClientId = clientId)</ID>
        <ID>ArgumentListWrapping:CreateGroupConversationUseCase.kt$CreateGroupConversationUseCase$(name, userIdList, options.copy(creatorClientId = clientId))</ID>
        <ID>ArgumentListWrapping:CreateGroupConversationUseCaseTest.kt$CreateGroupConversationUseCaseTest$(arrangement.newGroupConversationSystemMessagesCreator::conversationReadReceiptStatus, fun1&lt;Conversation>())</ID>
        <ID>ArgumentListWrapping:CreateGroupConversationUseCaseTest.kt$CreateGroupConversationUseCaseTest$(protocol = ConversationOptions.Protocol.MLS, creatorClientId = creatorClientId)</ID>
        <ID>ArgumentListWrapping:CreateGroupConversationUseCaseTest.kt$CreateGroupConversationUseCaseTest.Arrangement$(newGroupConversationSystemMessagesCreator::conversationReadReceiptStatus, fun1&lt;Conversation>())</ID>
        <ID>ArgumentListWrapping:CryptoSessionMapperTest.kt$CryptoSessionMapperTest$(domainToUserIdTOClientIdToPrekeyMap)</ID>
        <ID>ArgumentListWrapping:CryptoUtils.kt$(data)</ID>
        <ID>ArgumentListWrapping:CryptoUtils.kt$(secretKey)</ID>
        <ID>ArgumentListWrapping:CryptographyException.kt$CryptographyException$(message, rootCause)</ID>
        <ID>ArgumentListWrapping:CustomServerConfigRepositoryTest.kt$CustomServerConfigRepositoryTest.Arrangement$(serverConfigApi, developmentApiEnabled, serverConfigurationDAO, backendMetaDataUtil)</ID>
        <ID>ArgumentListWrapping:DatabaseExporterTest.kt$DatabaseExporterTest$(id = "normal", expireAfterMs = null, sender = OTHER_USER, senderUserId = OTHER_USER.id)</ID>
        <ID>ArgumentListWrapping:DatabaseExporterTest.kt$DatabaseExporterTest$(id = "selfDelete", expireAfterMs = 10000, sender = OTHER_USER, senderUserId = OTHER_USER.id)</ID>
        <ID>ArgumentListWrapping:DatabaseExporterTest.kt$DatabaseExporterTest.Companion$( "I'm quoting others", quotedMessageId = OTHER_MESSAGE.id )</ID>
        <ID>ArgumentListWrapping:DatabaseExporterTest.kt$DatabaseExporterTest.Companion$( "I'm quoting selfUser", quotedMessageId = SELF_MESSAGE.id )</ID>
        <ID>ArgumentListWrapping:DatabaseExporterTest.kt$DatabaseExporterTest.Companion$( messageBody = "@$@${OTHER_USER_2.name}", mentions = listOf(OTHER_MENTION) )</ID>
        <ID>ArgumentListWrapping:DatabaseExporterTest.kt$DatabaseExporterTest.Companion$( messageBody = "@${SELF_USER.name} @${OTHER_USER_2.name}", mentions = listOf(SELF_MENTION) )</ID>
        <ID>ArgumentListWrapping:DatabaseExporterTest.kt$DatabaseExporterTest.Companion$( start = 0, length = 9, userId = SELF_USER_ID )</ID>
        <ID>ArgumentListWrapping:DatabaseExporterTest.kt$DatabaseExporterTest.Companion$( start = 10, length = 11, userId = OTHER_USER_2.id )</ID>
        <ID>ArgumentListWrapping:DatabaseImporterTest.kt$DatabaseImporterTest$(::mapFromDetailsToConversationEntity)</ID>
        <ID>ArgumentListWrapping:DatabaseImporterTest.kt$DatabaseImporterTest$(ConversationEntity.AccessRole.values()[index % ConversationEntity.AccessRole.values().size])</ID>
        <ID>ArgumentListWrapping:DatabaseImporterTest.kt$DatabaseImporterTest$(conversationEntity.id)</ID>
        <ID>ArgumentListWrapping:DatabaseImporterTest.kt$DatabaseImporterTest$(emptyList(), restoredMembers)</ID>
        <ID>ArgumentListWrapping:DatabaseImporterTest.kt$DatabaseImporterTest$(readDateBackup)</ID>
        <ID>ArgumentListWrapping:DatabaseImporterTest.kt$DatabaseImporterTest$(readDateBackup2)</ID>
        <ID>ArgumentListWrapping:DatabaseImporterTest.kt$DatabaseImporterTest$(userConversations.map(::mapFromDetailsToConversationEntity))</ID>
        <ID>ArgumentListWrapping:DateTimeUtilTest.kt$DateTimeUtilTest$(isoDateTimeStringWith0MillisMinus1s, isoDateTimeStringWith0Millis)</ID>
        <ID>ArgumentListWrapping:DeleteClientCommand.kt$DeleteClientCommand$("Delete client failed: ${deleteClientResult.genericFailure}")</ID>
        <ID>ArgumentListWrapping:DeleteClientCommand.kt$DeleteClientCommand$("password", promptSuffix = ": ", hideInput = true)</ID>
        <ID>ArgumentListWrapping:DeleteClientCommand.kt$DeleteClientCommand$(help = "Account password")</ID>
        <ID>ArgumentListWrapping:DeleteClientUseCase.kt$DeleteClientUseCaseImpl$( { handleError(it) }, { DeleteClientResult.Success })</ID>
        <ID>ArgumentListWrapping:DeleteClientUseCaseTest.kt$DeleteClientUseCaseTest.Arrangement$(classOf&lt;UpdateSupportedProtocolsAndResolveOneOnOnesUseCase>())</ID>
        <ID>ArgumentListWrapping:DeleteClientUseCaseTest.kt$DeleteClientUseCaseTest.Companion$("no internet")</ID>
        <ID>ArgumentListWrapping:DeleteClientUseCaseTest.kt$DeleteClientUseCaseTest.Companion$(IOException("no internet"))</ID>
        <ID>ArgumentListWrapping:DeleteClientUseCaseTest.kt$DeleteClientUseCaseTest.Companion$(KaliumException.GenericError(IOException("no internet")))</ID>
        <ID>ArgumentListWrapping:DeleteEphemeralMessageForSelfUserAsReceiverUseCaseTest.kt$DeleteEphemeralMessageForSelfUserAsReceiverUseCaseTest$( matching { it.conversationId == SELF_CONVERSION_ID.first() &amp;&amp; it.content == MessageContent.DeleteForMe(messageId, conversationId) }, matching { it == MessageTarget.Conversation() })</ID>
        <ID>ArgumentListWrapping:DeleteEphemeralMessageForSelfUserAsReceiverUseCaseTest.kt$DeleteEphemeralMessageForSelfUserAsReceiverUseCaseTest$( matching { it.conversationId == conversationId &amp;&amp; it.content == MessageContent.DeleteMessage(messageId) }, matching { it == MessageTarget.Users(listOf(senderUserID)) })</ID>
        <ID>ArgumentListWrapping:DeleteMessageUseCaseTest.kt$DeleteMessageUseCaseTest.Arrangement$(Either.Right(TestMessage.TEXT_MESSAGE.copy(status = status, expirationData = expirationData)))</ID>
        <ID>ArgumentListWrapping:DeleteMessageUseCaseTest.kt$DeleteMessageUseCaseTest.Arrangement$(TestMessage.TEXT_MESSAGE.copy(status = status, expirationData = expirationData))</ID>
        <ID>ArgumentListWrapping:DeleteMessageUseCaseTest.kt$DeleteMessageUseCaseTest.Arrangement$(status = status, expirationData = expirationData)</ID>
        <ID>ArgumentListWrapping:DestroyConversationAction.kt$DestroyConversationAction$(sender)</ID>
        <ID>ArgumentListWrapping:E2EIApiV0.kt$E2EIApiV0$(::getWireNonce.name)</ID>
        <ID>ArgumentListWrapping:E2EIClientImpl.kt$E2EIClientImpl.Companion$( value.newNonce, value.newAccount, value.newOrder )</ID>
        <ID>ArgumentListWrapping:E2EIClientTest.kt$E2EIClientTest$( user.name, user.handle, user.teamId,90.days )</ID>
        <ID>ArgumentListWrapping:E2EIRepository.kt$E2EIRepositoryImpl$(challengeResponse)</ID>
        <ID>ArgumentListWrapping:E2EIRepository.kt$E2EIRepositoryImpl$(clientId, e2eiClient, certificateChain, isNewClient)</ID>
        <ID>ArgumentListWrapping:E2EIRepository.kt$E2EIRepositoryImpl$(coreCrypto, Json.encodeToString(challengeResponse).encodeToByteArray())</ID>
        <ID>ArgumentListWrapping:E2EIRepository.kt$E2EIRepositoryImpl$(it)</ID>
        <ID>ArgumentListWrapping:E2EIRepositoryTest.kt$E2EIRepositoryTest.Arrangement.Companion$( true, RANDOM_URL, DateTimeUtil.currentInstant() )</ID>
        <ID>ArgumentListWrapping:E2EISettings.kt$E2EISettings$( isRequired, discoverUrl, gracePeriodEnd?.toEpochMilliseconds() )</ID>
        <ID>ArgumentListWrapping:EncryptedSettingsBuilderTest.kt$EncryptedSettingsBuilderTest$("test-key")</ID>
        <ID>ArgumentListWrapping:EncryptedSettingsBuilderTest.kt$EncryptedSettingsBuilderTest$(actualProperties.getProperty("test-key"), "test-value", "App settings file contains wrong property")</ID>
        <ID>ArgumentListWrapping:EncryptedSettingsBuilderTest.kt$EncryptedSettingsBuilderTest$(actualProperties.getProperty("test-key"), "test-value", "User settings file contains wrong property")</ID>
        <ID>ArgumentListWrapping:EncryptedSettingsBuilderTest.kt$EncryptedSettingsBuilderTest$(coroutineDispatcher)</ID>
        <ID>ArgumentListWrapping:EncryptedSettingsBuilderTest.kt$EncryptedSettingsBuilderTest$(rootPath, "user-pref-${userIDEntity.value}-${userIDEntity.domain}")</ID>
        <ID>ArgumentListWrapping:EndCallOnConversationChangeUseCaseTest.kt$EndCallOnConversationChangeUseCaseTest$(proteusVerificationStatus = Conversation.VerificationStatus.DEGRADED)</ID>
        <ID>ArgumentListWrapping:EndCallOnConversationChangeUseCaseTest.kt$EndCallOnConversationChangeUseCaseTest.Companion$(Conversation.AccessRole.GUEST)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(OIDC_AUTHZ.challenge)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(RANDOM_DPoP_TOKEN)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(RANDOM_ID_TOKEN)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(RANDOM_ID_TOKEN, REFRESH_TOKEN, INITIALIZATION_RESULT)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(REFRESH_TOKEN)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(any&lt;Nonce>())</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(any&lt;Nonce>(), any&lt;List&lt;String>>())</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(any&lt;Nonce>(), any&lt;String>())</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(any&lt;String>())</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(any&lt;String>(), any&lt;Nonce>())</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(arrangement.e2EIRepository)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(arrangement.e2EIRepository::certificateRequest)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(arrangement.e2EIRepository::checkOrderRequest)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(arrangement.e2EIRepository::createNewAccount)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(arrangement.e2EIRepository::createNewOrder)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(arrangement.e2EIRepository::fetchAndSetTrustAnchors)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(arrangement.e2EIRepository::finalize)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(arrangement.e2EIRepository::getACMENonce)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(arrangement.e2EIRepository::getAuthorizations)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(arrangement.e2EIRepository::getDPoPToken)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(arrangement.e2EIRepository::getOAuthRefreshToken)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(arrangement.e2EIRepository::getWireAccessToken)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(arrangement.e2EIRepository::getWireNonce)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(arrangement.e2EIRepository::loadACMEDirectories)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(arrangement.e2EIRepository::rotateKeysAndMigrateConversations)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(arrangement.e2EIRepository::validateDPoPChallenge)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(arrangement.e2EIRepository::validateOIDCChallenge)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(eq(RANDOM_DPoP_TOKEN))</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(eq(RANDOM_ID_TOKEN), eq(REFRESH_TOKEN), any&lt;Nonce>(), eq(OIDC_AUTHZ.challenge))</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$(exactly = once)</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest.Companion$( identifier = "identifier", keyAuth = null, challenge = ACME_CHALLENGE )</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest.Companion$( oidcAuthorization = OIDC_AUTHZ, dpopAuthorization = DPOP_AUTHZ, nonce = RANDOM_NONCE )</ID>
        <ID>ArgumentListWrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest.Companion$( target = ACME_CHALLENGE.target, oAuthState = REFRESH_TOKEN, dPopAuthorizations = DPOP_AUTHZ, oidcAuthorizations = OIDC_AUTHZ, oAuthClaims = OAUTH_CLAIMS, lastNonce = RANDOM_NONCE, orderLocation = RANDOM_LOCATION )</ID>
        <ID>ArgumentListWrapping:EnrollE2EIUseCase.kt$EnrollE2EIUseCaseImpl$( idToken, oAuthState, prevNonce, oidcAuthorizations.challenge )</ID>
        <ID>ArgumentListWrapping:EnrollE2EIUseCase.kt$EnrollE2EIUseCaseImpl$( wireAccessToken.token, prevNonce, dPopAuthorizations.challenge )</ID>
        <ID>ArgumentListWrapping:EnvelopeProtoMapper.kt$EnvelopeProtoMapperImpl$( envelopeParameters.messageOption.userIDs.map { QualifiedUserId(it.value, it.domain) })</ID>
        <ID>ArgumentListWrapping:EnvelopeProtoMapperTest.kt$EnvelopeProtoMapperTest$( user, mapOf( Pair("241b5be49179d81b", ByteArray(0)), Pair("8bdacec7398a982e", ByteArray(0)), Pair("e47d908549239b72", ByteArray(0)), Pair("4c8346ce67fa0d7", ByteArray(0)) ) )</ID>
        <ID>ArgumentListWrapping:EphemeralMessageDeletionHandlerTest.kt$EphemeralMessageDeletionHandlerTest.Arrangement$(classOf&lt;DeleteEphemeralMessageForSelfUserAsSenderUseCase>())</ID>
        <ID>ArgumentListWrapping:EventContentDTO.kt$EventContentDTO.Conversation.MemberJoinDTO$("from")</ID>
        <ID>ArgumentListWrapping:EventContentDTO.kt$EventContentDTO.Conversation.MemberJoinDTO$("this.qualifiedFrom")</ID>
        <ID>ArgumentListWrapping:EventContentDTO.kt$EventContentDTO.Conversation.MemberJoinDTO$("use qualifiedFrom", replaceWith = ReplaceWith("this.qualifiedFrom"))</ID>
        <ID>ArgumentListWrapping:EventContentDTO.kt$JsonCorrectingSerializer$(FeatureConfigUpdatedDTOSerializer)</ID>
        <ID>ArgumentListWrapping:EventGatherer.kt$EventGathererImpl$("Unknown Websocket error: $cause, message: ${cause.message}", CoreFailure.Unknown(cause))</ID>
        <ID>ArgumentListWrapping:EventGatherer.kt$EventGathererImpl$(cause)</ID>
        <ID>ArgumentListWrapping:EventGathererTest.kt$EventGathererTest$(TestEvent.newConnection(eventId = "event_$value").wrapInEnvelope())</ID>
        <ID>ArgumentListWrapping:EventGathererTest.kt$EventGathererTest$(WebSocketEvent.BinaryPayloadReceived(TestEvent.newConnection(eventId = "event_$value").wrapInEnvelope()))</ID>
        <ID>ArgumentListWrapping:EventGathererTest.kt$EventGathererTest$(eventId = "event_$value")</ID>
        <ID>ArgumentListWrapping:EventRepository.kt$EventDataSource$(it)</ID>
        <ID>ArgumentListWrapping:EventRepository.kt$EventDataSource$(webSocketEvent.payload, true)</ID>
        <ID>ArgumentListWrapping:EventRepositoryTest.kt$EventRepositoryTest.Arrangement$(notificationApi, metaDAO, clientIdProvider, TestUser.SELF.id)</ID>
        <ID>ArgumentListWrapping:FeatureConfigEventReceiver.kt$FeatureConfigEventReceiverImpl$(event.model, duringSlowSync = false)</ID>
        <ID>ArgumentListWrapping:FeatureConfigEventReceiverTest.kt$FeatureConfigEventReceiverTest$( SelfDeletingMessagesConfigModel( enforcedTimeoutSeconds = null ), Status.DISABLED )</ID>
        <ID>ArgumentListWrapping:FeatureConfigEventReceiverTest.kt$FeatureConfigEventReceiverTest$( SelfDeletingMessagesConfigModel(enforcedTimeoutSeconds = 0), Status.ENABLED )</ID>
        <ID>ArgumentListWrapping:FeatureConfigEventReceiverTest.kt$FeatureConfigEventReceiverTest$( SelfDeletingMessagesConfigModel(enforcedTimeoutSeconds = newEnforcedDuration.inWholeSeconds), Status.ENABLED )</ID>
        <ID>ArgumentListWrapping:FeatureConfigEventReceiverTest.kt$FeatureConfigEventReceiverTest$( SelfDeletingMessagesConfigModel(enforcedTimeoutSeconds = newEnforcedTimeoutSeconds), Status.DISABLED )</ID>
        <ID>ArgumentListWrapping:FeatureConfigEventReceiverTest.kt$FeatureConfigEventReceiverTest$( SelfDeletingMessagesConfigModel(enforcedTimeoutSeconds = newEnforcedTimeoutSeconds), Status.ENABLED )</ID>
        <ID>ArgumentListWrapping:FeatureConfigEventReceiverTest.kt$FeatureConfigEventReceiverTest$(Either.Right(FileSharingStatus(state = FileSharingStatus.Value.Disabled, isStatusChanged = false)))</ID>
        <ID>ArgumentListWrapping:FeatureConfigEventReceiverTest.kt$FeatureConfigEventReceiverTest$(Either.Right(FileSharingStatus(state = FileSharingStatus.Value.EnabledAll, isStatusChanged = false)))</ID>
        <ID>ArgumentListWrapping:FeatureConfigEventReceiverTest.kt$FeatureConfigEventReceiverTest$(FileSharingStatus(state = FileSharingStatus.Value.Disabled, isStatusChanged = false))</ID>
        <ID>ArgumentListWrapping:FeatureConfigEventReceiverTest.kt$FeatureConfigEventReceiverTest$(FileSharingStatus(state = FileSharingStatus.Value.EnabledAll, isStatusChanged = false))</ID>
        <ID>ArgumentListWrapping:FeatureConfigEventReceiverTest.kt$FeatureConfigEventReceiverTest$(enforcedTimeoutSeconds = newEnforcedDuration.inWholeSeconds)</ID>
        <ID>ArgumentListWrapping:FeatureConfigEventReceiverTest.kt$FeatureConfigEventReceiverTest$(state = FileSharingStatus.Value.Disabled, isStatusChanged = false)</ID>
        <ID>ArgumentListWrapping:FeatureConfigEventReceiverTest.kt$FeatureConfigEventReceiverTest$(state = FileSharingStatus.Value.EnabledAll, isStatusChanged = false)</ID>
        <ID>ArgumentListWrapping:FeatureConfigEventReceiverTest.kt$FeatureConfigEventReceiverTest.Arrangement$(classOf&lt;UpdateSupportedProtocolsAndResolveOneOnOnesUseCase>())</ID>
        <ID>ArgumentListWrapping:FeatureConfigJson.kt$FeatureConfigJson$( AppLockConfigDTO(true, 0), FeatureFlagStatusDTO.ENABLED )</ID>
        <ID>ArgumentListWrapping:FeatureConfigMapperTest.kt$FeatureConfigMapperTest.Arrangement$( MLSConfigDTO( SupportedProtocolDTO.MLS, listOf(SupportedProtocolDTO.MLS), emptyList(), 1 ), FeatureFlagStatusDTO.ENABLED )</ID>
        <ID>ArgumentListWrapping:FeatureConfigRepositoryTest.kt$FeatureConfigRepositoryTest.Arrangement$( AppLockConfigDTO(true, 0), FeatureFlagStatusDTO.ENABLED )</ID>
        <ID>ArgumentListWrapping:FeatureConfigRepositoryTest.kt$FeatureConfigRepositoryTest.Arrangement$( MLSConfigDTO( SupportedProtocolDTO.PROTEUS, listOf(SupportedProtocolDTO.PROTEUS), emptyList(), 1 ), FeatureFlagStatusDTO.ENABLED )</ID>
        <ID>ArgumentListWrapping:FederationEventReceiver.kt$FederationEventReceiverImpl$(conversationId, userIds.filter { it.domain == firstDomain })</ID>
        <ID>ArgumentListWrapping:FederationEventReceiver.kt$FederationEventReceiverImpl$(conversationId, userIds.filter { it.domain == secondDomain })</ID>
        <ID>ArgumentListWrapping:FederationEventReceiver.kt$FederationEventReceiverImpl$(conversationId, userIds.filter { it.domain == selfUserId.domain })</ID>
        <ID>ArgumentListWrapping:FederationEventReceiver.kt$FederationEventReceiverImpl$(conversationId, userIds.filterNot { it.domain == selfUserId.domain })</ID>
        <ID>ArgumentListWrapping:FederationEventReceiverTest.kt$FederationEventReceiverTest$(defederatedUsersCount)</ID>
        <ID>ArgumentListWrapping:FederationEventReceiverTest.kt$FederationEventReceiverTest$(defederatedUsersCountTwo)</ID>
        <ID>ArgumentListWrapping:FederationEventReceiverTest.kt$FederationEventReceiverTest$(value = "defId$it", domain = defederatedDomain)</ID>
        <ID>ArgumentListWrapping:FederationEventReceiverTest.kt$FederationEventReceiverTest$(value = "defIdTwo$it", domain = defederatedDomainTwo)</ID>
        <ID>ArgumentListWrapping:FetchUsersClientsFromRemoteUseCaseTest.kt$FetchUsersClientsFromRemoteUseCaseTest$( SimpleClientResponse("111", DeviceTypeDTO.Phone), SimpleClientResponse("2222", DeviceTypeDTO.Desktop) )</ID>
        <ID>ArgumentListWrapping:GetAssetMessagesForConversationUseCaseTest.kt$GetAssetMessagesForConversationUseCaseTest$(testDispatcher.default)</ID>
        <ID>ArgumentListWrapping:GetAssetSizeLimitUseCaseTest.kt$GetAssetSizeLimitUseCaseTest$(dispatcher.default)</ID>
        <ID>ArgumentListWrapping:GetIncomingCallsUseCaseTest.kt$GetIncomingCallsUseCaseTest$(conversationWithMuteStatus(id, MutedConversationStatus.AllAllowed))</ID>
        <ID>ArgumentListWrapping:GetIncomingCallsUseCaseTest.kt$GetIncomingCallsUseCaseTest$(id, MutedConversationStatus.AllAllowed)</ID>
        <ID>ArgumentListWrapping:GetMessageAssetUseCase.kt$GetMessageAssetUseCaseImpl$("The message associated to this id, was not an asset message")</ID>
        <ID>ArgumentListWrapping:GetMessageAssetUseCase.kt$GetMessageAssetUseCaseImpl$("There was an error downloading asset with id => ${assetMetadata.assetKey.obfuscateId()}")</ID>
        <ID>ArgumentListWrapping:GetMessageAssetUseCase.kt$GetMessageAssetUseCaseImpl$(AssetTransferStatus.FAILED_DOWNLOAD, conversationId, messageId)</ID>
        <ID>ArgumentListWrapping:GetMessageAssetUseCase.kt$GetMessageAssetUseCaseImpl$(AssetTransferStatus.NOT_FOUND, conversationId, messageId)</ID>
        <ID>ArgumentListWrapping:GetMessageAssetUseCase.kt$GetMessageAssetUseCaseImpl$(AssetTransferStatus.SAVED_INTERNALLY, conversationId, messageId)</ID>
        <ID>ArgumentListWrapping:GetMessageAssetUseCase.kt$GetMessageAssetUseCaseImpl$(IllegalStateException("The message associated to this id, was not an asset message"))</ID>
        <ID>ArgumentListWrapping:GetMessageAssetUseCase.kt$GetMessageAssetUseCaseImpl$(QualifiedID(assetMetadata.assetKey, domain))</ID>
        <ID>ArgumentListWrapping:GetMessageAssetUseCase.kt$GetMessageAssetUseCaseImpl$(assetMetadata.assetKey, domain)</ID>
        <ID>ArgumentListWrapping:GetMessageAssetUseCase.kt$GetMessageAssetUseCaseImpl$(decodedAssetPath, assetMetadata.assetSize, assetMetadata.assetName)</ID>
        <ID>ArgumentListWrapping:GetMessageAssetUseCase.kt$GetMessageAssetUseCaseImpl$(it, false)</ID>
        <ID>ArgumentListWrapping:GetMessageAssetUseCaseTest.kt$GetMessageAssetUseCaseTest$(arrangement.mockedImageContent.remoteData.assetId)</ID>
        <ID>ArgumentListWrapping:GetMessageAssetUseCaseTest.kt$GetMessageAssetUseCaseTest$(conversationId = someConversationId, messageId = someMessageId, encryptedPath = encryptedPath)</ID>
        <ID>ArgumentListWrapping:GetMessageAssetUseCaseTest.kt$GetMessageAssetUseCaseTest$(eq(arrangement.mockedImageContent.remoteData.assetId), any(), any(), any(), any(), any(), any(), any())</ID>
        <ID>ArgumentListWrapping:GetMessageAssetUseCaseTest.kt$GetMessageAssetUseCaseTest$(eq(arrangement.mockedImageContent.remoteData.assetId), any(), any(), any(), any(), any(), any(), eq(true))</ID>
        <ID>ArgumentListWrapping:GetMessageAssetUseCaseTest.kt$GetMessageAssetUseCaseTest$(testDispatcher.default)</ID>
        <ID>ArgumentListWrapping:GetMessageAssetUseCaseTest.kt$GetMessageAssetUseCaseTest$(true)</ID>
        <ID>ArgumentListWrapping:GetMessageAssetUseCaseTest.kt$GetMessageAssetUseCaseTest.Arrangement$( assetDataSource, messageRepository, userRepository, updateAssetMessageTransferStatus, testScope, testDispatcher )</ID>
        <ID>ArgumentListWrapping:GetMessageByIdUseCaseTest.kt$GetMessageByIdUseCaseTest$(testDispatchers.io)</ID>
        <ID>ArgumentListWrapping:GetNotificationsUseCaseTest.kt$GetNotificationsUseCaseTest$( conversationId(1), "some convo", listOf(), false )</ID>
        <ID>ArgumentListWrapping:GetPaginatedFlowOfMessagesByConversationUseCase.kt$GetPaginatedFlowOfMessagesByConversationUseCase$( conversationId, visibility, pagingConfig, startingOffset )</ID>
        <ID>ArgumentListWrapping:GetPaginatedFlowOfMessagesBySearchQueryAndConversationIdUseCase.kt$GetPaginatedFlowOfMessagesBySearchQueryAndConversationIdUseCase$( searchQuery, conversationId, pagingConfig, startingOffset )</ID>
        <ID>ArgumentListWrapping:GetPublicAssetUseCaseTest.kt$GetPublicAssetUseCaseTest$(NetworkFailure.FederatedBackendFailure.General::class, (publicAsset as PublicAssetResult.Failure).coreFailure::class)</ID>
        <ID>ArgumentListWrapping:GetPublicAssetUseCaseTest.kt$GetPublicAssetUseCaseTest$(NetworkFailure.ServerMiscommunication::class, (publicAsset as PublicAssetResult.Failure).coreFailure::class)</ID>
        <ID>ArgumentListWrapping:GetServerConfigUseCase.kt$GetServerConfigUseCase$(url)</ID>
        <ID>ArgumentListWrapping:GetSessionsUseCase.kt$GetSessionsUseCase$( { when (it) { StorageFailure.DataNotFound -> GetAllSessionsResult.Failure.NoSessionFound is StorageFailure.Generic -> GetAllSessionsResult.Failure.Generic(it) } }, { GetAllSessionsResult.Success(it) } )</ID>
        <ID>ArgumentListWrapping:GetUserInfoUseCase.kt$GetUserInfoUseCaseImpl$( { GetUserInfoResult.Failure }, { team -> GetUserInfoResult.Success(otherUser, team) })</ID>
        <ID>ArgumentListWrapping:GlobalDBBaseTest.kt$GlobalDBBaseTest$("test_db_secret".toByteArray())</ID>
        <ID>ArgumentListWrapping:GlobalDBBaseTest.kt$GlobalDBBaseTest$(ApplicationProvider.getApplicationContext(), GlobalDatabaseSecret("test_db_secret".toByteArray()))</ID>
        <ID>ArgumentListWrapping:GlobalDBBaseTest.kt$GlobalDBBaseTest$(NSCachesDirectory, NSUserDomainMask, null, true, null)</ID>
        <ID>ArgumentListWrapping:GlobalKaliumScope.kt$GlobalKaliumScope$(customServerConfigRepository)</ID>
        <ID>ArgumentListWrapping:GlobalPrefProvider.kt$GlobalPrefProvider$(SettingOptions.AppSettings(shouldEncryptData), EncryptedSettingsPlatformParam(context))</ID>
        <ID>ArgumentListWrapping:GlobalPrefProvider.kt$GlobalPrefProvider$(context)</ID>
        <ID>ArgumentListWrapping:GlobalPrefProvider.kt$GlobalPrefProvider$(shouldEncryptData)</ID>
        <ID>ArgumentListWrapping:GuestRoomConfigHandler.kt$GuestRoomConfigHandler$( { false }, { it.isGuestRoomLinkEnabled != status } )</ID>
        <ID>ArgumentListWrapping:HandleExternalRequestAction.kt$( """ Hey there, I hope you're doing well. I've got a bit of a craving for bananas, and I was wondering if you might be able to share a few with me? It would mean a lot.  Thanks a bunch, A friendly monkey  """.trimIndent(), """ Yo, I'm in need of some bananas, my friend. Can you hook me up? I'd appreciate it big time. Respect, A neutral monkey  """.trimIndent(), """ Listen up, I ain't messin' around. I want them bananas, and I want 'em now. You better deliver or there'll be consequences. No games, An evil monkey  """.trimIndent() )</ID>
        <ID>ArgumentListWrapping:IncrementalSyncManager.kt$IncrementalSyncManager$("$TAG IncrementalSync finished normally. Starting to observe ConnectionPolicy upgrade")</ID>
        <ID>ArgumentListWrapping:IncrementalSyncManagerTest.kt$IncrementalSyncManagerTest$(TestKaliumDispatcher.default)</ID>
        <ID>ArgumentListWrapping:IncrementalSyncManagerTest.kt$IncrementalSyncManagerTest.Arrangement$(classOf&lt;IncrementalSyncRepository>())</ID>
        <ID>ArgumentListWrapping:IncrementalSyncManagerTest.kt$IncrementalSyncManagerTest.Arrangement$(mock(classOf&lt;IncrementalSyncRepository>()))</ID>
        <ID>ArgumentListWrapping:IncrementalSyncWorkerTest.kt$IncrementalSyncWorkerTest$(TestKaliumDispatcher.default)</ID>
        <ID>ArgumentListWrapping:InstanceService.kt$InstanceService$( instanceRequest.email, instanceRequest.password, true, secondFactorVerificationCode = instanceRequest.verificationCode )</ID>
        <ID>ArgumentListWrapping:InstanceService.kt$InstanceService$( loginResult.serverConfigId, loginResult.ssoID, loginResult.authData, null, true )</ID>
        <ID>ArgumentListWrapping:InstanceService.kt$InstanceService$("Instance $instanceId: Client registration failed, 2FA code needed for account")</ID>
        <ID>ArgumentListWrapping:InstanceService.kt$InstanceService$("Instance $instanceId: Client registration failed, invalid 2FA code")</ID>
        <ID>ArgumentListWrapping:InstanceService.kt$InstanceService$("Instance $instanceId: Client registration failed, invalid password")</ID>
        <ID>ArgumentListWrapping:InstanceService.kt$InstanceService$("Instance $instanceId: Client registration failed, missing password")</ID>
        <ID>ArgumentListWrapping:InstanceService.kt$InstanceService$("Instance $instanceId: Client registration failed, too many clients")</ID>
        <ID>ArgumentListWrapping:InstanceService.kt$InstanceService$("Instance $instanceId: Login with ${instanceRequest.email} on ${instanceRequest.customBackend.rest}")</ID>
        <ID>ArgumentListWrapping:InstanceService.kt$InstanceService$(MetricRegistry.name("testservice", "instances", "total", "size"), Gauge { instances.size })</ID>
        <ID>ArgumentListWrapping:InstanceServiceTest.kt$InstanceServiceTest$("No directory for coreLogic was created", File(instancePath).exists())</ID>
        <ID>ArgumentListWrapping:InstanceServiceTest.kt$InstanceServiceTest$("No global-storage/global-db file found in $instancePath", File("$instancePath/global-storage/global-db").exists())</ID>
        <ID>ArgumentListWrapping:JoinConversationViaCodeUseCaseTest.kt$JoinConversationViaCodeUseCaseTest$( code, key, null, password, Either.Left( NetworkFailure.ServerMiscommunication( KaliumException.InvalidRequestError( ErrorResponse(403, "wrong password", "invalid-conversation-password") ) ) ) )</ID>
        <ID>ArgumentListWrapping:JoinExistingMLSConversationUseCaseTest.kt$JoinExistingMLSConversationUseCaseTest$(Arrangement.MLS_UNESTABLISHED_ONE_ONE_ONE_CONVERSATION.id)</ID>
        <ID>ArgumentListWrapping:JoinExistingMLSConversationsUseCase.kt$JoinExistingMLSConversationsUseCaseImpl$(GroupState.PENDING_JOIN)</ID>
        <ID>ArgumentListWrapping:KaliumHttpLogger.kt$KaliumHttpLogger$(request.headers.entries().map { it.key to it.value })</ID>
        <ID>ArgumentListWrapping:KaliumHttpLogger.kt$KaliumHttpLogger$(response.headers.entries().map { it.key to it.value })</ID>
        <ID>ArgumentListWrapping:KeyPackageManager.kt$KeyPackageManagerImpl$(LAST_KEY_PACKAGE_COUNT_CHECK)</ID>
        <ID>ArgumentListWrapping:KeyPackageManagerTests.kt$KeyPackageManagerTests.Arrangement$( TestClient.CLIENT_ID, 0, true )</ID>
        <ID>ArgumentListWrapping:KeyPackageRepository.kt$KeyPackageDataSource$(KeyPackageApi.Param.SkipOwnClient(userId.toApi(), selfClientId.value))</ID>
        <ID>ArgumentListWrapping:KeyPackageRepository.kt$KeyPackageDataSource$(userId.toApi(), selfClientId.value)</ID>
        <ID>ArgumentListWrapping:KeyPackageRepositoryTest.kt$KeyPackageRepositoryTest$(Arrangement.CLAIMED_KEY_PACKAGES.keyPackages[0])</ID>
        <ID>ArgumentListWrapping:KeyPackageRepositoryTest.kt$KeyPackageRepositoryTest$(listOf(Arrangement.CLAIMED_KEY_PACKAGES.keyPackages[0]), keyPackageResult.successfullyFetchedKeyPackages)</ID>
        <ID>ArgumentListWrapping:KeyPackageRepositoryTest.kt$KeyPackageRepositoryTest.Arrangement$(1)</ID>
        <ID>ArgumentListWrapping:KeyPackageRepositoryTest.kt$KeyPackageRepositoryTest.Arrangement$(MLS_CLIENT)</ID>
        <ID>ArgumentListWrapping:KeyPackageRepositoryTest.kt$KeyPackageRepositoryTest.Arrangement$(MLS_CLIENT::generateKeyPackages)</ID>
        <ID>ArgumentListWrapping:KeyPackageRepositoryTest.kt$KeyPackageRepositoryTest.Arrangement$(SELF_CLIENT_ID)</ID>
        <ID>ArgumentListWrapping:KeyPackageRepositoryTest.kt$KeyPackageRepositoryTest.Arrangement$(SELF_CLIENT_ID.value)</ID>
        <ID>ArgumentListWrapping:KeyPackageRepositoryTest.kt$KeyPackageRepositoryTest.Arrangement$(anything(), anything())</ID>
        <ID>ArgumentListWrapping:KeyPackageRepositoryTest.kt$KeyPackageRepositoryTest.Arrangement$(eq(1))</ID>
        <ID>ArgumentListWrapping:KeyPackageRepositoryTest.kt$KeyPackageRepositoryTest.Arrangement$(eq(SELF_CLIENT_ID))</ID>
        <ID>ArgumentListWrapping:KeyPackageRepositoryTest.kt$KeyPackageRepositoryTest.Arrangement$(eq(SELF_CLIENT_ID.value))</ID>
        <ID>ArgumentListWrapping:KeyPackageRepositoryTest.kt$KeyPackageRepositoryTest.Arrangement$(keyPackageApi)</ID>
        <ID>ArgumentListWrapping:KeyPackageRepositoryTest.kt$KeyPackageRepositoryTest.Arrangement$(keyPackageApi::getAvailableKeyPackageCount)</ID>
        <ID>ArgumentListWrapping:KeyPackageRepositoryTest.kt$KeyPackageRepositoryTest.Arrangement$(keyPackageApi::uploadKeyPackages)</ID>
        <ID>ArgumentListWrapping:KeyPackageRepositoryTest.kt$KeyPackageRepositoryTest.Arrangement$(mlsClientProvider)</ID>
        <ID>ArgumentListWrapping:KeyPackageRepositoryTest.kt$KeyPackageRepositoryTest.Arrangement$(mlsClientProvider::getMLSClient)</ID>
        <ID>ArgumentListWrapping:LastReadContentHandler.kt$LastReadContentHandlerImpl$(messageContent.conversationId)</ID>
        <ID>ArgumentListWrapping:LeaveConversationAction.kt$LeaveConversationAction$(sender)</ID>
        <ID>ArgumentListWrapping:LegalHoldHandler.kt$LegalHoldHandlerImpl$("missing legal hold consent for connection with user ${connection.qualifiedToId.toLogString()}")</ID>
        <ID>ArgumentListWrapping:LegalHoldHandler.kt$LegalHoldHandlerImpl$(connection.qualifiedConversationId, Conversation.LegalHoldStatus.DEGRADED)</ID>
        <ID>ArgumentListWrapping:LegalHoldHandler.kt$LegalHoldHandlerImpl$(conversationId, newLegalHoldStatusAfterMembersChange)</ID>
        <ID>ArgumentListWrapping:LegalHoldHandler.kt$LegalHoldHandlerImpl$(conversationId, newStatus, systemMessageTimestampIso)</ID>
        <ID>ArgumentListWrapping:LegalHoldHandler.kt$LegalHoldHandlerImpl$(conversationId, systemMessageTimestampIso)</ID>
        <ID>ArgumentListWrapping:LegalHoldHandler.kt$LegalHoldHandlerImpl$(legalHoldDisabled.userId, DateTimeUtil.currentIsoDateTimeString())</ID>
        <ID>ArgumentListWrapping:LegalHoldHandler.kt$LegalHoldHandlerImpl$(legalHoldEnabled.userId, DateTimeUtil.currentIsoDateTimeString())</ID>
        <ID>ArgumentListWrapping:LegalHoldHandler.kt$LegalHoldHandlerImpl$(listOf(message.conversationId), systemMessageTimestampIso)</ID>
        <ID>ArgumentListWrapping:LegalHoldHandler.kt$LegalHoldHandlerImpl$(message.conversationId)</ID>
        <ID>ArgumentListWrapping:LegalHoldHandler.kt$LegalHoldHandlerImpl$(userId, systemMessageTimestampIso)</ID>
        <ID>ArgumentListWrapping:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$(LegalHoldState.Enabled)</ID>
        <ID>ArgumentListWrapping:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$(conversation(legalHoldStatus = Conversation.LegalHoldStatus.DISABLED))</ID>
        <ID>ArgumentListWrapping:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$(conversation(legalHoldStatus = Conversation.LegalHoldStatus.ENABLED))</ID>
        <ID>ArgumentListWrapping:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$(legalHoldStatus = Conversation.LegalHoldStatus.DISABLED)</ID>
        <ID>ArgumentListWrapping:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$(legalHoldStatus = Conversation.LegalHoldStatus.ENABLED)</ID>
        <ID>ArgumentListWrapping:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$(listOf(conversation(legalHoldStatus = Conversation.LegalHoldStatus.DISABLED)))</ID>
        <ID>ArgumentListWrapping:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$(listOf(conversation(legalHoldStatus = Conversation.LegalHoldStatus.ENABLED)))</ID>
        <ID>ArgumentListWrapping:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$(membersHavingLegalHoldClientBefore, membersHavingLegalHoldClientAfter)</ID>
        <ID>ArgumentListWrapping:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$(userId)</ID>
        <ID>ArgumentListWrapping:LegalHoldHandlerTest.kt$LegalHoldHandlerTest.Arrangement$(LegalHoldSystemMessagesHandler::class)</ID>
        <ID>ArgumentListWrapping:LegalHoldHandlerTest.kt$LegalHoldHandlerTest.Arrangement$(mock(LegalHoldSystemMessagesHandler::class))</ID>
        <ID>ArgumentListWrapping:LegalHoldSystemMessageHandlerTest.kt$LegalHoldSystemMessagesHandlerTest$(MessageContent.LegalHold.ForMembers.Disabled(listOf(TestUser.OTHER_USER_ID_2)))</ID>
        <ID>ArgumentListWrapping:LegalHoldSystemMessageHandlerTest.kt$LegalHoldSystemMessagesHandlerTest$(MessageContent.LegalHold.ForMembers.Enabled(listOf(TestUser.OTHER_USER_ID_2)))</ID>
        <ID>ArgumentListWrapping:LegalHoldSystemMessageHandlerTest.kt$LegalHoldSystemMessagesHandlerTest$(TestConversation.CONVERSATION.id to TestMessage.TEXT_MESSAGE)</ID>
        <ID>ArgumentListWrapping:LegalHoldSystemMessageHandlerTest.kt$LegalHoldSystemMessagesHandlerTest$(TestUser.OTHER_USER_ID_2)</ID>
        <ID>ArgumentListWrapping:LegalHoldSystemMessageHandlerTest.kt$LegalHoldSystemMessagesHandlerTest$(listOf(TestUser.OTHER_USER_ID_2))</ID>
        <ID>ArgumentListWrapping:LegalHoldSystemMessageHandlerTest.kt$LegalHoldSystemMessagesHandlerTest$(mapOf(TestConversation.CONVERSATION.id to TestMessage.TEXT_MESSAGE))</ID>
        <ID>ArgumentListWrapping:LegalHoldSystemMessageHandlerTest.kt$LegalHoldSystemMessagesHandlerTest$(matching { it.content is MessageContent.LegalHold.ForConversation.Disabled &amp;&amp; it.date == timestampIso })</ID>
        <ID>ArgumentListWrapping:LegalHoldSystemMessageHandlerTest.kt$LegalHoldSystemMessagesHandlerTest$(matching { it.content is MessageContent.LegalHold.ForConversation.Enabled &amp;&amp; it.date == timestampIso })</ID>
        <ID>ArgumentListWrapping:LegalHoldSystemMessagesHandler.kt$LegalHoldSystemMessagesHandlerImpl$(MessageContent.LegalHold.ForConversation.Disabled, conversationId, systemMessageTimestampIso)</ID>
        <ID>ArgumentListWrapping:LegalHoldSystemMessagesHandler.kt$LegalHoldSystemMessagesHandlerImpl$(MessageContent.LegalHold.ForConversation.Enabled, conversationId, systemMessageTimestampIso)</ID>
        <ID>ArgumentListWrapping:LegalHoldSystemMessagesHandler.kt$LegalHoldSystemMessagesHandlerImpl$(conversationId, Conversation.LegalHoldStatus.DISABLED, systemMessageTimestampIso)</ID>
        <ID>ArgumentListWrapping:LegalHoldSystemMessagesHandler.kt$LegalHoldSystemMessagesHandlerImpl$(conversationId, Conversation.LegalHoldStatus.ENABLED, systemMessageTimestampIso)</ID>
        <ID>ArgumentListWrapping:ListUserRequest.kt$(qualifiedHandles)</ID>
        <ID>ArgumentListWrapping:ListUsersRequestJson.kt$ListUsersRequestJson$( QualifiedUserIdListRequest( listOf( QualifiedID("id1", "domain1"), QualifiedID("id11", "domain1"), QualifiedID("id2", "domain2") ) ), qualifiedIdsProvider )</ID>
        <ID>ArgumentListWrapping:LocalMonkey.kt$LocalMonkey$( id, monkey.monkeyType.userId() )</ID>
        <ID>ArgumentListWrapping:LocalMonkey.kt$LocalMonkey$( name, monkeyList.map { it.monkeyType.userId() }, ConversationOptions(protocol = protocol) )</ID>
        <ID>ArgumentListWrapping:LocalMonkey.kt$LocalMonkey$( userIdentifier = email, password = password, shouldPersistClient = false, secondFactorVerificationCode = secondFactor )</ID>
        <ID>ArgumentListWrapping:LoginUseCase.kt$LoginUseCaseImpl$(authTokens, ssoId, serverConfig.id, proxyCredentials)</ID>
        <ID>ArgumentListWrapping:LoginUseCase.kt$LoginUseCaseImpl$(it, isEmail, cleanUserIdentifier)</ID>
        <ID>ArgumentListWrapping:LoginUseCaseTest.kt$LoginUseCaseTest$("cooluser", listOf('!', ':', '?'))</ID>
        <ID>ArgumentListWrapping:LoginUseCaseTest.kt$LoginUseCaseTest$('!', ':', '?')</ID>
        <ID>ArgumentListWrapping:LoginUseCaseTest.kt$LoginUseCaseTest$(TEST_EMAIL, TEST_PASSWORD, TEST_PERSIST_CLIENT, TEST_LABEL, TEST_2FA_CODE)</ID>
        <ID>ArgumentListWrapping:LoginUseCaseTest.kt$LoginUseCaseTest$(dirtyEmail, TEST_PASSWORD, TEST_PERSIST_CLIENT, TEST_LABEL, TEST_2FA_CODE)</ID>
        <ID>ArgumentListWrapping:LoginUseCaseTest.kt$LoginUseCaseTest$(dirtyHandle, TEST_PASSWORD, TEST_PERSIST_CLIENT, TEST_LABEL, TEST_2FA_CODE)</ID>
        <ID>ArgumentListWrapping:LoginWithEmailRequestJson.kt$LoginWithEmailRequestJson$( LoginApi.LoginParam.LoginWithEmail( email = "user@email.de", label = "label", password = "password", verificationCode = "verificationCode" ), jsonProvider )</ID>
        <ID>ArgumentListWrapping:LoginWithEmailRequestJson.kt$LoginWithEmailRequestJson$( LoginApi.LoginParam.LoginWithHandle( handle = "cool_user_name", label = "label", password = "password", ), jsonProvider )</ID>
        <ID>ArgumentListWrapping:LogoutApiV0Test.kt$LogoutApiV0Test$((errorResponse.kException as KaliumException.InvalidRequestError).errorResponse, ERROR_RESPONSE.serializableData)</ID>
        <ID>ArgumentListWrapping:LogoutUseCaseTest.kt$LogoutUseCaseTest.Arrangement$(classOf&lt;UserSessionScopeProvider>())</ID>
        <ID>ArgumentListWrapping:LogoutUseCaseTest.kt$LogoutUseCaseTest.Arrangement$(classOf&lt;UserSessionWorkScheduler>())</ID>
        <ID>ArgumentListWrapping:LogoutUseCaseTest.kt$LogoutUseCaseTest.Arrangement$(mock(classOf&lt;UserSessionScopeProvider>()))</ID>
        <ID>ArgumentListWrapping:LogoutUseCaseTest.kt$LogoutUseCaseTest.Arrangement$(mock(classOf&lt;UserSessionWorkScheduler>()))</ID>
        <ID>ArgumentListWrapping:MLSClientImpl.kt$MLSClientImpl$(coreCrypto.decryptMessage(toUByteList(groupId.decodeBase64Bytes()), toUByteList(message)))</ID>
        <ID>ArgumentListWrapping:MLSClientImpl.kt$MLSClientImpl$(coreCrypto.removeClientsFromConversation(toUByteList(groupId.decodeBase64Bytes()), clientIds))</ID>
        <ID>ArgumentListWrapping:MLSClientImpl.kt$MLSClientImpl$(groupId.decodeBase64Bytes())</ID>
        <ID>ArgumentListWrapping:MLSClientImpl.kt$MLSClientImpl$(keyRotationDuration.toJavaDuration(), MlsWirePolicy.PLAINTEXT)</ID>
        <ID>ArgumentListWrapping:MLSClientImpl.kt$MLSClientImpl$(message)</ID>
        <ID>ArgumentListWrapping:MLSClientImpl.kt$MLSClientImpl$(toDecryptedMessageBundle(coreCrypto.decryptMessage(toUByteList(groupId.decodeBase64Bytes()), toUByteList(message))))</ID>
        <ID>ArgumentListWrapping:MLSClientImpl.kt$MLSClientImpl$(toUByteList(groupId.decodeBase64Bytes()), clientIds)</ID>
        <ID>ArgumentListWrapping:MLSClientImpl.kt$MLSClientImpl$(toUByteList(groupId.decodeBase64Bytes()), toUByteList(message))</ID>
        <ID>ArgumentListWrapping:MLSClientImpl.kt$MLSClientImpl.Companion$((toByteArray(it).commonToUtf8String()))</ID>
        <ID>ArgumentListWrapping:MLSClientImpl.kt$MLSClientImpl.Companion$(it)</ID>
        <ID>ArgumentListWrapping:MLSConfigHandler.kt$MLSConfigHandler$(SupportedProtocol.PROTEUS)</ID>
        <ID>ArgumentListWrapping:MLSConfigHandler.kt$MLSConfigHandler$(if (mlsEnabled) mlsConfig.defaultProtocol else SupportedProtocol.PROTEUS)</ID>
        <ID>ArgumentListWrapping:MLSConfigHandler.kt$MLSConfigHandler$(setOf(SupportedProtocol.PROTEUS))</ID>
        <ID>ArgumentListWrapping:MLSConversationRepository.kt$MLSConversationDataSource$(event, EventDeliveryInfo(isTransient = true, source = EventSource.LIVE))</ID>
        <ID>ArgumentListWrapping:MLSConversationRepository.kt$MLSConversationDataSource$(isTransient = true, source = EventSource.LIVE)</ID>
        <ID>ArgumentListWrapping:MLSConversationRepository.kt$MLSConversationDataSource$(serialDispatcher)</ID>
        <ID>ArgumentListWrapping:MLSConversationRepository.kt$MLSConversationDataSource$(user.userId, user.domain)</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest$(Arrangement.GROUP_ID, TestConversation.ID)</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest$(Arrangement.GROUP_ID, listOf(TestConversation.USER_ID1))</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest$(Either.Left(StorageFailure.DataNotFound), mlsConversationRepository.getClientIdentity(TestClient.CLIENT_ID))</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest$(Either.Right(listOf(WIRE_IDENTITY)), mlsConversationRepository.getUserIdentity(TestUser.OTHER_USER_ID))</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest$(StorageFailure.DataNotFound)</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest$(TestClient.CLIENT_ID)</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest$(TestClient.CLIENT_ID, arrangement.e2eiClient, "")</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest$(TestConversation.USER_ID1)</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest$(TestKaliumDispatcher.default)</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest$(TestUser.OTHER_USER_ID)</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest$(WIRE_IDENTITY)</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest$(handle = WireIdentity.Handle.fromString(handleWithSchemeAndDomain, domain))</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest$(handleWithSchemeAndDomain, domain)</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest$(keyPackageSuccess)</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest$(keyPackages = listOf(keyPackageSuccess), usersWithoutKeyPackages = usersMissingKeyPackages)</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest$(listOf(WIRE_IDENTITY))</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest.Arrangement$(NetworkResponse.Success(value = CLIENTS_OF_USERS_RESPONSE, headers = mapOf(), httpCode = 200))</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest.Arrangement$(value = CLIENTS_OF_USERS_RESPONSE, headers = mapOf(), httpCode = 200)</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest.Arrangement.Companion$(409, "", "mls-client-mismatch")</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest.Arrangement.Companion$(409, "", "mls-stale-message")</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest.Arrangement.Companion$(ErrorResponse(409, "", "mls-client-mismatch"))</ID>
        <ID>ArgumentListWrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest.Arrangement.Companion$(ErrorResponse(409, "", "mls-stale-message"))</ID>
        <ID>ArgumentListWrapping:MLSConversationsVerificationStatusesHandler.kt$MLSConversationsVerificationStatusesHandlerImpl$( epochChangesData.conversationId.toModel(), epochChangesData.members.keys.map { it.toModel() })</ID>
        <ID>ArgumentListWrapping:MLSConversationsVerificationStatusesHandler.kt$MLSConversationsVerificationStatusesHandlerImpl$(conversationId, updatedStatus != VerificationStatus.DEGRADED)</ID>
        <ID>ArgumentListWrapping:MLSConversationsVerificationStatusesHandlerTest.kt$MLSConversationsVerificationStatusesHandlerTest$(conversation = TestConversation.MLS_CONVERSATION)</ID>
        <ID>ArgumentListWrapping:MLSKeyPackageCountUseCase.kt$MLSKeyPackageCountUseCaseImpl$( { MLSKeyPackageCountResult.Failure.Generic(it) }, { MLSKeyPackageCountResult.Success(selfClient, it, keyPackageLimitsProvider.needsRefill(it)) })</ID>
        <ID>ArgumentListWrapping:MLSKeyPackageCountUseCase.kt$MLSKeyPackageCountUseCaseImpl$( { MLSKeyPackageCountResult.Failure.NetworkCallFailure(it) }, { MLSKeyPackageCountResult.Success(selfClient, it.count, keyPackageLimitsProvider.needsRefill(it.count)) })</ID>
        <ID>ArgumentListWrapping:MLSKeyPackageCountUseCase.kt$MLSKeyPackageCountUseCaseImpl$(it.count)</ID>
        <ID>ArgumentListWrapping:MLSKeyPackageCountUseCase.kt$MLSKeyPackageCountUseCaseImpl$(selfClient, it.count, keyPackageLimitsProvider.needsRefill(it.count))</ID>
        <ID>ArgumentListWrapping:MLSMessageCreator.kt$MLSMessageCreatorImpl$(groupId)</ID>
        <ID>ArgumentListWrapping:MLSMessageCreator.kt$MLSMessageCreatorImpl$(idMapper.toCryptoModel(groupId), content.data)</ID>
        <ID>ArgumentListWrapping:MLSMessageCreator.kt$MLSMessageCreatorImpl$(mlsClient.encryptMessage(idMapper.toCryptoModel(groupId), content.data))</ID>
        <ID>ArgumentListWrapping:MLSMessageUnpacker.kt$MLSMessageUnpackerImpl$( KaliumLogLevel.DEBUG, "Received MLS proposal, scheduling delayed commit", mapOf( "groupId" to groupId.toLogString(), "commitDelay" to "$commitDelay" ) )</ID>
        <ID>ArgumentListWrapping:MLSMessageUnpackerTest.kt$MLSMessageUnpackerTest$(TestConversation.GROUP_ID)</ID>
        <ID>ArgumentListWrapping:MLSMessageUnpackerTest.kt$MLSMessageUnpackerTest$(matching { it.contentEquals(messageEvent.content.decodeBase64Bytes()) }, eq(TestConversation.GROUP_ID))</ID>
        <ID>ArgumentListWrapping:MLSMessageUnpackerTest.kt$MLSMessageUnpackerTest$(messageEvent.content.decodeBase64Bytes())</ID>
        <ID>ArgumentListWrapping:MLSMigrator.kt$MLSMigratorImpl$( conversationId, selfUserId, Protocol.MIXED )</ID>
        <ID>ArgumentListWrapping:MLSMigrator.kt$MLSMigratorImpl$( conversationId, selfUserId, Protocol.MLS )</ID>
        <ID>ArgumentListWrapping:MLSWelcomeEventHandler.kt$MLSWelcomeEventHandlerImpl$(groupID, Conversation.ProtocolInfo.MLSCapable.GroupState.ESTABLISHED)</ID>
        <ID>ArgumentListWrapping:MLSWelcomeEventHandlerTest.kt$MLSWelcomeEventHandlerTest.Arrangement$(classOf&lt;CertificateRevocationListRepository>())</ID>
        <ID>ArgumentListWrapping:MainActivity.kt$( modifier = Modifier.fillMaxWidth(), thickness = 0.5.dp )</ID>
        <ID>ArgumentListWrapping:MapperProvider.kt$MapperProvider$(idMapper(), selfUserId)</ID>
        <ID>ArgumentListWrapping:MarkGuestLinkFeatureFlagAsNotChangedUseCaseTest.kt$MarkGuestLinkFeatureFlagAsNotChangedUseCaseTest$(any(), eq(false))</ID>
        <ID>ArgumentListWrapping:MarkGuestLinkFeatureFlagAsNotChangedUseCaseTest.kt$MarkGuestLinkFeatureFlagAsNotChangedUseCaseTest$(false)</ID>
        <ID>ArgumentListWrapping:MarkGuestLinkFeatureFlagAsNotChangedUseCaseTest.kt$MarkGuestLinkFeatureFlagAsNotChangedUseCaseTest$(once)</ID>
        <ID>ArgumentListWrapping:MarkGuestLinkFeatureFlagAsNotChangedUseCaseTest.kt$MarkGuestLinkFeatureFlagAsNotChangedUseCaseTest$(userConfigRepository)</ID>
        <ID>ArgumentListWrapping:MarkGuestLinkFeatureFlagAsNotChangedUseCaseTest.kt$MarkGuestLinkFeatureFlagAsNotChangedUseCaseTest$(userConfigRepository::setGuestRoomStatus)</ID>
        <ID>ArgumentListWrapping:MarkLegalHoldChangeAsNotifiedForSelfUseCaseTest.kt$MarkLegalHoldChangeAsNotifiedForSelfUseCaseTest.Arrangement$(userConfigRepository)</ID>
        <ID>ArgumentListWrapping:MemberChangeEventHandlerTest.kt$MemberChangeEventHandlerTest.Arrangement$(conversationRepository)</ID>
        <ID>ArgumentListWrapping:MemberDAO.kt$MemberDAOImpl$(coroutineContext)</ID>
        <ID>ArgumentListWrapping:MemberDAOTest.kt$MemberDAOTest$(conversationEntity1.id)</ID>
        <ID>ArgumentListWrapping:MemberDAOTest.kt$MemberDAOTest$(dispatcher)</ID>
        <ID>ArgumentListWrapping:MemberDAOTest.kt$MemberDAOTest$(member1, member2)</ID>
        <ID>ArgumentListWrapping:MemberDAOTest.kt$MemberDAOTest$(setOf(member1, member2), memberDAO.observeConversationMembers(conversationEntity1.id).first().toSet())</ID>
        <ID>ArgumentListWrapping:MemberMapperTest.kt$MemberMapperTest.Companion$("other1", "domain1")</ID>
        <ID>ArgumentListWrapping:MemberMapperTest.kt$MemberMapperTest.Companion$(id = UserIdDTO("other1", "domain1"), conversationRole = "wire_member", service = null)</ID>
        <ID>ArgumentListWrapping:MemberUpdateDTO.kt$MemberUpdateDTO$("otr_muted_status")</ID>
        <ID>ArgumentListWrapping:MemberUpdateDTO.kt$MemberUpdateDTO$(with = MutedStatusSerializer::class)</ID>
        <ID>ArgumentListWrapping:MemberUpdateRequestJson.kt$MemberUpdateRequestJson$( null, null, null, null, "2022-04-11T14:15:48.044Z", MutedStatus.ALL_ALLOWED )</ID>
        <ID>ArgumentListWrapping:MembersToMentionUseCase.kt$MembersToMentionUseCase$(dispatcher.io)</ID>
        <ID>ArgumentListWrapping:MessageContentEncoder.kt$MessageContentEncoder$(latitudeBEBytes + longitudeBEBytes + encodeMessageTimeStampInMillis(messageTimeStampInMillis))</ID>
        <ID>ArgumentListWrapping:MessageDAOBenchmarkTest.kt$MessageDAOBenchmarkTest$("Took $it to query visible messages from a single conversation, with $totalMessageCount random messages inserted")</ID>
        <ID>ArgumentListWrapping:MessageDAOImpl.kt$MessageDAOImpl$( conversationId, visibility )</ID>
        <ID>ArgumentListWrapping:MessageDAOImpl.kt$MessageDAOImpl$( conversationId, visibility, date.toInstant(), mapper::toEntityMessageFromView )</ID>
        <ID>ArgumentListWrapping:MessageDAOImpl.kt$MessageDAOImpl$( userId, MessageEntity.Status.PENDING, mapper::toEntityMessageFromView )</ID>
        <ID>ArgumentListWrapping:MessageDAOImpl.kt$MessageDAOImpl$(coroutineContext)</ID>
        <ID>ArgumentListWrapping:MessageDAOImpl.kt$MessageDAOImpl$(queries, assetViewQueries, mapper, coroutineContext)</ID>
        <ID>ArgumentListWrapping:MessageDAOTest.kt$MessageDAOTest$( id = it.toString(), date = "2000-01-01T11:0$it:00.000Z".toInstant(), conversationId = conversationId, senderUserId = userEntity1.id, )</ID>
        <ID>ArgumentListWrapping:MessageDAOTest.kt$MessageDAOTest$( messageId, conversationId, listOf(userEntity1.id, userEntity2.id), RecipientFailureTypeEntity.MESSAGE_DELIVERY_FAILED )</ID>
        <ID>ArgumentListWrapping:MessageDAOTest.kt$MessageDAOTest$(124)</ID>
        <ID>ArgumentListWrapping:MessageDAOTest.kt$MessageDAOTest$(AssetTransferStatusEntity.DOWNLOAD_IN_PROGRESS, messageId, conversationEntity1.id)</ID>
        <ID>ArgumentListWrapping:MessageDAOTest.kt$MessageDAOTest$(AssetTransferStatusEntity.UPLOAD_IN_PROGRESS, message2Id, conversationEntity1.id)</ID>
        <ID>ArgumentListWrapping:MessageDAOTest.kt$MessageDAOTest$(conversationEntity1.id, messageToSend.id, Instant.fromEpochMilliseconds(124), 1)</ID>
        <ID>ArgumentListWrapping:MessageDAOTest.kt$MessageDAOTest$(conversationInQuestion.id)</ID>
        <ID>ArgumentListWrapping:MessageDAOTest.kt$MessageDAOTest$(conversationInQuestion.id, dateInQuestion)</ID>
        <ID>ArgumentListWrapping:MessageDAOTest.kt$MessageDAOTest$(userEntity1.id, userEntity2.id)</ID>
        <ID>ArgumentListWrapping:MessageDraftDAOImpl.kt$MessageDraftDAOImpl$(conversationIDEntity)</ID>
        <ID>ArgumentListWrapping:MessageDraftMapper.kt$( text = text, editMessageId = editMessageId, quotedMessageId = quotedMessageId, // self mentions are not supported in drafts selectedMentionList = selectedMentionList.map { it.toModel(selfUserId = null) })</ID>
        <ID>ArgumentListWrapping:MessageEnvelopeCreator.kt$MessageEnvelopeCreatorImpl$(message.id, message.content, expectsReadConfirmation, legalHoldStatus)</ID>
        <ID>ArgumentListWrapping:MessageLegalHoldTest.kt$MessageLegalHoldTest.Companion$(ORIGINAL_MESSAGE_ID, ORIGINAL_CONTENT, CONVERSATION_ID, OTHER_USER.id)</ID>
        <ID>ArgumentListWrapping:MessageLegalHoldTest.kt$MessageLegalHoldTest.Companion$(OTHER_USER.id)</ID>
        <ID>ArgumentListWrapping:MessageLegalHoldTest.kt$MessageLegalHoldTest.Companion$(listOf(OTHER_USER.id), MessageEntity.LegalHoldType.ENABLED_FOR_MEMBERS)</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$( this.mimeType, this.assetSizeInBytes, this.assetName )</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$(adminName)</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$(domainList)</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$(memberList)</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$(memberList, MessageContent.MemberChange.FailedToAdd.Type.Federation)</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$(memberList, MessageContent.MemberChange.FailedToAdd.Type.LegalHold)</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$(memberList, MessageContent.MemberChange.FailedToAdd.Type.Unknown)</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$(memberUserIdList, MessageEntity.MemberChangeType.FAILED_TO_ADD_FEDERATION)</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$(memberUserIdList, MessageEntity.MemberChangeType.FAILED_TO_ADD_LEGAL_HOLD)</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$(memberUserIdList, MessageEntity.MemberChangeType.FAILED_TO_ADD_UNKNOWN)</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$(messageTimer)</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$(protocol.toModel())</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$(this.members.map { it.toDao() }, MessageEntity.LegalHoldType.DISABLED_FOR_MEMBERS)</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$(this.members.map { it.toDao() }, MessageEntity.LegalHoldType.ENABLED_FOR_MEMBERS)</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$(userName)</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$(username = senderName, messageBody = messageBody)</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$(username = senderName, type = type.toModel())</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$MessageMapper$( senderName = senderName, messageBody = text.requireField("text") )</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$MessageMapper$("quotedMessageDateTime")</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$MessageMapper$(conversationName.orEmpty())</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$MessageMapper$(userName = senderName)</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$MessageMapperImpl$( expireAfter = it.toDuration(DurationUnit.MILLISECONDS), selfDeletionStatus = message.selfDeletionStartDate ?.let { Message.ExpirationData.SelfDeletionStatus.Started(it) } ?: Message.ExpirationData.SelfDeletionStatus.NotStarted)</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$MessageMapperImpl$(message.editStatus.lastTimeStamp.toInstant())</ID>
        <ID>ArgumentListWrapping:MessageMapper.kt$MessageMapperImpl$(message.visibility.toModel() == Message.Visibility.HIDDEN, selfUserId)</ID>
        <ID>ArgumentListWrapping:MessageMapperTest.kt$MessageMapperTest$(emptyList(), MessageEntity.LegalHoldType.DISABLED_FOR_CONVERSATION)</ID>
        <ID>ArgumentListWrapping:MessageMapperTest.kt$MessageMapperTest$(emptyList(), MessageEntity.LegalHoldType.ENABLED_FOR_CONVERSATION)</ID>
        <ID>ArgumentListWrapping:MessageMapperTest.kt$MessageMapperTest$(memberUserIdList, MessageEntity.LegalHoldType.DISABLED_FOR_MEMBERS)</ID>
        <ID>ArgumentListWrapping:MessageMapperTest.kt$MessageMapperTest$(memberUserIdList, MessageEntity.LegalHoldType.ENABLED_FOR_MEMBERS)</ID>
        <ID>ArgumentListWrapping:MessageNotificationsTest.kt$MessageNotificationsTest$(TEST_CONVERSATION_1.id, ConversationEntity.MutedStatus.ALL_MUTED, 0L)</ID>
        <ID>ArgumentListWrapping:MessageNotificationsTest.kt$MessageNotificationsTest$(conversationId, mutedStatus, Clock.System.now().toEpochMilliseconds())</ID>
        <ID>ArgumentListWrapping:MessageNotificationsTest.kt$MessageNotificationsTest.Companion$( "I'm quoting others", quotedMessageId = OTHER_MESSAGE.id )</ID>
        <ID>ArgumentListWrapping:MessageNotificationsTest.kt$MessageNotificationsTest.Companion$( "I'm quoting selfUser", quotedMessageId = SELF_MESSAGE.id )</ID>
        <ID>ArgumentListWrapping:MessageNotificationsTest.kt$MessageNotificationsTest.Companion$( messageBody = "@$@${OTHER_USER_2.name}", mentions = listOf(OTHER_MENTION) )</ID>
        <ID>ArgumentListWrapping:MessageNotificationsTest.kt$MessageNotificationsTest.Companion$( messageBody = "@${SELF_USER.name} @${OTHER_USER_2.name}", mentions = listOf(SELF_MENTION) )</ID>
        <ID>ArgumentListWrapping:MessageNotificationsTest.kt$MessageNotificationsTest.Companion$( start = 0, length = 9, userId = SELF_USER_ID )</ID>
        <ID>ArgumentListWrapping:MessageNotificationsTest.kt$MessageNotificationsTest.Companion$( start = 10, length = 11, userId = OTHER_USER_2.id )</ID>
        <ID>ArgumentListWrapping:MessageReactionsTest.kt$MessageReactionsTest$(initialMessageEntity.id, initialMessageEntity.conversationId, OTHER_USER.id, "date", "")</ID>
        <ID>ArgumentListWrapping:MessageReactionsTest.kt$MessageReactionsTest$(initialMessageEntity.id, initialMessageEntity.conversationId, OTHER_USER.id, "date", firstEmoji)</ID>
        <ID>ArgumentListWrapping:MessageReactionsTest.kt$MessageReactionsTest$(initialMessageEntity.id, initialMessageEntity.conversationId, SELF_USER_ID, "date", firstEmoji)</ID>
        <ID>ArgumentListWrapping:MessageReactionsTest.kt$MessageReactionsTest$(initialMessageEntity.id, initialMessageEntity.conversationId, SELF_USER_ID, "date", secondEmoji)</ID>
        <ID>ArgumentListWrapping:MessageReplyTest.kt$MessageReplyTest$(dispatcher)</ID>
        <ID>ArgumentListWrapping:MessageRepository.kt$MessageDataSource$(messageOption.userIDs.map { it.toApi() })</ID>
        <ID>ArgumentListWrapping:MessageRepositoryTest.kt$MessageRepositoryTest$( matching { (it.messageOption is MessageApi.QualifiedMessageOption.ReportSome) &amp;&amp; ((it.messageOption as MessageApi.QualifiedMessageOption.ReportSome) .userIDs == recipient.map { it.id }) }, anything() )</ID>
        <ID>ArgumentListWrapping:MessageRepositoryTest.kt$MessageRepositoryTest$( matching { it.recipients.isEmpty() &amp;&amp; it.messageOption == MessageApi.QualifiedMessageOption.IgnoreAll }, anything() )</ID>
        <ID>ArgumentListWrapping:MessageRepositoryTest.kt$MessageRepositoryTest$( matching { it.recipients.isEmpty() &amp;&amp; it.messageOption == MessageApi.QualifiedMessageOption.ReportAll }, anything() )</ID>
        <ID>ArgumentListWrapping:MessageRepositoryTest.kt$MessageRepositoryTest$(conversationID, messageID, newServerData, millis)</ID>
        <ID>ArgumentListWrapping:MessageScope.kt$MessageScope$( messageRepository, dispatcher )</ID>
        <ID>ArgumentListWrapping:MessageScope.kt$MessageScope$(slowSyncRepository, selfUserId, currentClientIdProvider, messageSender, dispatcher)</ID>
        <ID>ArgumentListWrapping:MessageSendFailureHandler.kt$MessageSendFailureHandlerImpl$(Unit)</ID>
        <ID>ArgumentListWrapping:MessageSendFailureHandlerTest.kt$MessageSendFailureHandlerTest$( failureData, null )</ID>
        <ID>ArgumentListWrapping:MessageSendFailureHandlerTest.kt$MessageSendFailureHandlerTest$(arrangement.userOne, arrangement.userTwo)</ID>
        <ID>ArgumentListWrapping:MessageSendFailureHandlerTest.kt$MessageSendFailureHandlerTest$(failure, arrangement.conversationId, arrangement.messageId, "text")</ID>
        <ID>ArgumentListWrapping:MessageSendFailureHandlerTest.kt$MessageSendFailureHandlerTest$(mapOf(arrangement.userOne, arrangement.userTwo), mapOf(), mapOf(), null)</ID>
        <ID>ArgumentListWrapping:MessageSender.kt$MessageSenderImpl$((messageTarget.usersToIgnore + usersWithoutSessions.users).toSet())</ID>
        <ID>ArgumentListWrapping:MessageSender.kt$MessageSenderImpl$(conversationId, messageTimestampIso, handleClientsHaveChangedFailure)</ID>
        <ID>ArgumentListWrapping:MessageSender.kt$MessageSenderImpl$(envelope, message, option, target, remainingAttempts)</ID>
        <ID>ArgumentListWrapping:MessageSender.kt$MessageSenderImpl$(it, "Broadcast", message.toLogString(), message.id, message.date, null, remainingAttempts = 1)</ID>
        <ID>ArgumentListWrapping:MessageSender.kt$MessageSenderImpl$(message.conversationId, message.id, filteredUsersFailed)</ID>
        <ID>ArgumentListWrapping:MessageSender.kt$MessageSenderImpl$(message.conversationId, message.id, messageSent.failedToConfirmClients)</ID>
        <ID>ArgumentListWrapping:MessageSender.kt$MessageSenderImpl$(message.conversationId, message.id, usersWithoutSessions)</ID>
        <ID>ArgumentListWrapping:MessageSenderTest.kt$MessageSenderTest$(Arrangement.TEST_CONVERSATION_ID, Arrangement.TEST_MESSAGE_UUID)</ID>
        <ID>ArgumentListWrapping:MessageSenderTest.kt$MessageSenderTest$(Either.Left(failure), Either.Right(MessageSent(MESSAGE_SENT_TIME)))</ID>
        <ID>ArgumentListWrapping:MessageSenderTest.kt$MessageSenderTest$(Either.Left(failure), Either.Right(TestMessage.TEST_DATE_STRING))</ID>
        <ID>ArgumentListWrapping:MessageSenderTest.kt$MessageSenderTest$(MESSAGE_SENT_TIME)</ID>
        <ID>ArgumentListWrapping:MessageSenderTest.kt$MessageSenderTest$(MessageSent(MESSAGE_SENT_TIME))</ID>
        <ID>ArgumentListWrapping:MessageSenderTest.kt$MessageSenderTest$(TestMessage.TEST_DATE_STRING)</ID>
        <ID>ArgumentListWrapping:MessageSenderTest.kt$MessageSenderTest$(failure)</ID>
        <ID>ArgumentListWrapping:MessageSenderTest.kt$MessageSenderTest.Arrangement$(StorageFailure.DataNotFound)</ID>
        <ID>ArgumentListWrapping:MessageSenderTest.kt$MessageSenderTest.Arrangement$(TestMessage.TEST_DATE_STRING)</ID>
        <ID>ArgumentListWrapping:MessageSenderTest.kt$MessageSenderTest.Arrangement$(TestMessage.TEST_MESSAGE_SENT)</ID>
        <ID>ArgumentListWrapping:MessageSenderTest.kt$MessageSenderTest.Arrangement$(TestMessage.TEXT_MESSAGE)</ID>
        <ID>ArgumentListWrapping:MessageSenderTest.kt$MessageSenderTest.Arrangement$(if (failing) Either.Left(StorageFailure.DataNotFound) else Either.Right(TestMessage.TEXT_MESSAGE))</ID>
        <ID>ArgumentListWrapping:MessageSenderTest.kt$MessageSenderTest.Arrangement$(sendMlsMessageWithResult)</ID>
        <ID>ArgumentListWrapping:MessageSendingInterceptor.kt$MessageSendingInterceptorImpl$(originalMessage.conversationId, replyMessageContent.quotedMessageReference.quotedMessageId)</ID>
        <ID>ArgumentListWrapping:MessageTextEditHandler.kt$MessageTextEditHandlerImpl$(message.conversationId, messageContent.editMessageId)</ID>
        <ID>ArgumentListWrapping:MessageTextEditTest.kt$MessageTextEditTest$(ORIGINAL_MESSAGE_ID)</ID>
        <ID>ArgumentListWrapping:MessageTextEditTest.kt$MessageTextEditTest$(OTHER_USER.id, CONVERSATION_ID, Clock.System.now(), ReceiptTypeEntity.READ, listOf(ORIGINAL_MESSAGE_ID))</ID>
        <ID>ArgumentListWrapping:MessageTextEditTest.kt$MessageTextEditTest$(OTHER_USER.id, CONVERSATION_ID, instant, ReceiptTypeEntity.READ, listOf(ORIGINAL_MESSAGE_ID))</ID>
        <ID>ArgumentListWrapping:MigrationDAOTest.kt$MigrationDAOTest$(id = "conversation_id")</ID>
        <ID>ArgumentListWrapping:MigrationDAOTest.kt$MigrationDAOTest$(type = ConversationEntity.Type.GROUP, name = "conv name")</ID>
        <ID>ArgumentListWrapping:MigrationDAOTest.kt$MigrationDAOTest$(type = ConversationEntity.Type.ONE_ON_ONE, name = "migration name")</ID>
        <ID>ArgumentListWrapping:Monkey.kt$( user.email, backendConfig.passwordForUsers, UserId(user.unqualifiedId, backendConfig.domain), team, oldCode )</ID>
        <ID>ArgumentListWrapping:Monkey.kt$(Monkey::external)</ID>
        <ID>ArgumentListWrapping:Monkey.kt$(request.name, request.monkeys.map(Monkey::external), request.protocol, request.isDestroyable)</ID>
        <ID>ArgumentListWrapping:Monkey.kt$Monkey$(this.connectedMonkeys().randomOrNull() ?: error("Monkey ${this.monkeyType.userId()} not connected to anyone"))</ID>
        <ID>ArgumentListWrapping:MonkeyApplication.kt$MonkeyApplication$( coreLogic, prefix, config.groupCount, config.userCount, config.protocol, monkeyPool )</ID>
        <ID>ArgumentListWrapping:MonkeyApplication.kt$MonkeyApplication$("-l", "--log-level", help = "log level")</ID>
        <ID>ArgumentListWrapping:MonkeyApplication.kt$MonkeyApplication$("-w", "--sequential-warmup", help = "Should the warmup happen sequentially?")</ID>
        <ID>ArgumentListWrapping:MonkeyApplication.kt$MonkeyApplication$("Creating initial key packages for clients (logging everyone in and out). This can take a while...")</ID>
        <ID>ArgumentListWrapping:MonkeyApplication.kt$MonkeyApplication$(KaliumLogLevel.INFO)</ID>
        <ID>ArgumentListWrapping:MonkeyApplication.kt$MonkeyApplication.Companion$("CC-Version")</ID>
        <ID>ArgumentListWrapping:MonkeyConversation.kt$MonkeyConversation$("g_conversationMembers", listOf(Tag.of("id", conversationId.toString())), this.participants)</ID>
        <ID>ArgumentListWrapping:MonkeyConversation.kt$MonkeyConversation$("id", conversationId.toString())</ID>
        <ID>ArgumentListWrapping:MonkeyConversation.kt$MonkeyConversation$(Tag.of("id", conversationId.toString()))</ID>
        <ID>ArgumentListWrapping:MonkeyPool.kt$MonkeyPool$( "g_loggedInUsers", listOf(Tag.of("domain", domain), Tag.of("testCase", testCase)), usersById )</ID>
        <ID>ArgumentListWrapping:MonkeyPool.kt$MonkeyPool$( "g_loggedOutUsers", listOf(Tag.of("domain", domain), Tag.of("testCase", testCase)), usersById )</ID>
        <ID>ArgumentListWrapping:MonkeyPool.kt$MonkeyPool$(Monkey::external)</ID>
        <ID>ArgumentListWrapping:MonkeyServer.kt$MonkeyServer$( "-f", envvar = "FILE_BACKEND_CONFIG" )</ID>
        <ID>ArgumentListWrapping:MonkeyServer.kt$MonkeyServer$("-l", "--log-level", help = "log level")</ID>
        <ID>ArgumentListWrapping:MonkeyServer.kt$MonkeyServer$(KaliumLogLevel.INFO)</ID>
        <ID>ArgumentListWrapping:NeedsToRegisterClientUseCaseTest.kt$NeedsToRegisterClientUseCaseTest.Arrangement$(currentClientIdProvider, sessionRepository, proteusClientProvider, selfUserId)</ID>
        <ID>ArgumentListWrapping:NetworkStateObserverImplTest.kt$NetworkStateObserverImplTest$(dispatcher.default)</ID>
        <ID>ArgumentListWrapping:NetworkStateObserverImplTest.kt$NetworkStateObserverImplTest$(networkType = NetworkType.MOBILE, setAsDefault = true, withInternetValidated = false)</ID>
        <ID>ArgumentListWrapping:NetworkStateObserverImplTest.kt$NetworkStateObserverImplTest$(networkType = NetworkType.MOBILE, setAsDefault = true, withInternetValidated = true)</ID>
        <ID>ArgumentListWrapping:NetworkStateObserverImplTest.kt$NetworkStateObserverImplTest$(networkType = NetworkType.WIFI, setAsDefault = true, withInternetValidated = true)</ID>
        <ID>ArgumentListWrapping:NetworkStateObserverImplTest.kt$NetworkStateObserverImplTest.Arrangement$(Context.CONNECTIVITY_SERVICE)</ID>
        <ID>ArgumentListWrapping:NetworkStateObserverImplTest.kt$NetworkStateObserverImplTest.Arrangement$(NetworkInfo.DetailedState.CONNECTED, networkType.type, 0, true, true)</ID>
        <ID>ArgumentListWrapping:NetworkStateObserverImplTest.kt$NetworkStateObserverImplTest.Arrangement$(context, dispatcher)</ID>
        <ID>ArgumentListWrapping:NetworkUtils.kt$(responseString)</ID>
        <ID>ArgumentListWrapping:NewConversationEventHandler.kt$NewConversationEventHandlerImpl$(event.conversation.id.toModel())</ID>
        <ID>ArgumentListWrapping:NewConversationEventHandler.kt$NewConversationEventHandlerImpl$(event.conversation.members.otherMembers.map { it.id.toModel() }.toSet())</ID>
        <ID>ArgumentListWrapping:NewConversationEventHandler.kt$NewConversationEventHandlerImpl$(event.conversationId, DateTimeUtil.currentInstant())</ID>
        <ID>ArgumentListWrapping:NewConversationEventHandlerTest.kt$NewConversationEventHandlerTest$(arrangement.newGroupConversationSystemMessagesCreator::conversationResolvedMembersAdded)</ID>
        <ID>ArgumentListWrapping:NewConversationEventHandlerTest.kt$NewConversationEventHandlerTest$(arrangement.newGroupConversationSystemMessagesCreator::conversationStartedUnverifiedWarning)</ID>
        <ID>ArgumentListWrapping:NewConversationEventHandlerTest.kt$NewConversationEventHandlerTest.Arrangement$(newGroupConversationSystemMessagesCreator::conversationReadReceiptStatus, fun1&lt;ConversationResponse>())</ID>
        <ID>ArgumentListWrapping:NewGroupConversationSystemMessagesCreatorTest.kt$NewGroupConversationSystemMessagesCreatorTest$( ConversationMemberDTO.Self( TestUser.SELF.id.toApi(), "wire_admin" ), emptyList() )</ID>
        <ID>ArgumentListWrapping:NewGroupConversationSystemMessagesCreatorTest.kt$NewGroupConversationSystemMessagesCreatorTest$( TestConversation.ID, listOf(TestUser.OTHER.id), MessageContent.MemberChange.FailedToAdd.Type.Unknown )</ID>
        <ID>ArgumentListWrapping:NewGroupConversationSystemMessagesCreatorTest.kt$NewGroupConversationSystemMessagesCreatorTest$(TestConversation.CONVERSATION.copy(type = Conversation.Type.GROUP))</ID>
        <ID>ArgumentListWrapping:NewGroupConversationSystemMessagesCreatorTest.kt$NewGroupConversationSystemMessagesCreatorTest$(TestConversation.CONVERSATION_RESPONSE.copy(type = ConversationResponse.Type.ONE_TO_ONE))</ID>
        <ID>ArgumentListWrapping:NewGroupConversationSystemMessagesCreatorTest.kt$NewGroupConversationSystemMessagesCreatorTest$(type = Conversation.Type.GROUP)</ID>
        <ID>ArgumentListWrapping:NewGroupConversationSystemMessagesCreatorTest.kt$NewGroupConversationSystemMessagesCreatorTest$(type = ConversationResponse.Type.ONE_TO_ONE)</ID>
        <ID>ArgumentListWrapping:NewMessageEventHandlerTest.kt$NewMessageEventHandlerTest$( Either.Right( applicationMessage.copy( content = applicationMessage.content.copy(expiresAfterMillis = 123L) ) ))</ID>
        <ID>ArgumentListWrapping:NotificationEventsResponseJson.kt$NotificationEventsResponseJson$( AppLockConfigDTO(true, 60), FeatureFlagStatusDTO.ENABLED )</ID>
        <ID>ArgumentListWrapping:ObfuscateUtil.kt$("qualified_id", "qualified_ids", "qualified_users", "content", "payload")</ID>
        <ID>ArgumentListWrapping:ObserveClientDetailsUseCase.kt$ObserveClientDetailsUseCaseImpl$( { GetClientDetailsResult.Failure.Generic(it) }, { client -> provideClientId.invoke().getOrNull()?.let { currentClientId -> GetClientDetailsResult.Success(client, currentClientId.value == clientId.value) } ?: GetClientDetailsResult.Success(client, false) })</ID>
        <ID>ArgumentListWrapping:ObserveConversationAssetStatusesUseCase.kt$ObserveAssetStatusesUseCaseImpl$( { mapOf() }, { assetList -> assetList.associateBy { assetStatus -> assetStatus.id } })</ID>
        <ID>ArgumentListWrapping:ObserveConversationInteractionAvailabilityUseCase.kt$ObserveConversationInteractionAvailabilityUseCase$(dispatcher.io)</ID>
        <ID>ArgumentListWrapping:ObserveConversationInteractionAvailabilityUseCase.kt$ObserveConversationInteractionAvailabilityUseCase$(failure)</ID>
        <ID>ArgumentListWrapping:ObserveConversationListDetailsUseCaseTest.kt$ObserveConversationListDetailsUseCaseTest$(conversation = successConversation)</ID>
        <ID>ArgumentListWrapping:ObserveConversationMembersUseCaseTest.kt$ObserveConversationMembersUseCaseTest$(Member(otherUser.id, Member.Role.Admin), Member(selfUser.id, Member.Role.Member))</ID>
        <ID>ArgumentListWrapping:ObserveConversationMembersUseCaseTest.kt$ObserveConversationMembersUseCaseTest$(listOf(Member(otherUser.id, Member.Role.Admin), Member(selfUser.id, Member.Role.Member)))</ID>
        <ID>ArgumentListWrapping:ObserveConversationMembersUseCaseTest.kt$ObserveConversationMembersUseCaseTest$(otherUser.id, Member.Role.Admin)</ID>
        <ID>ArgumentListWrapping:ObserveConversationMembersUseCaseTest.kt$ObserveConversationMembersUseCaseTest$(selfUser.id, Member.Role.Member)</ID>
        <ID>ArgumentListWrapping:ObserveE2EIRequiredUseCase.kt$ObserveE2EIRequiredUseCaseImpl$(certificateResult.certificate)</ID>
        <ID>ArgumentListWrapping:ObserveE2EIRequiredUseCaseTest.kt$ObserveE2EIRequiredUseCaseTest$(TestKaliumDispatcher.io)</ID>
        <ID>ArgumentListWrapping:ObserveE2EIRequiredUseCaseTest.kt$ObserveE2EIRequiredUseCaseTest.Arrangement$(userConfigRepository, featureSupport, e2eiCertificate, currentClientIdProvider, testDispatcher)</ID>
        <ID>ArgumentListWrapping:ObserveFileSharingStatusUseCase.kt$ObserveFileSharingStatusUseCaseImpl$("Storage Error : ${it.rootCause} in ObserveFileSharingStatusUseCase", it.rootCause)</ID>
        <ID>ArgumentListWrapping:ObserveGuestRoomLinkFeatureFlagUseCase.kt$ObserveGuestRoomLinkFeatureFlagUseCaseImpl$("Storage Error : ${it.rootCause} in ObserveGuestRoomLinkFeatureFlagUseCase", it.rootCause)</ID>
        <ID>ArgumentListWrapping:ObserveIfAppUpdateRequiredUseCase.kt$ObserveIfAppUpdateRequiredUseCaseImpl$(dtoCredentials)</ID>
        <ID>ArgumentListWrapping:ObserveIsAppLockEditableUseCaseTest.kt$ObserveIsAppLockEditableUseCaseTest$(AccountInfo.Valid(TestUser.SELF.id), AccountInfo.Valid(TestUser.OTHER.id))</ID>
        <ID>ArgumentListWrapping:ObserveIsAppLockEditableUseCaseTest.kt$ObserveIsAppLockEditableUseCaseTest$(TestUser.OTHER.id)</ID>
        <ID>ArgumentListWrapping:ObserveIsAppLockEditableUseCaseTest.kt$ObserveIsAppLockEditableUseCaseTest$(TestUser.SELF.id)</ID>
        <ID>ArgumentListWrapping:ObserveIsAppLockEditableUseCaseTest.kt$ObserveIsAppLockEditableUseCaseTest$(flowOf(listOf(AccountInfo.Valid(TestUser.SELF.id), AccountInfo.Valid(TestUser.OTHER.id))))</ID>
        <ID>ArgumentListWrapping:ObserveIsAppLockEditableUseCaseTest.kt$ObserveIsAppLockEditableUseCaseTest$(listOf(AccountInfo.Valid(TestUser.SELF.id), AccountInfo.Valid(TestUser.OTHER.id)))</ID>
        <ID>ArgumentListWrapping:ObserveIsAppLockEditableUseCaseTest.kt$ObserveIsAppLockEditableUseCaseTest.Arrangement$(userSessionScopeProvider::getOrCreate, KFunction2&lt;UserId, UserSessionScope.() -> UserConfigRepository>())</ID>
        <ID>ArgumentListWrapping:ObserveIsSelfUserMemberUseCaseTest.kt$ObserveIsSelfUserMemberUseCaseTest.Arrangement$(any(), any())</ID>
        <ID>ArgumentListWrapping:ObserveIsSelfUserMemberUseCaseTest.kt$ObserveIsSelfUserMemberUseCaseTest.Arrangement$(conversationRepository)</ID>
        <ID>ArgumentListWrapping:ObserveIsSelfUserMemberUseCaseTest.kt$ObserveIsSelfUserMemberUseCaseTest.Arrangement$(conversationRepository::observeIsUserMember)</ID>
        <ID>ArgumentListWrapping:ObserveLegalHoldStateForSelfUserUseCaseTest.kt$ObserveLegalHoldStateForSelfUserUseCaseTest$("fingerprint".toByteArray())</ID>
        <ID>ArgumentListWrapping:ObserveMemberDetailsByIdsUseCaseTest.kt$ObserveMemberDetailsByIdsUseCaseTest$(list.size, 1)</ID>
        <ID>ArgumentListWrapping:ObserveMessageReceiptsUseCase.kt$ObserveMessageReceiptsUseCaseImpl$("[ObserveMessageReceiptsUseCase] - Observing read receipts for " + "Conversation: ${conversationId.toLogString()}")</ID>
        <ID>ArgumentListWrapping:ObserveNewClientsUseCaseTest.kt$ObserveNewClientsUseCaseTest$( NewClientResult.InOtherAccount( listOf(TestClient.CLIENT), TestUser.OTHER_USER_ID, TestUser.SELF.name, TestUser.SELF.handle ), awaitItem() )</ID>
        <ID>ArgumentListWrapping:ObserveNewClientsUseCaseTest.kt$ObserveNewClientsUseCaseTest.Arrangement$(classOf&lt;UserClientRepositoryProvider>())</ID>
        <ID>ArgumentListWrapping:ObserveNewClientsUseCaseTest.kt$ObserveNewClientsUseCaseTest.Arrangement$(mock(classOf&lt;UserClientRepositoryProvider>()))</ID>
        <ID>ArgumentListWrapping:ObserveScreenshotCensoringConfigUseCaseTest.kt$ObserveScreenshotCensoringConfigUseCaseTest$(5L.toDuration(DurationUnit.MINUTES))</ID>
        <ID>ArgumentListWrapping:ObserveScreenshotCensoringConfigUseCaseTest.kt$ObserveScreenshotCensoringConfigUseCaseTest$(DurationUnit.MINUTES)</ID>
        <ID>ArgumentListWrapping:ObserveScreenshotCensoringConfigUseCaseTest.kt$ObserveScreenshotCensoringConfigUseCaseTest$(TeamSelfDeleteTimer.Enforced(5L.toDuration(DurationUnit.MINUTES)))</ID>
        <ID>ArgumentListWrapping:ObserveSecurityClassificationLabelUseCaseTest.kt$ObserveSecurityClassificationLabelUseCaseTest.Arrangement$( TestUser.OTHER.copy( UserId(uuid4().toString(), domain), expiresAt = expiresAt ), Conversation.Member.Role.Member )</ID>
        <ID>ArgumentListWrapping:ObserveSecurityClassificationLabelUseCaseTest.kt$ObserveSecurityClassificationLabelUseCaseTest.Arrangement$( observeConversationMembersUseCase, conversationRepository, userConfigRepository )</ID>
        <ID>ArgumentListWrapping:ObserveSelfDeletingMessagesUseCaseTest.kt$ObserveSelfDeletingMessagesUseCaseTest$(conversationId, SelfDeletionTimer.Enforced.ByGroup(conversationSettingsDuration))</ID>
        <ID>ArgumentListWrapping:ObserveSelfDeletingMessagesUseCaseTest.kt$ObserveSelfDeletingMessagesUseCaseTest$(conversationSettingsDuration)</ID>
        <ID>ArgumentListWrapping:ObserveSelfDeletionTimerSettingsForConversationUseCase.kt$ObserveSelfDeletionTimerSettingsForConversationUseCaseImpl$(conversationDetailsEither, considerSelfUserSettings)</ID>
        <ID>ArgumentListWrapping:ObserveSelfDeletionTimerSettingsForConversationUseCase.kt$ObserveSelfDeletionTimerSettingsForConversationUseCaseImpl$(it.userMessageTimer)</ID>
        <ID>ArgumentListWrapping:ObserveSyncStateUseCase.kt$ObserveSyncStateUseCaseImpl$(slowSyncRepository.slowSyncStatus, incrementalSyncRepository.incrementalSyncState)</ID>
        <ID>ArgumentListWrapping:ObserveSyncStateUseCaseTest.kt$ObserveSyncStateUseCaseTest$(TestKaliumDispatcher.default)</ID>
        <ID>ArgumentListWrapping:ObserveUserInfoUseCase.kt$ObserveOtherUserResult$("ObserveOtherUserResult.toEither: one of the fields should not be null.")</ID>
        <ID>ArgumentListWrapping:ObserveUserInfoUseCaseTest.kt$ObserveUserInfoUseCaseTest$(TestUser.OTHER.copy(userType = UserType.INTERNAL), (result as GetUserInfoResult.Success).otherUser)</ID>
        <ID>ArgumentListWrapping:ObserveUserInfoUseCaseTest.kt$ObserveUserInfoUseCaseTest$(userType = UserType.INTERNAL)</ID>
        <ID>ArgumentListWrapping:ObserveUsersTypingUseCase.kt$ObserveUsersTypingUseCaseImpl$(dispatcher.io)</ID>
        <ID>ArgumentListWrapping:OnCloseCall.kt$OnCloseCall$("[OnCloseCall] -> ConversationId: ${conversationId.obfuscateId()} | callStatus: $callStatus")</ID>
        <ID>ArgumentListWrapping:OnHttpRequestTest.kt$OnHttpRequestTest$(TestKaliumDispatcher.main)</ID>
        <ID>ArgumentListWrapping:OnIncomingCall.kt$OnIncomingCall$(ConversationType.Conference, ConversationType.ConferenceMls)</ID>
        <ID>ArgumentListWrapping:OnIncomingCall.kt$OnIncomingCall$(mappedConversationType)</ID>
        <ID>ArgumentListWrapping:OnSendOTR.kt$OnSendOTR$(handle, calling, messageSender, callingScope, selfConversationIdProvider)</ID>
        <ID>ArgumentListWrapping:OneOnOneMigrator.kt$OneOnOneMigratorImpl$(user.id, Conversation.Protocol.PROTEUS)</ID>
        <ID>ArgumentListWrapping:OneOnOneProtocolSelectorTest.kt$OneOnOneProtocolSelectorTest$(Either.Right(TestUser.OTHER.copy(supportedProtocols = setOf(SupportedProtocol.PROTEUS))))</ID>
        <ID>ArgumentListWrapping:OneOnOneProtocolSelectorTest.kt$OneOnOneProtocolSelectorTest$(SupportedProtocol.PROTEUS)</ID>
        <ID>ArgumentListWrapping:OneOnOneProtocolSelectorTest.kt$OneOnOneProtocolSelectorTest$(TestUser.OTHER.copy(supportedProtocols = setOf(SupportedProtocol.PROTEUS)))</ID>
        <ID>ArgumentListWrapping:OneOnOneProtocolSelectorTest.kt$OneOnOneProtocolSelectorTest$(supportedProtocols = setOf(SupportedProtocol.PROTEUS))</ID>
        <ID>ArgumentListWrapping:OneOnOneResolverTest.kt$OneOnOneResolverTest$(TestUser.OTHER.copy(id = TestUser.OTHER_USER_ID), TestUser.OTHER.copy(id = TestUser.OTHER_USER_ID_2))</ID>
        <ID>ArgumentListWrapping:OneOnOneResolverTest.kt$OneOnOneResolverTest$(id = TestUser.OTHER_USER_ID)</ID>
        <ID>ArgumentListWrapping:OneOnOneResolverTest.kt$OneOnOneResolverTest$(id = TestUser.OTHER_USER_ID_2)</ID>
        <ID>ArgumentListWrapping:OnlyAffectedTestTask.kt$OnlyAffectedTestTask$(childProject.tasks .filter { it.name.equals(targetTestTask, true) } .map { task -> "${childProject.name}:${task.name}" }.toList() )</ID>
        <ID>ArgumentListWrapping:OnlyAffectedTestTask.kt$OnlyAffectedTestTask$(hasToRunAllTests, affectedModules.contains(it.name) &amp;&amp; !ignoredModules.contains(it.name))</ID>
        <ID>ArgumentListWrapping:PendingProposalSchedulerTest.kt$PendingProposalSchedulerTest$(Arrangement.PROPOSAL_TIMER.groupID, Arrangement.PROPOSAL_TIMER.timestamp)</ID>
        <ID>ArgumentListWrapping:PendingProposalSchedulerTest.kt$PendingProposalSchedulerTest$(ProposalTimer(TestConversation.GROUP_ID, Arrangement.INSTANT_NEAR_FUTURE))</ID>
        <ID>ArgumentListWrapping:PendingProposalSchedulerTest.kt$PendingProposalSchedulerTest$(TestConversation.GROUP_ID, Arrangement.INSTANT_NEAR_FUTURE)</ID>
        <ID>ArgumentListWrapping:PendingProposalSchedulerTest.kt$PendingProposalSchedulerTest$(TestKaliumDispatcher.default)</ID>
        <ID>ArgumentListWrapping:PendingProposalSchedulerTest.kt$PendingProposalSchedulerTest$(listOf(ProposalTimer(TestConversation.GROUP_ID, Arrangement.INSTANT_NEAR_FUTURE)))</ID>
        <ID>ArgumentListWrapping:PersistNewSelfDeletionTimerUseCase.kt$PersistNewSelfDeletionTimerUseCaseImpl$(dispatcher.io)</ID>
        <ID>ArgumentListWrapping:PocIntegrationTest.kt$PocIntegrationTest$(NetworkState.ConnectedWithInternet)</ID>
        <ID>ArgumentListWrapping:PocIntegrationTest.kt$PocIntegrationTest$(NetworkState.ConnectedWithoutInternet)</ID>
        <ID>ArgumentListWrapping:PocIntegrationTest.kt$PocIntegrationTest.Companion$( rootPath = "$HOME_DIRECTORY/.kalium/accounts-test", kaliumConfigs = KaliumConfigs( developmentApiEnabled = true, encryptProteusStorage = true, isMLSSupportEnabled = true, wipeOnDeviceRemoval = true, kaliumMockEngine = KaliumMockEngine(mockEngine = mockEngine), mockNetworkStateObserver = TestNetworkStateObserver.DEFAULT_TEST_NETWORK_STATE_OBSERVER ), "Wire Integration Tests" )</ID>
        <ID>ArgumentListWrapping:PostgresStorage.kt$PostgresStorage$(DATABASE, pgConfig.dbName)</ID>
        <ID>ArgumentListWrapping:PostgresStorage.kt$PostgresStorage$(DRIVER, "postgresql")</ID>
        <ID>ArgumentListWrapping:PostgresStorage.kt$PostgresStorage$(Event(MonkeyId(event.monkey_index, event.team, event.client_id), Json.decodeFromString(event.event_data)))</ID>
        <ID>ArgumentListWrapping:PostgresStorage.kt$PostgresStorage$(HOST, pgConfig.host)</ID>
        <ID>ArgumentListWrapping:PostgresStorage.kt$PostgresStorage$(MonkeyId(event.monkey_index, event.team, event.client_id), Json.decodeFromString(event.event_data))</ID>
        <ID>ArgumentListWrapping:PostgresStorage.kt$PostgresStorage$(PASSWORD, pgConfig.password)</ID>
        <ID>ArgumentListWrapping:PostgresStorage.kt$PostgresStorage$(PORT, PG_PORT)</ID>
        <ID>ArgumentListWrapping:PostgresStorage.kt$PostgresStorage$(USER, pgConfig.username)</ID>
        <ID>ArgumentListWrapping:PostgresStorage.kt$PostgresStorage$(event.event_data)</ID>
        <ID>ArgumentListWrapping:PostgresStorage.kt$PostgresStorage$(event.monkey_index, event.team, event.client_id)</ID>
        <ID>ArgumentListWrapping:PostgresStorage.kt$PostgresStorage$(execution.id)</ID>
        <ID>ArgumentListWrapping:PostgresStorage.kt$PostgresStorage$(it.backend_config)</ID>
        <ID>ArgumentListWrapping:PreKeyListMapper.kt$PreKeyListMapper$(listPrekeysResponse.failedToList ?.map { it.toModel() } ?: listOf())</ID>
        <ID>ArgumentListWrapping:PreKeyListMapperTest.kt$PreKeyListMapperTest$( "domA" to mapOf( "userA" to mapOf( "clientA" to PreKeyDTO(1, "keyA") ), "userB" to mapOf( "clientB" to PreKeyDTO(32, "key") ) ), "domB" to mapOf( "userB" to mapOf( "clientB" to PreKeyDTO(22, "keyC") ) ) )</ID>
        <ID>ArgumentListWrapping:PrekeyApiV0Test.kt$PrekeyApiV0Test$(VALID_GET_USERS_PREKEY_REQUEST.serializableData)</ID>
        <ID>ArgumentListWrapping:PrekeyApiV4Test.kt$PrekeyApiV4Test$(VALID_GET_USERS_PREKEY_REQUEST.serializableData)</ID>
        <ID>ArgumentListWrapping:ProteusClientCoreCryptoImpl.kt$ProteusClientCoreCryptoImpl$(UShort.MAX_VALUE)</ID>
        <ID>ArgumentListWrapping:ProteusClientCoreCryptoImpl.kt$ProteusClientCoreCryptoImpl$(UShort.MAX_VALUE.toInt(), toByteArray(coreCrypto.proteusNewPrekey(UShort.MAX_VALUE)))</ID>
        <ID>ArgumentListWrapping:ProteusClientCoreCryptoImpl.kt$ProteusClientCoreCryptoImpl$(coreCrypto.proteusLastErrorCode().toInt())</ID>
        <ID>ArgumentListWrapping:ProteusClientCoreCryptoImpl.kt$ProteusClientCoreCryptoImpl$(coreCrypto.proteusLastResortPrekeyId().toInt(), coreCrypto.proteusLastResortPrekey())</ID>
        <ID>ArgumentListWrapping:ProteusClientCoreCryptoImpl.kt$ProteusClientCoreCryptoImpl$(coreCrypto.proteusNewPrekey(UShort.MAX_VALUE))</ID>
        <ID>ArgumentListWrapping:ProteusClientCoreCryptoImpl.kt$ProteusClientCoreCryptoImpl$(coreCrypto.proteusSessionFromMessage(sessionId.value, toUByteList(message)))</ID>
        <ID>ArgumentListWrapping:ProteusClientCoreCryptoImpl.kt$ProteusClientCoreCryptoImpl$(e.message, ProteusException.fromProteusCode(coreCrypto.proteusLastErrorCode().toInt()), e)</ID>
        <ID>ArgumentListWrapping:ProteusClientCoreCryptoImpl.kt$ProteusClientCoreCryptoImpl$(message)</ID>
        <ID>ArgumentListWrapping:ProteusClientCoreCryptoImpl.kt$ProteusClientCoreCryptoImpl$(preKeyCrypto.encodedData.decodeBase64Bytes())</ID>
        <ID>ArgumentListWrapping:ProteusClientCoreCryptoImpl.kt$ProteusClientCoreCryptoImpl$(sessionId.value, preKeyCrypto.encodedData.decodeBase64Bytes())</ID>
        <ID>ArgumentListWrapping:ProteusClientCoreCryptoImpl.kt$ProteusClientCoreCryptoImpl$(sessionId.value, toUByteList(message))</ID>
        <ID>ArgumentListWrapping:ProteusClientCoreCryptoImpl.kt$ProteusClientCoreCryptoImpl$(sessionId.value, toUByteList(preKeyCrypto.encodedData.decodeBase64Bytes()))</ID>
        <ID>ArgumentListWrapping:ProteusClientCoreCryptoImpl.kt$ProteusClientCoreCryptoImpl.Companion$(coreCrypto.proteusLastErrorCode().toInt())</ID>
        <ID>ArgumentListWrapping:ProteusClientCoreCryptoImpl.kt$ProteusClientCoreCryptoImpl.Companion$(e.message, ProteusException.fromProteusCode(coreCrypto.proteusLastErrorCode().toInt()), e.cause)</ID>
        <ID>ArgumentListWrapping:ProteusClientCryptoBoxImpl.kt$ProteusClientCryptoBoxImpl$(defaultContext)</ID>
        <ID>ArgumentListWrapping:ProteusClientCryptoBoxImpl.kt$ProteusClientCryptoBoxImpl$(sessionId.value, payload = message.toUint8Array(), preKeyBundle = preKeyBundle.toArrayBuffer())</ID>
        <ID>ArgumentListWrapping:ProteusClientTest.kt$ProteusClientTest$(aliceSessionId, missingAliceSessionId)</ID>
        <ID>ArgumentListWrapping:ProteusClientTest.kt$ProteusClientTest$(message1.encodeToByteArray(), listOf(aliceSessionId, missingAliceSessionId))</ID>
        <ID>ArgumentListWrapping:ProteusMessageUnpacker.kt$ProteusMessageUnpackerImpl$("! External message can't contain another external message inside!")</ID>
        <ID>ArgumentListWrapping:ProteusMessageUnpackerTest.kt$ProteusMessageUnpackerTest$(PlainData(protobufExternalContent.encodeToByteArray()), aesKey)</ID>
        <ID>ArgumentListWrapping:ProteusMessageUnpackerTest.kt$ProteusMessageUnpackerTest$(protobufExternalContent.encodeToByteArray())</ID>
        <ID>ArgumentListWrapping:ProtoContentMapper.kt$ProtoContentMapperImpl$( editMessageId = replacingMessageId, newContent = editContent.value.content, newMentions = mentions )</ID>
        <ID>ArgumentListWrapping:ProtoContentMapper.kt$ProtoContentMapperImpl$( quotedMessageId = it.quotedMessageId, quotedMessageSha256 = it.quotedMessageSha256?.array, isVerified = false )</ID>
        <ID>ArgumentListWrapping:ProtoContentMapper.kt$ProtoContentMapperImpl$( type = when (receiptContent.type) { ReceiptType.DELIVERED -> Confirmation.Type.DELIVERED ReceiptType.READ -> Confirmation.Type.READ }, firstMessageId = firstMessage, moreMessageIds = restOfMessageIds )</ID>
        <ID>ArgumentListWrapping:ProtoContentMapper.kt$ProtoContentMapperImpl$("External content when parsing protobuf. Message UUID = ${genericMessage.messageId.obfuscateId()}")</ID>
        <ID>ArgumentListWrapping:ProtoContentMapper.kt$ProtoContentMapperImpl$("Null content when parsing protobuf. Message UUID = ${genericMessage.messageId.obfuscateId()}")</ID>
        <ID>ArgumentListWrapping:ProtoContentMapper.kt$ProtoContentMapperImpl$(ByteArr(protoContent.otrKey), protoContent.sha256?.let { ByteArr(it) }, protoContent.encryptionAlgorithm?.let { encryptionAlgorithmMapper.toProtoBufModel(it) })</ID>
        <ID>ArgumentListWrapping:ProtoContentMapper.kt$ProtoContentMapperImpl$(Ephemeral(expireAfterMillis = expireAfterMillis, content = ephemeralContent))</ID>
        <ID>ArgumentListWrapping:ProtoContentMapper.kt$ProtoContentMapperImpl$(MessageDelete(messageId = readableContent.messageId))</ID>
        <ID>ArgumentListWrapping:ProtoContentMapper.kt$ProtoContentMapperImpl$(expireAfterMillis = expireAfterMillis, content = ephemeralContent)</ID>
        <ID>ArgumentListWrapping:ProtoContentMapper.kt$ProtoContentMapperImpl$(genericMessage.messageId, external.otrKey.array, external.sha256?.array, algorithm)</ID>
        <ID>ArgumentListWrapping:ProtoContentMapper.kt$ProtoContentMapperImpl$(messageId = readableContent.messageId)</ID>
        <ID>ArgumentListWrapping:ProtoContentMapper.kt$ProtoContentMapperImpl$(protoContent.value.qualifiedConversationId, hiddenMessage.conversationId)</ID>
        <ID>ArgumentListWrapping:ProtoContentMapper.kt$ProtoContentMapperImpl$(protoContent.value.qualifiedConversationId, protoContent.value.conversationId)</ID>
        <ID>ArgumentListWrapping:ProtoContentMapperTest.kt$ProtoContentMapperTest$( TEST_MESSAGE_UUID, GenericMessage.Content.Asset( Asset( original = Asset.Original( mimeType = "file/binary", size = mockedAsset.size.toLong(), name = assetName, ), status = Asset.Status.NotUploaded(Asset.NotUploaded.CANCELLED), ) ) )</ID>
        <ID>ArgumentListWrapping:ProtoContentMapperTest.kt$ProtoContentMapperTest$( TEST_MESSAGE_UUID, TEST_CONVERSATION_ID )</ID>
        <ID>ArgumentListWrapping:ProtoContentMapperTest.kt$ProtoContentMapperTest$( quotedMessageId = "quotedMessageId", quotedMessageSha256 = null, true )</ID>
        <ID>ArgumentListWrapping:ProtoContentMapperTest.kt$ProtoContentMapperTest$(MessageEdit(replacedMessageId, textContent))</ID>
        <ID>ArgumentListWrapping:ProtoContentMapperTest.kt$ProtoContentMapperTest$(TEST_MESSAGE_UUID, GenericMessage.Content.Edited(MessageEdit(replacedMessageId, textContent)))</ID>
        <ID>ArgumentListWrapping:ProtoContentMapperTest.kt$ProtoContentMapperTest$(messageUid, otrKey.data, sha256, encryptionAlgorithm)</ID>
        <ID>ArgumentListWrapping:ProtoContentMapperTest.kt$ProtoContentMapperTest$(replacedMessageId, textContent)</ID>
        <ID>ArgumentListWrapping:QualifiedIdMapper.kt$QualifiedIdMapperImpl$(VALUE_DOMAIN_SEPARATOR)</ID>
        <ID>ArgumentListWrapping:QualifiedIdMapper.kt$QualifiedIdMapperImpl$(VALUE_DOMAIN_SEPARATOR.toString())</ID>
        <ID>ArgumentListWrapping:QualifiedIdMapperTest.kt$QualifiedIdMapperTest$(selfUserId)</ID>
        <ID>ArgumentListWrapping:QualifiedSendMessageRequestJson.kt$QualifiedSendMessageRequestJson$( MessageApi.Parameters.QualifiedDefaultParameters( sender = USER_1_CLIENT_1, externalBlob = "blob-id".toByteArray(), nativePush = true, recipients = mapOf(), transient = false, priority = MessagePriority.HIGH, messageOption = MessageApi.QualifiedMessageOption.IgnoreAll ), defaultParametersProvider )</ID>
        <ID>ArgumentListWrapping:ReactionDAO.kt$ReactionDAOImpl$( originalMessageId, conversationId, senderUserId, emoji, date )</ID>
        <ID>ArgumentListWrapping:ReactionDAO.kt$ReactionDAOImpl$(originalMessageId, conversationId, senderUserId)</ID>
        <ID>ArgumentListWrapping:ReactionDAOTest.kt$ReactionDAOTest$(TEST_MESSAGE.id, TEST_MESSAGE.conversationId, SELF_USER_ID, "Date", expectedReactions)</ID>
        <ID>ArgumentListWrapping:ReceiptDAOTest.kt$ReceiptDAOTest$( OTHER_USER.id, TEST_CONVERSATION.id, DateTimeUtil.currentInstant(), ReceiptTypeEntity.DELIVERY, listOf("SomeUnknownMessage") )</ID>
        <ID>ArgumentListWrapping:ReceiptDAOTest.kt$ReceiptDAOTest$( OTHER_USER.id, TEST_CONVERSATION.id, DateTimeUtil.currentInstant(), ReceiptTypeEntity.DELIVERY, listOf(TEST_MESSAGE.id) )</ID>
        <ID>ArgumentListWrapping:ReceiptDAOTest.kt$ReceiptDAOTest$( OTHER_USER.id, TEST_CONVERSATION.id, DateTimeUtil.currentInstant(), ReceiptTypeEntity.DELIVERY, listOf(otherMessageId) )</ID>
        <ID>ArgumentListWrapping:ReceiptDAOTest.kt$ReceiptDAOTest$( OTHER_USER.id, TEST_CONVERSATION.id, insertedInstant, ReceiptTypeEntity.DELIVERY, listOf(TEST_MESSAGE.id) )</ID>
        <ID>ArgumentListWrapping:ReceiptDAOTest.kt$ReceiptDAOTest$( SELF_USER_ID, TEST_CONVERSATION.id, DateTimeUtil.currentInstant(), ReceiptTypeEntity.DELIVERY, listOf(TEST_MESSAGE.id) )</ID>
        <ID>ArgumentListWrapping:ReceiptDAOTest.kt$ReceiptDAOTest$( SELF_USER_ID, TEST_CONVERSATION.id, DateTimeUtil.currentInstant(), ReceiptTypeEntity.READ, listOf(TEST_MESSAGE.id) )</ID>
        <ID>ArgumentListWrapping:ReceiptDAOTest.kt$ReceiptDAOTest$("SomeUnknownMessage")</ID>
        <ID>ArgumentListWrapping:ReceiptDAOTest.kt$ReceiptDAOTest$(TEST_MESSAGE.id)</ID>
        <ID>ArgumentListWrapping:ReceiptDAOTest.kt$ReceiptDAOTest$(otherMessageId)</ID>
        <ID>ArgumentListWrapping:RegisterAccountRepositoryTest.kt$RegisterAccountRepositoryTest$(RegisterApi.ActivationParam.Email(email, code))</ID>
        <ID>ArgumentListWrapping:RegisterAccountRepositoryTest.kt$RegisterAccountRepositoryTest$(email, code)</ID>
        <ID>ArgumentListWrapping:RegisterAccountRepositoryTest.kt$RegisterAccountRepositoryTest$(exactly = once)</ID>
        <ID>ArgumentListWrapping:RegisterAccountRepositoryTest.kt$RegisterAccountRepositoryTest$(registerApi)</ID>
        <ID>ArgumentListWrapping:RegisterAccountUseCaseTest.kt$RegisterAccountUseCaseTest$( param.email, param.emailActivationCode, param.name, param.password, param.teamName, param.teamIcon, param.cookieLabel )</ID>
        <ID>ArgumentListWrapping:RegisterAccountUseCaseTest.kt$RegisterAccountUseCaseTest$(expected.kaliumException, (actual.failure as NetworkFailure.ServerMiscommunication).kaliumException)</ID>
        <ID>ArgumentListWrapping:RegisterAccountUseCaseTest.kt$RegisterAccountUseCaseTest$(param.email, param.emailActivationCode, param.name, param.password, param.cookieLabel)</ID>
        <ID>ArgumentListWrapping:RegisterApi.kt$RegisterApi.ActivationParam.Email$(code = code, dryRun = dryRun, email = email, null, null, null)</ID>
        <ID>ArgumentListWrapping:RegisterClientUseCaseTest.kt$RegisterClientUseCaseTest.Companion$("no internet")</ID>
        <ID>ArgumentListWrapping:RegisterClientUseCaseTest.kt$RegisterClientUseCaseTest.Companion$(IOException("no internet"))</ID>
        <ID>ArgumentListWrapping:RegisterClientUseCaseTest.kt$RegisterClientUseCaseTest.Companion$(KaliumException.GenericError(IOException("no internet")))</ID>
        <ID>ArgumentListWrapping:RegisterMLSClientUseCaseTest.kt$RegisterMLSClientUseCaseTest.Arrangement.Companion$( true, RANDOM_URL, DateTimeUtil.currentInstant() )</ID>
        <ID>ArgumentListWrapping:RegisterTokenJson.kt$RegisterTokenJson$( PushTokenBody( "8218398", "123456", "oaisjdoiasjd", "GCM" ), jsonProvider )</ID>
        <ID>ArgumentListWrapping:RemoteMonkey.kt$RemoteMonkey$( CREATE_CONVERSATION, CreateConversationRequest(name, monkeyList.map { it.monkeyType.userId() }, protocol, isDestroyable) )</ID>
        <ID>ArgumentListWrapping:RemoteMonkey.kt$RemoteMonkey$(ADD_MONKEY_TO_CONVERSATION, AddMonkeysRequest(conversationId, monkeys.map { it.monkeyType.userId() }))</ID>
        <ID>ArgumentListWrapping:RemoteMonkey.kt$RemoteMonkey$(conversationId, monkeys.map { it.monkeyType.userId() })</ID>
        <ID>ArgumentListWrapping:RemoteMonkey.kt$RemoteMonkey$(monkeyConfig.wait)</ID>
        <ID>ArgumentListWrapping:RemoteMonkey.kt$RemoteMonkey$(monkeyType, internalId)</ID>
        <ID>ArgumentListWrapping:RemoteMonkey.kt$RemoteMonkey$(monkeyType.userData(), internalId)</ID>
        <ID>ArgumentListWrapping:RemoteMonkey.kt$RemoteMonkey$(name, monkeyList.map { it.monkeyType.userId() }, protocol, isDestroyable)</ID>
        <ID>ArgumentListWrapping:RemoveMemberFromGroupCommand.kt$RemoveMemberFromGroupCommand$(selectedConversation.id, selectedMember.id)</ID>
        <ID>ArgumentListWrapping:ReplayApplication.kt$ReplayApplication$( "-f", help = "Stop the application if an action fails, otherwise ignore and continue processing next events" )</ID>
        <ID>ArgumentListWrapping:ReplayApplication.kt$ReplayApplication$( mustExist = true, mustBeReadable = true, canBeDir = false )</ID>
        <ID>ArgumentListWrapping:ReplayApplication.kt$ReplayApplication$("-l", "--log-level", help = "log level")</ID>
        <ID>ArgumentListWrapping:ReplayApplication.kt$ReplayApplication$("-s", help = "read from file or postgres")</ID>
        <ID>ArgumentListWrapping:ReplayApplication.kt$ReplayApplication$(EventLogType.FILE)</ID>
        <ID>ArgumentListWrapping:ReplayApplication.kt$ReplayApplication$(FileStorageConfig(eventsLocation!!.absolutePath, teamsLocation!!.absolutePath))</ID>
        <ID>ArgumentListWrapping:ReplayApplication.kt$ReplayApplication$(KaliumLogLevel.INFO)</ID>
        <ID>ArgumentListWrapping:ReplayApplication.kt$ReplayApplication$(PostgresStorageConfig(host, dbName, username, password), executionId)</ID>
        <ID>ArgumentListWrapping:ReplayApplication.kt$ReplayApplication$(eventsLocation != null &amp;&amp; teamsLocation != null)</ID>
        <ID>ArgumentListWrapping:ReplayApplication.kt$ReplayApplication$(eventsLocation!!.absolutePath, teamsLocation!!.absolutePath)</ID>
        <ID>ArgumentListWrapping:ReplayApplication.kt$ReplayApplication$(host, dbName, username, password)</ID>
        <ID>ArgumentListWrapping:RequestActivationCodeJson.kt$RequestActivationCodeJson$( RegisterApi.RequestActivationCodeParam.Email(email = "user@domain.de"), jsonProvider )</ID>
        <ID>ArgumentListWrapping:RequestResponseEventAction.kt$RequestResponseEventAction$({})</ID>
        <ID>ArgumentListWrapping:ResetSessionUseCaseTest.kt$ResetSessionUseCaseTest$(testDispatchers.io)</ID>
        <ID>ArgumentListWrapping:RestoreBackupResult.kt$RestoreBackupResult.BackupRestoreFailure.InvalidUserId$("User id in the backup file does not match the current user id")</ID>
        <ID>ArgumentListWrapping:RestoreBackupUseCase.kt$RestoreBackupUseCaseImpl$("The provided backup version is lower than the minimum supported version")</ID>
        <ID>ArgumentListWrapping:RestoreBackupUseCase.kt$RestoreBackupUseCaseImpl$(acceptedFileNames())</ID>
        <ID>ArgumentListWrapping:RestoreBackupUseCase.kt$RestoreBackupUseCaseImpl$(inputSource, extractedBackupRootPath, ExtractFilesParam.Only(acceptedFileNames()), kaliumFileSystem)</ID>
        <ID>ArgumentListWrapping:RestoreBackupUseCaseTest.kt$RestoreBackupUseCaseTest.Arrangement$(listOf(source(metadataPath) to metadataPath.name, source(dbPath) to dbPath.name), outputSink)</ID>
        <ID>ArgumentListWrapping:RestoreBackupUseCaseTest.kt$RestoreBackupUseCaseTest.Arrangement$(source(metadataPath) to metadataPath.name, source(dbPath) to dbPath.name)</ID>
        <ID>ArgumentListWrapping:RestoreWebBackupUseCase.kt$RestoreWebBackupUseCaseImpl$(conversationMapper::fromMigrationModel)</ID>
        <ID>ArgumentListWrapping:RestoreWebBackupUseCase.kt$RestoreWebBackupUseCaseImpl$(filePath)</ID>
        <ID>ArgumentListWrapping:RestoreWebBackupUseCase.kt$RestoreWebBackupUseCaseImpl$(migratedConversations.map(conversationMapper::fromMigrationModel))</ID>
        <ID>ArgumentListWrapping:RetryFailedMessageUseCase.kt$RetryFailedMessageUseCase$(AssetTransferStatus.FAILED_UPLOAD, message.conversationId, message.id)</ID>
        <ID>ArgumentListWrapping:RetryFailedMessageUseCase.kt$RetryFailedMessageUseCase$(AssetTransferStatus.UPLOAD_IN_PROGRESS, message.conversationId, message.id)</ID>
        <ID>ArgumentListWrapping:RetryFailedMessageUseCase.kt$RetryFailedMessageUseCase$(content = MessageContent.Asset(value = uploadedAssetContent))</ID>
        <ID>ArgumentListWrapping:RetryFailedMessageUseCase.kt$RetryFailedMessageUseCase$(it, message.conversationId, message.id, type)</ID>
        <ID>ArgumentListWrapping:RetryFailedMessageUseCase.kt$RetryFailedMessageUseCase$(value = uploadedAssetContent)</ID>
        <ID>ArgumentListWrapping:RetryFailedMessageUseCaseTest.kt$RetryFailedMessageUseCaseTest$( matching { it is Message.Signaling // message edits are sent as signaling messages &amp;&amp; it.id != message.id // when editing we need to generate and set a new id &amp;&amp; it.content is MessageContent.TextEdited &amp;&amp; (it.content as MessageContent.TextEdited).editMessageId == message.id // original id in edited content }, anything() )</ID>
        <ID>ArgumentListWrapping:RetryFailedMessageUseCaseTest.kt$RetryFailedMessageUseCaseTest$(Either.Left(NetworkFailure.ServerMiscommunication(TestNetworkException.missingAuth)))</ID>
        <ID>ArgumentListWrapping:RetryFailedMessageUseCaseTest.kt$RetryFailedMessageUseCaseTest$(NetworkFailure.ServerMiscommunication(TestNetworkException.missingAuth))</ID>
        <ID>ArgumentListWrapping:RetryFailedMessageUseCaseTest.kt$RetryFailedMessageUseCaseTest$(TEST_DATE_STRING)</ID>
        <ID>ArgumentListWrapping:RetryFailedMessageUseCaseTest.kt$RetryFailedMessageUseCaseTest$(TestNetworkException.missingAuth)</ID>
        <ID>ArgumentListWrapping:RetryFailedMessageUseCaseTest.kt$RetryFailedMessageUseCaseTest$(status = Message.Status.Failed, editStatus = Message.EditStatus.Edited(TEST_DATE_STRING))</ID>
        <ID>ArgumentListWrapping:SSOInitiateLoginUseCase.kt$SSOInitiateLoginUseCaseImpl$( validUuid, redirects.success, redirects.error )</ID>
        <ID>ArgumentListWrapping:SSOInitiateLoginUseCaseTest.kt$SSOInitiateLoginUseCaseTest$(TEST_UUID, expectedRedirects.success, expectedRedirects.error)</ID>
        <ID>ArgumentListWrapping:SSOInitiateLoginUseCaseTest.kt$SSOInitiateLoginUseCaseTest$(ssoLoginRepository)</ID>
        <ID>ArgumentListWrapping:SSOLoginRepositoryTest.kt$SSOLoginRepositoryTest$( DomainLookupResult( networkResponse.configJsonUrl, networkResponse.webappWelcomeUrl ), actual.value )</ID>
        <ID>ArgumentListWrapping:SSOLoginScope.kt$SSOLoginScope$(ssoLoginRepository, proxyCredentials)</ID>
        <ID>ArgumentListWrapping:SaveMessageDraftUseCase.kt$SaveMessageDraftUseCaseImpl$(dispatcher.io)</ID>
        <ID>ArgumentListWrapping:ScheduleNewAssetMessageUseCase.kt$ScheduleNewAssetMessageUseCaseImpl$(generatedAssetUuid, tempAssetDomain, assetDataPath, assetDataSize, assetName.fileExtension())</ID>
        <ID>ArgumentListWrapping:ScheduleNewAssetMessageUseCase.kt$ScheduleNewAssetMessageUseCaseImpl$(it, conversationId, message.id, TYPE)</ID>
        <ID>ArgumentListWrapping:ScheduleNewAssetMessageUseCaseTest.kt$ScheduleNewAssetMessageUseCaseTest$( matching { it == AssetTransferStatus.FAILED_UPLOAD }, any(), any() )</ID>
        <ID>ArgumentListWrapping:ScheduleNewAssetMessageUseCaseTest.kt$ScheduleNewAssetMessageUseCaseTest$( matching { it == AssetTransferStatus.UPLOADED }, any(), any() )</ID>
        <ID>ArgumentListWrapping:ScheduleNewAssetMessageUseCaseTest.kt$ScheduleNewAssetMessageUseCaseTest$(testDispatcher.default)</ID>
        <ID>ArgumentListWrapping:ScheduleNewAssetMessageUseCaseTest.kt$ScheduleNewAssetMessageUseCaseTest.Arrangement$(classOf&lt;ObserveSelfDeletionTimerSettingsForConversationUseCase>())</ID>
        <ID>ArgumentListWrapping:SearchDAOTest.kt$SearchDAOTest$( MemberEntity( connectedPartOfConversation1.id, MemberEntity.Role.Member ), conversationToExclude.id )</ID>
        <ID>ArgumentListWrapping:SearchDAOTest.kt$SearchDAOTest$( MemberEntity( connectedPartOfConversation2.id, MemberEntity.Role.Member ), conversationToExclude.id )</ID>
        <ID>ArgumentListWrapping:SearchDAOTest.kt$SearchDAOTest$( MemberEntity( connectedUser1.id, MemberEntity.Role.Member ), conversation.id )</ID>
        <ID>ArgumentListWrapping:SearchDAOTest.kt$SearchDAOTest$(connectionStatus = ConnectionEntity.State.ACCEPTED)</ID>
        <ID>ArgumentListWrapping:SearchDAOTest.kt$SearchDAOTest$(connectionStatus = ConnectionEntity.State.ACCEPTED, deleted = true)</ID>
        <ID>ArgumentListWrapping:SearchDAOTest.kt$SearchDAOTest$(connectionStatus = ConnectionEntity.State.MISSING_LEGALHOLD_CONSENT)</ID>
        <ID>ArgumentListWrapping:SearchDAOTest.kt$SearchDAOTest$(connectionStatus = ConnectionEntity.State.NOT_CONNECTED)</ID>
        <ID>ArgumentListWrapping:SearchDAOTest.kt$SearchDAOTest$(handle = "qwerty", connectionStatus = ConnectionEntity.State.ACCEPTED)</ID>
        <ID>ArgumentListWrapping:SearchDAOTest.kt$SearchDAOTest$(handle = "searchQuery", connectionStatus = ConnectionEntity.State.ACCEPTED)</ID>
        <ID>ArgumentListWrapping:SearchDAOTest.kt$SearchDAOTest$(handle = searchQuery, connectionStatus = ConnectionEntity.State.ACCEPTED)</ID>
        <ID>ArgumentListWrapping:SearchDAOTest.kt$SearchDAOTest$(id = "1")</ID>
        <ID>ArgumentListWrapping:SearchDAOTest.kt$SearchDAOTest$(id = "2")</ID>
        <ID>ArgumentListWrapping:SearchDAOTest.kt$SearchDAOTest$(id = "connectedUser1")</ID>
        <ID>ArgumentListWrapping:SearchDAOTest.kt$SearchDAOTest$(id = "connectedUser2")</ID>
        <ID>ArgumentListWrapping:SearchDAOTest.kt$SearchDAOTest$(id = "deletedUser")</ID>
        <ID>ArgumentListWrapping:SearchDAOTest.kt$SearchDAOTest$(id = "missingLeaseholdConsentUser")</ID>
        <ID>ArgumentListWrapping:SearchDAOTest.kt$SearchDAOTest$(id = "notConnectedUser")</ID>
        <ID>ArgumentListWrapping:SearchDAOTest.kt$SearchDAOTest$(name = "qwerty", connectionStatus = ConnectionEntity.State.ACCEPTED)</ID>
        <ID>ArgumentListWrapping:SearchDAOTest.kt$SearchDAOTest$(name = "searchQuery", connectionStatus = ConnectionEntity.State.ACCEPTED)</ID>
        <ID>ArgumentListWrapping:SearchDAOTest.kt$SearchDAOTest$(name = searchQuery, connectionStatus = ConnectionEntity.State.ACCEPTED)</ID>
        <ID>ArgumentListWrapping:SearchUserRepositoryTest.kt$SearchUserRepositoryTest$(NetworkResponse.Success(USER_RESPONSE.copy(usersFound = emptyList()), mapOf(), 200))</ID>
        <ID>ArgumentListWrapping:SearchUserRepositoryTest.kt$SearchUserRepositoryTest$(TEST_QUERY, TEST_DOMAIN, null, SearchUsersOptions.Default)</ID>
        <ID>ArgumentListWrapping:SearchUserRepositoryTest.kt$SearchUserRepositoryTest$(TEST_QUERY, selfUser.id.domain, null, SearchUsersOptions.Default)</ID>
        <ID>ArgumentListWrapping:SearchUserRepositoryTest.kt$SearchUserRepositoryTest$(USER_RESPONSE.copy(usersFound = emptyList()), mapOf(), 200)</ID>
        <ID>ArgumentListWrapping:SearchUserRepositoryTest.kt$SearchUserRepositoryTest$(usersFound = emptyList())</ID>
        <ID>ArgumentListWrapping:SearchUsersUseCase.kt$SearchUsersUseCase$(emptyList())</ID>
        <ID>ArgumentListWrapping:SearchUsersUseCase.kt$SearchUsersUseCase$(excludingMembersOfConversation)</ID>
        <ID>ArgumentListWrapping:SelfConversationIdProviderTest.kt$SelfConversationIdProviderTest$(Arrangement.PROTEUS_SELF_CONVERSATION_ID, Arrangement.MLS_SELF_CONVERSATION_ID)</ID>
        <ID>ArgumentListWrapping:SelfConversationIdProviderTest.kt$SelfConversationIdProviderTest$(listOf(Arrangement.PROTEUS_SELF_CONVERSATION_ID, Arrangement.MLS_SELF_CONVERSATION_ID), it.value)</ID>
        <ID>ArgumentListWrapping:SendBrokenAssetMessageUseCaseImpl.kt$SendBrokenAssetMessageUseCaseImpl$(AssetTransferStatus.UPLOADED, message.conversationId, message.id)</ID>
        <ID>ArgumentListWrapping:SendBrokenAssetMessageUseCaseImpl.kt$SendBrokenAssetMessageUseCaseImpl$(AssetTransferStatus.UPLOAD_IN_PROGRESS, conversationId, generatedMessageUuid)</ID>
        <ID>ArgumentListWrapping:SendButtonMessageCaseTest.kt$SendButtonMessageCaseTest.Arrangement$(classOf&lt;MessageSendFailureHandler>())</ID>
        <ID>ArgumentListWrapping:SendButtonMessageCaseTest.kt$SendButtonMessageCaseTest.Arrangement$(mock(classOf&lt;MessageSendFailureHandler>()))</ID>
        <ID>ArgumentListWrapping:SendButtonMessageUseCase.kt$SendButtonMessageUseCase$(it, it, false)</ID>
        <ID>ArgumentListWrapping:SendDirectMessageEventAction.kt$SendDirectMessageEventAction$( UserCount.single(), 1u, 1u )</ID>
        <ID>ArgumentListWrapping:SendEditTextMessageUseCase.kt$SendEditTextMessageUseCase$(it, conversationId, originalMessageId, TYPE)</ID>
        <ID>ArgumentListWrapping:SendEditTextMessageUseCaseTest.kt$SendEditTextMessageUseCaseTest$(TestConversation.ID, originalMessageId, editedMessageText, listOf(), editedMessageId)</ID>
        <ID>ArgumentListWrapping:SendEditTextMessageUseCaseTest.kt$SendEditTextMessageUseCaseTest.Arrangement$(classOf&lt;MessageSendFailureHandler>())</ID>
        <ID>ArgumentListWrapping:SendEditTextMessageUseCaseTest.kt$SendEditTextMessageUseCaseTest.Arrangement$(mock(classOf&lt;MessageSendFailureHandler>()))</ID>
        <ID>ArgumentListWrapping:SendKnockUseCase.kt$SendKnockUseCase$(dispatcher.io)</ID>
        <ID>ArgumentListWrapping:SendKnockUseCase.kt$SendKnockUseCase$(it, conversationId, generatedMessageUuid, TYPE)</ID>
        <ID>ArgumentListWrapping:SendKnockUserCaseTest.kt$SendKnockUserCaseTest.Arrangement$(classOf&lt;MessageSendFailureHandler>())</ID>
        <ID>ArgumentListWrapping:SendKnockUserCaseTest.kt$SendKnockUserCaseTest.Arrangement$(mock(classOf&lt;MessageSendFailureHandler>()))</ID>
        <ID>ArgumentListWrapping:SendLocationUseCase.kt$SendLocationUseCase$(it, conversationId, generatedMessageUuid, TYPE)</ID>
        <ID>ArgumentListWrapping:SendLocationUseCaseTest.kt$SendLocationUseCaseTest.Arrangement$(classOf&lt;MessageSendFailureHandler>())</ID>
        <ID>ArgumentListWrapping:SendLocationUseCaseTest.kt$SendLocationUseCaseTest.Arrangement$(mock(classOf&lt;MessageSendFailureHandler>()))</ID>
        <ID>ArgumentListWrapping:SendMessageAction.kt$SendMessageAction$(Event(monkeySender.internalId, EventType.SendDirectMessage(monkeyReceiver.internalId)))</ID>
        <ID>ArgumentListWrapping:SendMessageAction.kt$SendMessageAction$(conversationPool.getFromPrefixed(target).map { it to it.randomMonkeys(this.config.userCount) })</ID>
        <ID>ArgumentListWrapping:SendMessageAction.kt$SendMessageAction$(conversationPool.randomConversations(this.config.countGroups) .map { it to it.randomMonkeys(this.config.userCount) })</ID>
        <ID>ArgumentListWrapping:SendMessageAction.kt$SendMessageAction$(monkeyPool.randomLoggedInMonkeys(this.config.userCount).map { it to it.randomPeer(monkeyPool) })</ID>
        <ID>ArgumentListWrapping:SendMessageAction.kt$SendMessageAction$(monkeyReceiver.internalId)</ID>
        <ID>ArgumentListWrapping:SendMessageAction.kt$SendMessageAction$(monkeySender.internalId, EventType.SendDirectMessage(monkeyReceiver.internalId))</ID>
        <ID>ArgumentListWrapping:SendMessageAction.kt$SendMessageAction$(target)</ID>
        <ID>ArgumentListWrapping:SendMessageAction.kt$SendMessageAction$(this.config.userCount)</ID>
        <ID>ArgumentListWrapping:SendMessageEventAction.kt$SendMessageEventAction$( UserCount.single(), 1u, 1u )</ID>
        <ID>ArgumentListWrapping:SendMessagePartialFailureMapperTest.kt$SendMessagePartialFailureMapperTest$( MessageSent("2022-04-21T20:56:22.393Z", listOf(TEST_USER_ID, OTHER_USER_ID_2)), mapper.fromDTO(RESULT_DTO) )</ID>
        <ID>ArgumentListWrapping:SendMessagePartialFailureMapperTest.kt$SendMessagePartialFailureMapperTest$("2022-04-21T20:56:22.393Z", emptyList(), expectedUsersFailedToSend.map { it.toApi() })</ID>
        <ID>ArgumentListWrapping:SendMessageRequestJson.kt$SendMessageRequestJson$( MessageApi.Parameters.DefaultParameters( sender = "sender-client-it", data = null, nativePush = true, recipients = recipients, transient = false, priority = MessagePriority.LOW ), defaultParametersProvider )</ID>
        <ID>ArgumentListWrapping:SendRequestAction.kt$SendRequestAction$(Event(it.internalId, EventType.RequestResponse(origin.internalId, this.config.shouldAccept)))</ID>
        <ID>ArgumentListWrapping:SendRequestAction.kt$SendRequestAction$(it.internalId, EventType.RequestResponse(origin.internalId, this.config.shouldAccept))</ID>
        <ID>ArgumentListWrapping:SendRequestAction.kt$SendRequestAction$(origin.internalId, this.config.shouldAccept)</ID>
        <ID>ArgumentListWrapping:SendTextMessageCaseTest.kt$SendTextMessageCaseTest.Arrangement$(ObserveSelfDeletionTimerSettingsForConversationUseCase::class)</ID>
        <ID>ArgumentListWrapping:SendTextMessageCaseTest.kt$SendTextMessageCaseTest.Arrangement$(classOf&lt;MessageSendFailureHandler>())</ID>
        <ID>ArgumentListWrapping:SendTextMessageCaseTest.kt$SendTextMessageCaseTest.Arrangement$(mock(classOf&lt;MessageSendFailureHandler>()))</ID>
        <ID>ArgumentListWrapping:SendTypingEventUseCaseTest.kt$SendTypingEventUseCaseTest.Arrangement$(TypingIndicatorOutgoingRepository::class)</ID>
        <ID>ArgumentListWrapping:ServerConfig.kt$ServerConfigMapperImpl$( federation = metaData.federation, apiVersion = metaData.commonApiVersion.version, domain = metaData.domain )</ID>
        <ID>ArgumentListWrapping:ServerConfig.kt$ServerConfigMapperImpl$( federation = metaData.federation, commonApiVersion = apiVersionMapper.toDTO(metaData.apiVersion), domain = metaData.domain )</ID>
        <ID>ArgumentListWrapping:ServerConfig.kt$ServerConfigMapperImpl$(metaData.apiVersion)</ID>
        <ID>ArgumentListWrapping:ServerConfig.kt$ServerConfigMapperImpl$(metaData.federation, metaData.apiVersion.toCommonApiVersionType(), metaData.domain)</ID>
        <ID>ArgumentListWrapping:ServerConfig.kt$ServerConfigMapperImpl$(serverConfigEntityLinks)</ID>
        <ID>ArgumentListWrapping:ServerConfigMapperTest.kt$ServerConfigMapperTest$(1)</ID>
        <ID>ArgumentListWrapping:ServerConfigMapperTest.kt$ServerConfigMapperTest$(SERVER_CONFIG_TEST.metaData.commonApiVersion)</ID>
        <ID>ArgumentListWrapping:ServerConfigMapperTest.kt$ServerConfigMapperTest$(versionMapper)</ID>
        <ID>ArgumentListWrapping:ServerConfigRepositoryTest.kt$ServerConfigRepositoryTest$(1)</ID>
        <ID>ArgumentListWrapping:ServerConfigRepositoryTest.kt$ServerConfigRepositoryTest$(false, CommonApiVersionType.Unknown, "domain")</ID>
        <ID>ArgumentListWrapping:ServerConfigRepositoryTest.kt$ServerConfigRepositoryTest$(metaData = ServerConfig.MetaData(false, CommonApiVersionType.Unknown, "domain"))</ID>
        <ID>ArgumentListWrapping:ServerConfigurationDAO.kt$ServerConfigurationDAOImpl$(date, mapper::serverConfigWithAccId)</ID>
        <ID>ArgumentListWrapping:ServerConfigurationDAO.kt$ServerConfigurationDAOImpl$(queriesContext)</ID>
        <ID>ArgumentListWrapping:SessionEstablisher.kt$SessionEstablisherImpl$(client.value)</ID>
        <ID>ArgumentListWrapping:SessionEstablisher.kt$SessionEstablisherImpl$(idMapper.toCryptoQualifiedIDId(recipientUserId), CryptoClientId(client.value))</ID>
        <ID>ArgumentListWrapping:SessionEstablisher.kt$SessionEstablisherImpl$(recipientUserId)</ID>
        <ID>ArgumentListWrapping:SessionEstablisherTest.kt$SessionEstablisherTest$(CryptoSessionId(CryptoUserID(TEST_USER_ID_1.value, TEST_USER_ID_1.domain), CryptoClientId(TEST_CLIENT_ID_1.value)))</ID>
        <ID>ArgumentListWrapping:SessionEstablisherTest.kt$SessionEstablisherTest$(CryptoUserID(TEST_USER_ID_1.value, TEST_USER_ID_1.domain), CryptoClientId(TEST_CLIENT_ID_1.value))</ID>
        <ID>ArgumentListWrapping:SessionEstablisherTest.kt$SessionEstablisherTest$(TEST_CLIENT_ID_1.value)</ID>
        <ID>ArgumentListWrapping:SessionEstablisherTest.kt$SessionEstablisherTest$(TEST_USER_ID_1.domain to mapOf(TEST_USER_ID_1.value to mapOf(TEST_CLIENT_ID_1.value to preKey)))</ID>
        <ID>ArgumentListWrapping:SessionEstablisherTest.kt$SessionEstablisherTest$(TEST_USER_ID_1.value, TEST_USER_ID_1.domain)</ID>
        <ID>ArgumentListWrapping:SessionEstablisherTest.kt$SessionEstablisherTest$(eq(CryptoSessionId(CryptoUserID(TEST_USER_ID_1.value, TEST_USER_ID_1.domain), CryptoClientId(TEST_CLIENT_ID_1.value))))</ID>
        <ID>ArgumentListWrapping:SessionManagerExt.kt$("getProxyCredentials: Proxy has username: ${cred?.username?.isNotBlank()}; has password ${cred?.password?.isNotBlank()}")</ID>
        <ID>ArgumentListWrapping:SessionManagerImpl.kt$SessionManagerImpl$( { logout(LogoutReason.SESSION_EXPIRED) null }, { session -> session } )</ID>
        <ID>ArgumentListWrapping:SessionResetSenderTest.kt$SessionResetSenderTest$(testDispatchers.io)</ID>
        <ID>ArgumentListWrapping:SetUserHandleUseCase.kt$SetUserHandleUseCase$( { if (it is NetworkFailure.ServerMiscommunication &amp;&amp; it.kaliumException is KaliumException.InvalidRequestError) handleSpecificError(it.kaliumException) else SetUserHandleResult.Failure.Generic(it) }, { if (syncManager.isSlowSyncCompleted()) accountRepository.updateLocalSelfUserHandle(handleState.handle) SetUserHandleResult.Success } )</ID>
        <ID>ArgumentListWrapping:SetUserHandleUseCase.kt$SetUserHandleUseCase$(error)</ID>
        <ID>ArgumentListWrapping:SetUserHandleUseCase.kt$SetUserHandleUseCase$(handleState.handle)</ID>
        <ID>ArgumentListWrapping:ShouldRemoteMuteCheckerTest.kt$ShouldRemoteMuteCheckerTest.Companion$( OTHER_USER_ID, Conversation.Member.Role.Admin )</ID>
        <ID>ArgumentListWrapping:SlowSyncManager.kt$SlowSyncManager$(MIN_RETRY_DELAY, MAX_RETRY_DELAY)</ID>
        <ID>ArgumentListWrapping:SlowSyncManagerTest.kt$SlowSyncManagerTest$(TestKaliumDispatcher.default)</ID>
        <ID>ArgumentListWrapping:SlowSyncManagerTest.kt$SlowSyncManagerTest.Arrangement$(classOf&lt;SlowSyncRepository>())</ID>
        <ID>ArgumentListWrapping:SlowSyncManagerTest.kt$SlowSyncManagerTest.Arrangement$(mock(classOf&lt;SlowSyncRepository>()))</ID>
        <ID>ArgumentListWrapping:SlowSyncRepositoryTest.kt$SlowSyncRepositoryTest$(testDispatcher)</ID>
        <ID>ArgumentListWrapping:SlowSyncWorker.kt$SlowSyncWorkerImpl$(SlowSyncStep.RESOLVE_ONE_ON_ONE_PROTOCOLS, oneOnOneResolver::resolveAllOneOnOneConversations)</ID>
        <ID>ArgumentListWrapping:SlowSyncWorkerTest.kt$SlowSyncWorkerTest$(TestKaliumDispatcher.default)</ID>
        <ID>ArgumentListWrapping:SlowSyncWorkerTest.kt$SlowSyncWorkerTest.Arrangement$(UpdateSelfUserSupportedProtocolsUseCase::class)</ID>
        <ID>ArgumentListWrapping:StartCallUseCaseTest.kt$StartCallUseCaseTest.Arrangement$( lazy { callManager }, syncManager, kaliumConfigs, callRepository, answerCall )</ID>
        <ID>ArgumentListWrapping:StoreServerConfigUseCaseTest.kt$StoreServerConfigUseCaseTest.Arrangement$( customServerConfigRepository::storeConfig, fun2&lt;ServerConfig.Links, ServerConfig.VersionInfo>())</ID>
        <ID>ArgumentListWrapping:SyncFeatureConfigsUseCaseTest.kt$SyncFeatureConfigsUseCaseTest$(Either.Left(NetworkFailure.ServerMiscommunication(operationDeniedException)))</ID>
        <ID>ArgumentListWrapping:SyncFeatureConfigsUseCaseTest.kt$SyncFeatureConfigsUseCaseTest$(NetworkFailure.ServerMiscommunication(operationDeniedException))</ID>
        <ID>ArgumentListWrapping:SyncFeatureConfigsUseCaseTest.kt$SyncFeatureConfigsUseCaseTest$(operationDeniedException)</ID>
        <ID>ArgumentListWrapping:SyncFeatureConfigsUseCaseTest.kt$SyncFeatureConfigsUseCaseTest.Arrangement$( status, isStatusChanged )</ID>
        <ID>ArgumentListWrapping:SyncFeatureConfigsUseCaseTest.kt$SyncFeatureConfigsUseCaseTest.Arrangement$(classOf&lt;UpdateSupportedProtocolsAndResolveOneOnOnesUseCase>())</ID>
        <ID>ArgumentListWrapping:SyncManager.kt$SyncManagerImpl$("Waiting until or failure. Current status: slowSync: $slowSyncState; incrementalSync: $incrementalSyncState")</ID>
        <ID>ArgumentListWrapping:SyncManagerTest.kt$SyncManagerTest$(CoreFailure.MissingClientRegistration)</ID>
        <ID>ArgumentListWrapping:SyncManagerTest.kt$SyncManagerTest$(IncrementalSyncStatus.FetchingPendingEvents)</ID>
        <ID>ArgumentListWrapping:SyncManagerTest.kt$SyncManagerTest$(SlowSyncStatus.Failed(CoreFailure.MissingClientRegistration))</ID>
        <ID>ArgumentListWrapping:SyncManagerTest.kt$SyncManagerTest.Arrangement$( slowSyncRepository, incrementalSyncRepository )</ID>
        <ID>ArgumentListWrapping:TeamEventReceiverTest.kt$TeamEventReceiverTest.Arrangement$( userRepository, persistMessageUseCase, TestUser.USER_ID )</ID>
        <ID>ArgumentListWrapping:TeamRepositoryTest.kt$TeamRepositoryTest$("clientId")</ID>
        <ID>ArgumentListWrapping:TeamRepositoryTest.kt$TeamRepositoryTest$("teamId")</ID>
        <ID>ArgumentListWrapping:TeamRepositoryTest.kt$TeamRepositoryTest$(1, "key")</ID>
        <ID>ArgumentListWrapping:TeamRepositoryTest.kt$TeamRepositoryTest$(500, "error_message", "error_label")</ID>
        <ID>ArgumentListWrapping:TeamRepositoryTest.kt$TeamRepositoryTest$(ErrorResponse(500, "error_message", "error_label"))</ID>
        <ID>ArgumentListWrapping:TeamRepositoryTest.kt$TeamRepositoryTest$(KaliumException.ServerError(ErrorResponse(500, "error_message", "error_label")))</ID>
        <ID>ArgumentListWrapping:TeamRepositoryTest.kt$TeamRepositoryTest$(LegalHoldStatusDTO.PENDING, ClientIdDTO("clientId"), LastPreKeyDTO(1, "key"))</ID>
        <ID>ArgumentListWrapping:TeamRepositoryTest.kt$TeamRepositoryTest$(NetworkResponse.Error(KaliumException.ServerError(ErrorResponse(500, "error_message", "error_label"))))</ID>
        <ID>ArgumentListWrapping:TeamRepositoryTest.kt$TeamRepositoryTest$(teamId = TeamId("teamId"), userDomain = "userDomain", limit, pageSize = pageSize)</ID>
        <ID>ArgumentListWrapping:TeamRepositoryTest.kt$TeamRepositoryTest.Arrangement$(NetworkResponse.Success(value = SERVICE_DETAILS_RESPONSE, headers = mapOf(), httpCode = 200))</ID>
        <ID>ArgumentListWrapping:TeamRepositoryTest.kt$TeamRepositoryTest.Arrangement$(value = SERVICE_DETAILS_RESPONSE, headers = mapOf(), httpCode = 200)</ID>
        <ID>ArgumentListWrapping:TestConversation.kt$TestConversation$(ConversationEntity.AccessRole.NON_TEAM_MEMBER, ConversationEntity.AccessRole.TEAM_MEMBER)</ID>
        <ID>ArgumentListWrapping:TestDataImporter.kt$( "action" to "login", "email" to email )</ID>
        <ID>ArgumentListWrapping:TestDataImporter.kt$( "config" to mapOf( "allowedCipherSuites" to listOf(1), "defaultCipherSuite" to 1, "defaultProtocol" to "proteus", "protocolToggleUsers" to listOf&lt;String>(), "supportedProtocols" to listOf("mls", "proteus") ), "status" to "enabled" )</ID>
        <ID>ArgumentListWrapping:TestDataImporter.kt$( "email" to email, "name" to ownerName, "password" to backendConfig.passwordForUsers, "email_code" to code, "team" to mapOf( "name" to backendConfig.teamName, "icon" to "default", "binding" to true ) )</ID>
        <ID>ArgumentListWrapping:TestDataImporter.kt$( "email" to email, "name" to userName, "password" to userPassword, "team_code" to invitationCode )</ID>
        <ID>ArgumentListWrapping:TestDataImporter.kt$( "email" to email, "password" to password, "label" to "", "verification_code" to secondFactor )</ID>
        <ID>ArgumentListWrapping:TestDataImporter.kt$( "status" to "disabled", "ttl" to "unlimited" )</ID>
        <ID>ArgumentListWrapping:TestDataImporter.kt$("Owner $email (id $userId) of team ${backendConfig.teamName} (id: $teamId) in backend ${backendConfig.domain}")</ID>
        <ID>ArgumentListWrapping:TestDataImporter.kt$(OkHttp.create())</ID>
        <ID>ArgumentListWrapping:TestDataImporter.kt$(userData.email, userData.userId)</ID>
        <ID>ArgumentListWrapping:TestDataImporter.kt$TestDataImporter$( user.email, backendConfig.passwordForUsers, UserId(user.unqualifiedId, backendConfig.domain), team, null )</ID>
        <ID>ArgumentListWrapping:TestDataImporter.kt$TestDataImporter$(it, team, backendConfig.passwordForUsers)</ID>
        <ID>ArgumentListWrapping:TestDataImporter.kt$TestDataImporter$(user.unqualifiedId, backendConfig.domain)</ID>
        <ID>ArgumentListWrapping:TestDatabaseManipulation.kt$("test_db_secret".toByteArray())</ID>
        <ID>ArgumentListWrapping:TestDatabaseManipulation.kt$(ApplicationProvider.getApplicationContext(), GlobalDatabaseSecret("test_db_secret".toByteArray()))</ID>
        <ID>ArgumentListWrapping:TestEvent.kt$TestEvent$( eventId, TestClient.CLIENT )</ID>
        <ID>ArgumentListWrapping:ToggleReactionUseCase.kt$ToggleReactionUseCase$(messageId = messageId, emojiSet = currentReactions - removedReaction)</ID>
        <ID>ArgumentListWrapping:ToggleReactionUseCaseTest.kt$ToggleReactionUseCaseTest.Arrangement$(TEST_CURRENT_CLIENT)</ID>
        <ID>ArgumentListWrapping:TriggerBuffer.kt$TriggerBuffer$(extraBufferCapacity = 1, onBufferOverflow = BufferOverflow.DROP_OLDEST)</ID>
        <ID>ArgumentListWrapping:TypingIndicatorHandlerTest.kt$TypingIndicatorHandlerTest.Arrangement$(TypingIndicatorIncomingRepository::class)</ID>
        <ID>ArgumentListWrapping:TypingIndicatorOutgoingRepository.kt$TypingIndicatorOutgoingRepositoryImpl$(conversationId)</ID>
        <ID>ArgumentListWrapping:TypingIndicatorOutgoingRepositoryTest.kt$TypingIndicatorOutgoingRepositoryTest$(conversationOne, Conversation.TypingIndicatorMode.STARTED)</ID>
        <ID>ArgumentListWrapping:TypingIndicatorOutgoingRepositoryTest.kt$TypingIndicatorOutgoingRepositoryTest$(conversationOne, Conversation.TypingIndicatorMode.STOPPED)</ID>
        <ID>ArgumentListWrapping:UnreadEventMapper.kt$UnreadEventMapper$(conversationId = conversationId, unreadEvents = mapOf&lt;UnreadEventTypeEntity, Int>() .plus(UnreadEventTypeEntity.KNOCK to (knocksCount?.toInt() ?: 0)) .plus(UnreadEventTypeEntity.MISSED_CALL to (missedCallsCount?.toInt() ?: 0)) .plus(UnreadEventTypeEntity.MENTION to (mentionsCount?.toInt() ?: 0)) .plus(UnreadEventTypeEntity.REPLY to (repliesCount?.toInt() ?: 0)) .plus(UnreadEventTypeEntity.MESSAGE to (messagesCount?.toInt() ?: 0)) .filterValues { it > 0 } )</ID>
        <ID>ArgumentListWrapping:UpdateConversationAccessUseCaseTest.kt$UpdateConversationAccessUseCaseTest$( Conversation.AccessRole.TEAM_MEMBER, Conversation.AccessRole.SERVICE, Conversation.AccessRole.GUEST )</ID>
        <ID>ArgumentListWrapping:UpdateConversationAccessUseCaseTest.kt$UpdateConversationAccessUseCaseTest$(guestAllowed = false, servicesAllowed = true, nonTeamMembersAllowed = true)</ID>
        <ID>ArgumentListWrapping:UpdateConversationAccessUseCaseTest.kt$UpdateConversationAccessUseCaseTest$(guestAllowed = true, servicesAllowed = true, nonTeamMembersAllowed = true)</ID>
        <ID>ArgumentListWrapping:UpdateConversationArchivedStatusUseCase.kt$UpdateConversationArchivedStatusUseCaseImpl$(conversationId, shouldArchiveConversation, archivedStatusTimestamp)</ID>
        <ID>ArgumentListWrapping:UpdateConversationArchivedStatusUseCaseTest.kt$UpdateConversationArchivedStatusUseCaseTest$(conversationId, isConversationArchived, onlyLocally, archivedStatusTimestamp)</ID>
        <ID>ArgumentListWrapping:UpdateConversationMutedStatusUseCase.kt$UpdateConversationMutedStatusUseCaseImpl$("Something went wrong when updating the convId: " + "(${conversationId.toLogString()}) to (${mutedConversationStatus.status}")</ID>
        <ID>ArgumentListWrapping:UpdateConversationMutedStatusUseCase.kt$UpdateConversationMutedStatusUseCaseImpl$(conversationId, mutedConversationStatus, mutedStatusTimestamp)</ID>
        <ID>ArgumentListWrapping:UpdateConversationReceiptModeUseCaseTest.kt$UpdateConversationReceiptModeUseCaseTest.Arrangement$( conversationRepository, persistMessage, selfUserId )</ID>
        <ID>ArgumentListWrapping:UpdateCurrentSessionUseCaseTest.kt$UpdateCurrentSessionUseCaseTest$(classOf&lt;SessionRepository>())</ID>
        <ID>ArgumentListWrapping:UpdateCurrentSessionUseCaseTest.kt$UpdateCurrentSessionUseCaseTest$(mock(classOf&lt;SessionRepository>()))</ID>
        <ID>ArgumentListWrapping:UpdateEmailUseCaseTest.kt$UpdateEmailUseCaseTest$(IOException())</ID>
        <ID>ArgumentListWrapping:UpdateEmailUseCaseTest.kt$UpdateEmailUseCaseTest$(KaliumException.GenericError(IOException()))</ID>
        <ID>ArgumentListWrapping:UpdateEmailUseCaseTest.kt$UpdateEmailUseCaseTest$(NetworkFailure.ServerMiscommunication(KaliumException.GenericError(IOException())))</ID>
        <ID>ArgumentListWrapping:UpdateSelfUserSupportedProtocolsUseCase.kt$UpdateSelfUserSupportedProtocolsUseCaseImpl$(supportedProtocols, migrationConfiguration, selfClients, currentClientId)</ID>
        <ID>ArgumentListWrapping:UploadUserAvatarUseCaseTest.kt$UploadUserAvatarUseCaseTest.Arrangement$(userRepository, assetRepository)</ID>
        <ID>ArgumentListWrapping:UserConfigRepository.kt$UserConfigDataSource$(duration.inWholeMilliseconds)</ID>
        <ID>ArgumentListWrapping:UserConversationDAOIntegrationTest.kt$UserConversationDAOIntegrationTest$( "3", "someDomain" )</ID>
        <ID>ArgumentListWrapping:UserConversationDAOIntegrationTest.kt$UserConversationDAOIntegrationTest$( conversationId, listOf( MemberEntity( user = QualifiedIDEntity( "3", "someDomain" ), role = MemberEntity.Role.Admin ) ) )</ID>
        <ID>ArgumentListWrapping:UserConversationDAOIntegrationTest.kt$UserConversationDAOIntegrationTest$( conversationId, listOf( MemberEntity( user = user1.id, role = MemberEntity.Role.Admin ), MemberEntity( user = user2.id, role = MemberEntity.Role.Member ), ) )</ID>
        <ID>ArgumentListWrapping:UserConversationDAOIntegrationTest.kt$UserConversationDAOIntegrationTest$( memberList = members, conversationID = conversationIDEntity )</ID>
        <ID>ArgumentListWrapping:UserConversationDAOIntegrationTest.kt$UserConversationDAOIntegrationTest$( user = QualifiedIDEntity( "3", "someDomain" ), role = MemberEntity.Role.Admin )</ID>
        <ID>ArgumentListWrapping:UserConversationDAOIntegrationTest.kt$UserConversationDAOIntegrationTest$( user = user1.id, role = MemberEntity.Role.Admin )</ID>
        <ID>ArgumentListWrapping:UserConversationDAOIntegrationTest.kt$UserConversationDAOIntegrationTest$( user = user2.id, role = MemberEntity.Role.Member )</ID>
        <ID>ArgumentListWrapping:UserConversationDAOIntegrationTest.kt$UserConversationDAOIntegrationTest$("3", "someDomain")</ID>
        <ID>ArgumentListWrapping:UserConversationDAOIntegrationTest.kt$UserConversationDAOIntegrationTest$(QualifiedIDEntity("3", "someDomain"))</ID>
        <ID>ArgumentListWrapping:UserConversationDAOIntegrationTest.kt$UserConversationDAOIntegrationTest$(email = "emailMatch")</ID>
        <ID>ArgumentListWrapping:UserConversationDAOIntegrationTest.kt$UserConversationDAOIntegrationTest$(handle = "handleMatch")</ID>
        <ID>ArgumentListWrapping:UserDAOImpl.kt$UserDAOImpl$(listOf(qualifiedID))</ID>
        <ID>ArgumentListWrapping:UserDAOImpl.kt$UserDAOImpl$(qualifiedID)</ID>
        <ID>ArgumentListWrapping:UserDAOImpl.kt$UserDAOImpl$(queriesContext)</ID>
        <ID>ArgumentListWrapping:UserDAOImpl.kt$UserDAOImpl$(searchQuery, connectionStates)</ID>
        <ID>ArgumentListWrapping:UserDAOTest.kt$UserDAOTest$("conversationId", "domain")</ID>
        <ID>ArgumentListWrapping:UserDAOTest.kt$UserDAOTest$("conversationId1on1", "domain")</ID>
        <ID>ArgumentListWrapping:UserDAOTest.kt$UserDAOTest$("newActiveOneOnOneConversationId", "newActiveOneOnOneConversationDomain")</ID>
        <ID>ArgumentListWrapping:UserDAOTest.kt$UserDAOTest$(ConnectionEntity.State.ACCEPTED)</ID>
        <ID>ArgumentListWrapping:UserDAOTest.kt$UserDAOTest$(commonEmailPrefix, listOf(ConnectionEntity.State.ACCEPTED))</ID>
        <ID>ArgumentListWrapping:UserDAOTest.kt$UserDAOTest$(commonPrefix, listOf(ConnectionEntity.State.ACCEPTED))</ID>
        <ID>ArgumentListWrapping:UserDAOTest.kt$UserDAOTest$(dispatcher)</ID>
        <ID>ArgumentListWrapping:UserDAOTest.kt$UserDAOTest$(id = ConversationIDEntity("conversationId", "domain"))</ID>
        <ID>ArgumentListWrapping:UserDAOTest.kt$UserDAOTest$(id = ConversationIDEntity("conversationId1on1", "domain"))</ID>
        <ID>ArgumentListWrapping:UserDAOTest.kt$UserDAOTest$(name = "other name to make sure this one wasn't inserted nor edited")</ID>
        <ID>ArgumentListWrapping:UserDAOTest.kt$UserDAOTest$(type = ConversationEntity.Type.GROUP)</ID>
        <ID>ArgumentListWrapping:UserDAOTest.kt$UserDAOTest$(type = ConversationEntity.Type.ONE_ON_ONE)</ID>
        <ID>ArgumentListWrapping:UserDAOTest.kt$UserDAOTest$(user1.copy(name = "other name to make sure this one wasn't inserted nor edited"), user2)</ID>
        <ID>ArgumentListWrapping:UserDAOTest.kt$UserDAOTest$(user1.name!!, listOf(ConnectionEntity.State.ACCEPTED))</ID>
        <ID>ArgumentListWrapping:UserDTOJson.kt$UserDTOJson$( SelfUserDTO( id = UserId("user_id", "domain.com"), name = "user_name_123", accentId = 2, assets = listOf(), deleted = null, email = null, handle = null, service = null, teamId = null, expiresAt = "", nonQualifiedId = "", locale = "", managedByDTO = null, phone = null, ssoID = null, supportedProtocols = null ), jsonProvider )</ID>
        <ID>ArgumentListWrapping:UserDatabaseDataGenerator.kt$UserDatabaseDataGenerator$(ConversationEntity.Access.values()[index % ConversationEntity.Access.values().size])</ID>
        <ID>ArgumentListWrapping:UserDatabaseDataGenerator.kt$UserDatabaseDataGenerator$(ConversationEntity.AccessRole.values()[index % ConversationEntity.AccessRole.values().size])</ID>
        <ID>ArgumentListWrapping:UserDatabaseDataGenerator.kt$UserDatabaseDataGenerator$(MemberEntity(userEntity.id, MemberEntity.Role.Member), conversationId)</ID>
        <ID>ArgumentListWrapping:UserDatabaseDataGenerator.kt$UserDatabaseDataGenerator$(userEntity.id, MemberEntity.Role.Member)</ID>
        <ID>ArgumentListWrapping:UserEventReceiverTest.kt$UserEventReceiverTest$(arrangement.newGroupConversationSystemMessagesCreator::conversationStartedUnverifiedWarning)</ID>
        <ID>ArgumentListWrapping:UserMapper.kt$UserMapperImpl$( name = newName, accentId = newAccent, assets = if (newAssetId != null) { listOf( UserAssetDTO(newAssetId, AssetSizeDTO.COMPLETE, UserAssetTypeDTO.IMAGE), UserAssetDTO(newAssetId, AssetSizeDTO.PREVIEW, UserAssetTypeDTO.IMAGE) ) } else { null } )</ID>
        <ID>ArgumentListWrapping:UserMapper.kt$UserMapperImpl$(connectionState = userEntity.connectionStatus)</ID>
        <ID>ArgumentListWrapping:UserPrefBuilder.kt$UserPrefBuilder$(SettingOptions.UserSettings(shouldEncryptData, userId), EncryptedSettingsPlatformParam(rootPath))</ID>
        <ID>ArgumentListWrapping:UserPrefBuilder.kt$UserPrefBuilder$(rootPath)</ID>
        <ID>ArgumentListWrapping:UserPrefBuilder.kt$UserPrefBuilder$(shouldEncryptData, userId)</ID>
        <ID>ArgumentListWrapping:UserRepository.kt$UserDataSource$("User ids contains different domains when federation is not enabled by backend: $domainNames")</ID>
        <ID>ArgumentListWrapping:UserRepository.kt$UserDataSource$(Json.encodeToString(userEntity.id), SELF_USER_ID_KEY)</ID>
        <ID>ArgumentListWrapping:UserRepository.kt$UserDataSource$(mapTeamMemberDTO[userProfileDTO.id.value]?.permissions?.own)</ID>
        <ID>ArgumentListWrapping:UserRepository.kt$UserDataSource$(qualifiedUserIdList.filter { it.domain == selfUserId.domain } .map { userId -> userId.toApi() })</ID>
        <ID>ArgumentListWrapping:UserRepository.kt$UserDataSource$(selfUserTeamId?.value, selfUserDomain)</ID>
        <ID>ArgumentListWrapping:UserRepository.kt$UserDataSource$(status)</ID>
        <ID>ArgumentListWrapping:UserRepository.kt$UserDataSource$(teamMemberDTO?.permissions?.own)</ID>
        <ID>ArgumentListWrapping:UserRepository.kt$UserDataSource$(userDTO.id.toModel(), idMapper.toSsoId(userDTO.ssoID), userDTO.managedByDTO)</ID>
        <ID>ArgumentListWrapping:UserRepository.kt$UserDataSource$(userDTO.ssoID)</ID>
        <ID>ArgumentListWrapping:UserRepository.kt$UserDataSource$(userEntity.id)</ID>
        <ID>ArgumentListWrapping:UserRepository.kt$UserDataSource$(userId.toDao(), availabilityStatusMapper.fromModelAvailabilityStatusToDao(status))</ID>
        <ID>ArgumentListWrapping:UserRepositoryTest.kt$UserRepositoryTest$("id-valid", "domain2")</ID>
        <ID>ArgumentListWrapping:UserRepositoryTest.kt$UserRepositoryTest$(ListUsersDTO(usersFailed = emptyList(), listOf(TestUser.USER_PROFILE_DTO)))</ID>
        <ID>ArgumentListWrapping:UserRepositoryTest.kt$UserRepositoryTest$(TestUser.DETAILS_ENTITY.copy(id = UserIDEntity(value = "id1", domain = "domain1")))</ID>
        <ID>ArgumentListWrapping:UserRepositoryTest.kt$UserRepositoryTest$(TestUser.USER_PROFILE_DTO)</ID>
        <ID>ArgumentListWrapping:UserRepositoryTest.kt$UserRepositoryTest$(id = QualifiedIDEntity("id-valid", "domain2"), hasIncompleteMetadata = false)</ID>
        <ID>ArgumentListWrapping:UserRepositoryTest.kt$UserRepositoryTest$(id = UserIDEntity(value = "id1", domain = "domain1"))</ID>
        <ID>ArgumentListWrapping:UserRepositoryTest.kt$UserRepositoryTest$(id = userIdWithConsent.toApi(), legalHoldStatus = LegalHoldStatusDTO.DISABLED)</ID>
        <ID>ArgumentListWrapping:UserRepositoryTest.kt$UserRepositoryTest$(id = userIdWithoutConsent.toApi(), legalHoldStatus = LegalHoldStatusDTO.NO_CONSENT)</ID>
        <ID>ArgumentListWrapping:UserRepositoryTest.kt$UserRepositoryTest$(usersFailed = emptyList(), listOf(TestUser.USER_PROFILE_DTO))</ID>
        <ID>ArgumentListWrapping:UserRepositoryTest.kt$UserRepositoryTest$(value = "id1", domain = "domain1")</ID>
        <ID>ArgumentListWrapping:UserRepositoryTest.kt$UserRepositoryTest.Arrangement$(NetworkResponse.Success(TestUser.SELF_USER_DTO.copy(teamId = TestTeam.TEAM_ID.value), mapOf(), 200))</ID>
        <ID>ArgumentListWrapping:UserRepositoryTest.kt$UserRepositoryTest.Arrangement$(TestUser.SELF_USER_DTO.copy(teamId = TestTeam.TEAM_ID.value), mapOf(), 200)</ID>
        <ID>ArgumentListWrapping:UserRepositoryTest.kt$UserRepositoryTest.Arrangement$(teamId = TestTeam.TEAM_ID.value)</ID>
        <ID>ArgumentListWrapping:UserScope.kt$UserScope$(accountRepository, validateUserHandleUseCase, syncManager)</ID>
        <ID>ArgumentListWrapping:UserSearchApiWrapperTest.kt$UserSearchApiWrapperTest$( ConversationMemberExcludedOptions.ConversationExcluded( ConversationId( "someValue", "someDomain" ) ), selfUserIncluded = false )</ID>
        <ID>ArgumentListWrapping:UserSearchApiWrapperTest.kt$UserSearchApiWrapperTest$( ConversationMemberExcludedOptions.ConversationExcluded( ConversationId( "someValue", "someDomain" ) ), selfUserIncluded = true )</ID>
        <ID>ArgumentListWrapping:UserSearchApiWrapperTest.kt$UserSearchApiWrapperTest$( user = QualifiedIDEntity( "value3", "someDomain" ), role = MemberEntity.Role.Member )</ID>
        <ID>ArgumentListWrapping:UserSearchApiWrapperTest.kt$UserSearchApiWrapperTest$( user = QualifiedIDEntity( selfUser.id.value, selfUser.id.domain ), role = MemberEntity.Role.Member )</ID>
        <ID>ArgumentListWrapping:UserSessionScope.kt$UserSessionScope$( authenticatedNetworkContainer.notificationApi, userStorage.database.metadataDAO, clientIdProvider, userId )</ID>
        <ID>ArgumentListWrapping:UserSessionScope.kt$UserSessionScope$( clientIdProvider, authenticatedNetworkContainer.keyPackageApi, mlsClientProvider, userId )</ID>
        <ID>ArgumentListWrapping:UserSessionScope.kt$UserSessionScope$( clientRepository, notificationTokenRepository, pushTokenRepository )</ID>
        <ID>ArgumentListWrapping:UserSessionScope.kt$UserSessionScope$( conversationRepository, connectionRepository, userRepository, userStorage.database.memberDAO, persistMessage, userId )</ID>
        <ID>ArgumentListWrapping:UserSessionScope.kt$UserSessionScope$( conversations.observeConversationMembers, conversationRepository, userConfigRepository )</ID>
        <ID>ArgumentListWrapping:UserSessionScope.kt$UserSessionScope$( memberJoinHandler, memberLeaveHandler )</ID>
        <ID>ArgumentListWrapping:UserSessionScope.kt$UserSessionScope$( mlsClientProvider, clientRepository, keyPackageRepository, keyPackageLimitsProvider, userConfigRepository )</ID>
        <ID>ArgumentListWrapping:UserSessionScope.kt$UserSessionScope$( proteusClientProvider = proteusClientProvider, selfUserId = userId )</ID>
        <ID>ArgumentListWrapping:UserSessionScope.kt$UserSessionScope$( slowSyncRepository, incrementalSyncRepository )</ID>
        <ID>ArgumentListWrapping:UserSessionScope.kt$UserSessionScope$( userId, platformUserStorageProperties, kaliumConfigs.shouldEncryptData )</ID>
        <ID>ArgumentListWrapping:UserSessionScope.kt$UserSessionScope$( userId, qualifiedIdMapper, globalScope.sessionRepository )</ID>
        <ID>ArgumentListWrapping:UserSessionScope.kt$UserSessionScope$( userRepository, conversationRepository, EphemeralEventsNotificationManagerImpl )</ID>
        <ID>ArgumentListWrapping:UserSessionScope.kt$UserSessionScope$( userStorage.database.conversationDAO, persistMessage )</ID>
        <ID>ArgumentListWrapping:UserSessionScope.kt$UserSessionScope$(clientIdProvider, isAllowedToRegisterMLSClient, incrementalSyncRepository, lazy { slowSyncRepository }, lazy { clientRepository }, lazy { RegisterMLSClientUseCaseImpl( mlsClientProvider, clientRepository, keyPackageRepository, keyPackageLimitsProvider, userConfigRepository ) })</ID>
        <ID>ArgumentListWrapping:UserSessionScope.kt$UserSessionScope$(featureSupport, incrementalSyncRepository, lazy { clientRepository }, lazy { client.refillKeyPackages }, lazy { client.mlsKeyPackageCountUseCase }, lazy { users.timestampKeyRepository })</ID>
        <ID>ArgumentListWrapping:UserSessionScope.kt$UserSessionScope$(featureSupport, incrementalSyncRepository, lazy { clientRepository }, lazy { conversations.updateMLSGroupsKeyingMaterials }, lazy { users.timestampKeyRepository })</ID>
        <ID>ArgumentListWrapping:UserSessionScope.kt$UserSessionScope$(messageRepository, assetRepository, EphemeralEventsNotificationManagerImpl, userId)</ID>
        <ID>ArgumentListWrapping:UserSessionScope.kt$UserSessionScope$(userId, observeLegalHoldStateForUser, observeLegalHoldRequest)</ID>
        <ID>ArgumentListWrapping:UserSessionScope.kt$UserSessionScope$(userId, userConfigRepository, observeLegalHoldStateForUser)</ID>
        <ID>ArgumentListWrapping:UserSessionScope.kt$UserSessionScope$(userStorage.database.metadataDAO)</ID>
        <ID>ArgumentListWrapping:Utils.kt$("{{monkeyClientId}}", monkeyId.clientId.toString())</ID>
        <ID>ArgumentListWrapping:Utils.kt$("{{monkeyIndex}}", monkeyId.index.toString())</ID>
        <ID>ArgumentListWrapping:ValidatePasswordUseCaseTest.kt$ValidatePasswordUseCaseTest$("A1@3.")</ID>
        <ID>ArgumentListWrapping:ValidatePasswordUseCaseTest.kt$ValidatePasswordUseCaseTest$("a1@3.")</ID>
        <ID>ArgumentListWrapping:ValidatePasswordUseCaseTest.kt$ValidatePasswordUseCaseTest$("aA13")</ID>
        <ID>ArgumentListWrapping:ValidateSSOCodeUseCaseTest.kt$ValidateSSOCodeUseCaseTest$(code)</ID>
        <ID>ArgumentListWrapping:ValidateUserHandleUseCase.kt$ValidateUserHandleResult.Invalid$(handleWithoutInvalidCharacters)</ID>
        <ID>ArgumentListWrapping:ValidateUserHandleUseCase.kt$ValidateUserHandleUseCaseImpl$(handleWithoutInvalidCharacters, invalidCharactersUsed)</ID>
        <ID>ArgumentListWrapping:VerifyBackupUseCase.kt$VerifyBackupUseCaseImpl$(dispatchers.io)</ID>
        <ID>ArgumentListWrapping:WorkSchedulerImpl.kt$GlobalWorkSchedulerImpl$( localDateTimeNow.year, localDateTimeNow.monthNumber, localDateTimeNow.dayOfMonth, scheduledHourOfDayToExecute, 0, 0, 0 )</ID>
        <ID>ArgumentListWrapping:WorkSchedulerImpl.kt$GlobalWorkSchedulerImpl$(localTimeZone)</ID>
        <ID>ArgumentListWrapping:WorkSchedulerImpl.kt$GlobalWorkSchedulerImpl$(workerClass, repeatIntervalInHours.toLong(), TimeUnit.HOURS)</ID>
        <ID>ArgumentListWrapping:WrapApiRequestTest.kt$WrapApiRequestTest$( 500, "have you tried turning it off and on again?", "server_crash" )</ID>
        <ID>ArgumentListWrapping:WrapperWorker.kt$(key, Json.encodeToString(value))</ID>
        <ID>ArgumentListWrapping:WrapperWorker.kt$(value)</ID>
        <ID>ArgumentListWrapping:WrapperWorker.kt$WrapperWorker$(Context.NOTIFICATION_SERVICE)</ID>
        <ID>ArgumentListWrapping:WrapperWorker.kt$WrapperWorkerFactory$("No specialized constructor found for class $innerWorkerClassName. Default constructor will be used")</ID>
        <ID>ArgumentListWrapping:WrapperWorker.kt$WrapperWorkerFactory$(innerWorker as DefaultWorker, appContext, workerParameters, foregroundNotificationDetailsProvider)</ID>
        <ID>ArgumentListWrapping:WrapperWorker.kt$WrapperWorkerFactory$(userId)</ID>
        <ID>ArgumentListWrapping:build.gradle.kts$("main")</ID>
        <ID>ArgumentListWrapping:build.gradle.kts$(libs.coreCryptoAndroid.get().let { "${it.module}:${it.versionConstraint.requiredVersion}" })</ID>
        <ID>ArgumentListWrapping:homeDirectory.kt$( rootPath, kaliumConfigs = KaliumConfigs( developmentApiEnabled = true, encryptProteusStorage = true, isMLSSupportEnabled = true, wipeOnDeviceRemoval = true, ), userAgent = "Wire Infinite Monkeys", useInMemoryStorage = true )</ID>
        <ID>ClassNaming:Cryptobox.module_@wireapp_cryptobox.kt$T$0</ID>
        <ID>ClassNaming:Size_t.kt$Size_t : IntegerType</ID>
        <ID>ClassNaming:Uint32_t.kt$Uint32_t : IntegerType</ID>
        <ID>CommentSpacing:E2EIClientTest.kt$E2EIClientTest$//todo: fix later</ID>
        <ID>CommentSpacing:GetOrRegisterClientUseCaseTest.kt$GetOrRegisterClientUseCaseTest$//todo: fix later</ID>
        <ID>CommentSpacing:MLSClientManagerTest.kt$MLSClientManagerTest.Arrangement$//todo: cover all cases</ID>
        <ID>CommentSpacing:RegisterClientUseCaseTest.kt$RegisterClientUseCaseTest$//finalizing the client registration</ID>
        <ID>CommentSpacing:RegisterClientUseCaseTest.kt$RegisterClientUseCaseTest$//make sure we invoked the team settings fetched</ID>
        <ID>CommentSpacing:RegisterClientUseCaseTest.kt$RegisterClientUseCaseTest$//mls returns e2ei is required</ID>
        <ID>CommentSpacing:SlowSyncCriteriaProviderTest.kt$SlowSyncCriteriaProviderTest$//todo: fix later</ID>
        <ID>CommentSpacing:UserDAOTest.kt$UserDAOTest$//given</ID>
        <ID>EmptyDefaultConstructor:GetUpdatedSelfTeamUseCaseTest.kt$GetUpdatedSelfTeamUseCaseTest.Arrangement$()</ID>
        <ID>EmptyDefaultConstructor:MembersHavingLegalHoldClientUseCaseTest.kt$MembersHavingLegalHoldClientUseCaseTest.Arrangement$()</ID>
        <ID>EmptyDefaultConstructor:ObserveConversationUnderLegalHoldNotifiedUseCaseTest.kt$ObserveConversationUnderLegalHoldNotifiedUseCaseTest.Arrangement$()</ID>
        <ID>EmptyDefaultConstructor:SetNotifiedAboutConversationUnderLegalHoldUseCaseTest.kt$SetNotifiedAboutConversationUnderLegalHoldUseCaseTest.Arrangement$()</ID>
        <ID>EmptyFunctionBlock:FileTestHelper.kt$FileTestHelper${ }</ID>
        <ID>EmptyKtFile:FetchApiVersionUseCaseTest.kt$.FetchApiVersionUseCaseTest.kt</ID>
        <ID>Filename:ConversationStatus.kt$com.wire.kalium.logic.data.conversation.ConversationStatus.kt</ID>
        <ID>Filename:FileUtilTest.kt$com.wire.kalium.util.FileUtilTest.kt</ID>
        <ID>Filename:GetOtherUserClientsUseCaseTest.kt$com.wire.kalium.logic.feature.client.GetOtherUserClientsUseCaseTest.kt</ID>
        <ID>Filename:InputFlow.kt$com.wire.kalium.cli.commands.InputFlow.kt</ID>
        <ID>Filename:LegalHoldSystemMessageHandlerTest.kt$com.wire.kalium.logic.sync.receiver.handler.legalhold.LegalHoldSystemMessageHandlerTest.kt</ID>
        <ID>Filename:SessionResult.kt$com.wire.kalium.logic.feature.session.SessionResult.kt</ID>
        <ID>Filename:Uint32_t.kt$com.wire.kalium.calling.types.Uint32_t.kt</ID>
        <ID>Filename:commonJsConfig.kt$com.wire.kalium.plugins.commonJsConfig.kt</ID>
        <ID>Filename:coreLogic.kt$com.wire.kalium.cli.coreLogic.kt</ID>
        <ID>Filename:defaultHttpEngine.kt$com.wire.kalium.network.defaultHttpEngine.kt</ID>
        <ID>Filename:fileLogger.kt$com.wire.kalium.cli.fileLogger.kt</ID>
        <ID>Filename:fileLogger.kt$com.wire.kalium.monkeys.fileLogger.kt</ID>
        <ID>Filename:homeDirectory.kt$com.wire.kalium.cli.homeDirectory.kt</ID>
        <ID>Filename:homeDirectory.kt$com.wire.kalium.monkeys.homeDirectory.kt</ID>
        <ID>Filename:main.kt$.main.kt</ID>
        <ID>Filename:main.kt$com.wire.kalium.cli.main.kt</ID>
        <ID>Filename:main.kt$com.wire.kalium.monkeys.main.kt</ID>
        <ID>Filename:monkey.kt$com.wire.kalium.monkeys.monkey.kt</ID>
        <ID>Filename:readBinaryResource.kt$com.wire.kalium.cryptography.readBinaryResource.kt</ID>
        <ID>Filename:replayer.kt$com.wire.kalium.monkeys.replayer.kt</ID>
        <ID>Filename:toByteArray.kt$com.wire.kalium.util.int.toByteArray.kt</ID>
        <ID>Filename:toByteArray.kt$com.wire.kalium.util.long.toByteArray.kt</ID>
        <ID>Filename:toUTF16BEByteArray.kt$com.wire.kalium.util.string.toUTF16BEByteArray.kt</ID>
        <ID>FunctionNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open fun get_prekey_bundle(preKeyId: Number = definedExternally): Promise&lt;PreKeyBundle></ID>
        <ID>FunctionNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open fun get_serialized_last_resort_prekey(): Promise&lt;`T$0`></ID>
        <ID>FunctionNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open fun get_serialized_standard_prekeys(): Promise&lt;Array&lt;`T$0`>></ID>
        <ID>FunctionNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open fun new_prekeys(start: Number, size: Number): Promise&lt;Array&lt;PreKey>></ID>
        <ID>FunctionNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open fun serialize_prekey(prekey: PreKey): `T$0`</ID>
        <ID>FunctionNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open fun session_delete(sessionId: String): Promise&lt;String></ID>
        <ID>FunctionNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open fun session_from_prekey(sessionId: String, preKeyBundle: ArrayBuffer): Promise&lt;CryptoboxSession></ID>
        <ID>FunctionNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open fun session_load(sessionId: String): Promise&lt;CryptoboxSession></ID>
        <ID>FunctionNaming:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$CryptoboxCRUDStore$open fun delete_all(): Promise&lt;Boolean></ID>
        <ID>FunctionNaming:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$CryptoboxCRUDStore$open fun load_identity(): Promise&lt;IdentityKeyPair?></ID>
        <ID>FunctionNaming:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$CryptoboxCRUDStore$open fun load_prekeys(): Promise&lt;Array&lt;PreKey>></ID>
        <ID>FunctionNaming:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$CryptoboxCRUDStore$open fun save_identity(identity: IdentityKeyPair): Promise&lt;IdentityKeyPair></ID>
        <ID>FunctionNaming:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$CryptoboxCRUDStore$open fun save_prekey(preKey: PreKey): Promise&lt;PreKey></ID>
        <ID>FunctionNaming:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$CryptoboxCRUDStore$open fun save_prekeys(preKeys: Array&lt;PreKey>): Promise&lt;Array&lt;PreKey>></ID>
        <ID>FunctionNaming:CryptoboxSession.module_@wireapp_cryptobox.kt$CryptoboxSession$open fun fingerprint_local(): String</ID>
        <ID>FunctionNaming:CryptoboxSession.module_@wireapp_cryptobox.kt$CryptoboxSession$open fun fingerprint_remote(): String</ID>
        <ID>FunctionNaming:Encoder.module_@wireapp_cbor.kt$Encoder$open fun array_begin(): Encoder</ID>
        <ID>FunctionNaming:Encoder.module_@wireapp_cbor.kt$Encoder$open fun array_end(): Encoder</ID>
        <ID>FunctionNaming:Encoder.module_@wireapp_cbor.kt$Encoder$open fun get_buffer(): ArrayBuffer</ID>
        <ID>FunctionNaming:Encoder.module_@wireapp_cbor.kt$Encoder$open fun object_begin(): Encoder</ID>
        <ID>FunctionNaming:Encoder.module_@wireapp_cbor.kt$Encoder$open fun object_end(): Encoder</ID>
        <ID>FunctionNaming:KeyPair.module_@wireapp_proteus.kt$KeyPair.Companion$fun construct_private_key(ed25519_key_pair: KeyPair): SecretKey</ID>
        <ID>FunctionNaming:KeyPair.module_@wireapp_proteus.kt$KeyPair.Companion$fun construct_public_key(ed25519_key_pair: KeyPair): PublicKey</ID>
        <ID>FunctionNaming:PreKey.module_@wireapp_proteus.kt$PreKey.Companion$fun generate_prekeys(start: Number, size: Number): Array&lt;PreKey></ID>
        <ID>FunctionNaming:PreKey.module_@wireapp_proteus.kt$PreKey.Companion$fun last_resort(): PreKey</ID>
        <ID>FunctionNaming:PreKeyBundle.module_@wireapp_proteus.kt$PreKeyBundle$open fun serialised_json(): SerialisedJSON</ID>
        <ID>FunctionNaming:PreKeyStore.module_@wireapp_proteus.kt$PreKeyStore$open fun delete_prekey(prekeyId: Number): Promise&lt;Number></ID>
        <ID>FunctionNaming:PreKeyStore.module_@wireapp_proteus.kt$PreKeyStore$open fun load_prekey(prekeyId: Number): Promise&lt;PreKey?></ID>
        <ID>FunctionNaming:SecretKey.module_@wireapp_proteus.kt$SecretKey.Companion$fun shared_secret(publicKey: PublicKey, secretKey: SecretKey): Uint8Array</ID>
        <ID>FunctionParameterNaming:Calling.kt$Calling$curr_time: Uint32_t</ID>
        <ID>FunctionParameterNaming:Calling.kt$Calling$msg_time: Uint32_t</ID>
        <ID>FunctionParameterNaming:Calling.kt$Calling$wcall_participant_changed_h: ParticipantChangedHandler</ID>
        <ID>FunctionParameterNaming:CryptoboxSession.module_@wireapp_cryptobox.kt$CryptoboxSession$pk_store: CryptoboxCRUDStore</ID>
        <ID>FunctionParameterNaming:KeyPair.module_@wireapp_proteus.kt$KeyPair.Companion$ed25519_key_pair: KeyPair</ID>
        <ID>FunctionReturnTypeSpacing:BaseMLSClientTest.kt$BaseMLSClientTest$actual suspend fun createCoreCrypto(clientId: CryptoQualifiedClientId):CoreCryptoCentral</ID>
        <ID>FunctionStartOfBodySpacing:E2EIClientProviderTest.kt$E2EIClientProviderTest$@Test fun givenIsNewClientTrue_whenGettingE2EIClient_newAcmeEnrollmentCalled()</ID>
        <ID>FunctionStartOfBodySpacing:MLSWelcomeEventHandlerTest.kt$MLSWelcomeEventHandlerTest$@Test fun givenWelcomeBundleWithNewDistributionsCRL_whenHandlingEvent_then_CheckRevocationList()</ID>
        <ID>LargeClass:E2EIRepositoryTest.kt$E2EIRepositoryTest</ID>
        <ID>LargeClass:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest</ID>
        <ID>LargeClass:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest</ID>
        <ID>LargeClass:MessageSenderTest.kt$MessageSenderTest</ID>
        <ID>LargeClass:UserDAOTest.kt$UserDAOTest : BaseDatabaseTest</ID>
        <ID>LargeClass:UserRepositoryTest.kt$UserRepositoryTest</ID>
        <ID>LongMethod:ClientRepositoryTest.kt$ClientRepositoryTest$@Test fun whenSelfListOfClientsIsReturnSuccess_thenTheSuccessIsPropagated()</ID>
        <ID>LongMethod:ConversationDAOTest.kt$ConversationDAOTest$private fun ConversationEntity.toViewEntity(userEntity: UserEntity? = null): ConversationViewEntity</ID>
        <ID>LongMethod:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$@Test fun givenCreateNewAccountFails_whenInvokeUseCase_thenReturnFailure()</ID>
        <ID>LongMethod:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$@Test fun givenGetACMENonceFails_whenInvokeUseCase_thenReturnFailure()</ID>
        <ID>LongMethod:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$@Test fun givenLoadACMEDirectoriesFails_whenInvokeUseCase_thenReturnFailure()</ID>
        <ID>LongMethod:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$@Test fun givenUseCase_whenCreateAuthorizationsFailing_thenReturnFailure()</ID>
        <ID>LongMethod:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest$@Test fun givenUseCase_whenCreateNewOrderFailing_thenReturnFailure()</ID>
        <ID>LongMethod:EphemeralMessageDeletionHandlerTest.kt$EphemeralMessageDeletionHandlerTest$@Test fun givenMultipleMessageWithDifferentExpirationAsReceiver_whenEnqueuedForDeletionAndTimeElapsed_thenTheMessagesPastTheTimeShouldBeDeleted()</ID>
        <ID>LongMethod:EphemeralMessageDeletionHandlerTest.kt$EphemeralMessageDeletionHandlerTest$@Test fun givenMultipleMessageWithDifferentExpirationAsSender_whenEnqueuedForDeletionAndTimeElapsed_thenTheMessagesPastTheTimeShouldBeDeleted()</ID>
        <ID>LongMethod:FederationEventReceiverTest.kt$FederationEventReceiverTest$@Test fun givenConversationsWithFederatedUsers_whenReceivingFederationDeleteEvent_thenAllConversationsWithThemShouldBeCleared()</ID>
        <ID>LongMethod:MLSConversationsVerificationStatusesHandlerTest.kt$MLSConversationsVerificationStatusesHandlerTest$@Test fun givenDegradedConversation_whenVerifiedStatusComes_thenStatusUpdated()</ID>
        <ID>LongMethod:MLSConversationsVerificationStatusesHandlerTest.kt$MLSConversationsVerificationStatusesHandlerTest$@Test fun givenVerifiedConversation_whenVerifiedStatusComesAndUserNamesDivergeFromCC_thenStatusUpdatedToDegraded()</ID>
        <ID>LongMethod:MessageDAOTest.kt$MessageDAOTest$@Test fun givenAssetMessageWithMimeType_WhenGettingAssetMessages_ThenListShouldContainAssetMessageWithMimeType()</ID>
        <ID>LongMethod:MessageDAOTest.kt$MessageDAOTest$@Test fun givenMessagesAreInserted_whenGettingMessagesByConversation_thenOnlyRelevantMessagesAreReturned()</ID>
        <ID>LongMethod:MessageMapperTest.kt$MessageMapperTest.Arrangement$@Suppress("LongParameterList") fun toEntityFromView( id: String = "", conversationId: QualifiedIDEntity = QualifiedIDEntity("someValue", "someDomain"), contentType: MessageEntity.ContentType = MessageEntity.ContentType.TEXT, date: Instant = Instant.DISTANT_FUTURE, senderUserId: QualifiedIDEntity = QualifiedIDEntity("someValue", "someDomain"), senderClientId: String? = "someId", status: MessageEntity.Status = MessageEntity.Status.READ, lastEditTimestamp: Instant? = null, visibility: MessageEntity.Visibility = MessageEntity.Visibility.VISIBLE, expectsReadConfirmation: Boolean = false, expireAfterMillis: Long? = null, selfDeletionStartDate: Instant? = null, selfDeletionEndDate: Instant? = null, readCount: Long = 0, senderName: String? = null, senderHandle: String? = null, senderEmail: String? = null, senderPhone: String? = null, senderAccentId: Int = 0, senderTeamId: String? = null, senderConnectionStatus: ConnectionEntity.State = ConnectionEntity.State.ACCEPTED, senderPreviewAssetId: QualifiedIDEntity? = null, senderCompleteAssetId: QualifiedIDEntity? = null, senderAvailabilityStatus: UserAvailabilityStatusEntity = UserAvailabilityStatusEntity.AVAILABLE, senderUserType: UserTypeEntity = UserTypeEntity.STANDARD, senderBotService: BotIdEntity? = null, senderIsDeleted: Boolean = false, senderExpiresAt: Instant? = null, senderDefederated: Boolean = false, senderSupportedProtocols: Set&lt;SupportedProtocolEntity>? = null, senderActiveOneOnOneConversationId: QualifiedIDEntity? = null, senderIsProteusVerified: Long = 0, senderIsUnderLegalHold: Long = 0, isSelfMessage: Boolean = false, text: String? = null, isQuotingSelfUser: Boolean? = null, assetSize: Long? = null, assetName: String? = null, assetMimeType: String? = null, assetOtrKey: ByteArray? = null, assetSha256: ByteArray? = null, assetId: String? = null, assetToken: String? = null, assetDomain: String? = null, assetEncryptionAlgorithm: String? = null, assetWidth: Int? = null, assetHeight: Int? = null, assetDuration: Long? = null, assetNormalizedLoudness: ByteArray? = null, callerId: QualifiedIDEntity? = null, memberChangeList: List&lt;QualifiedIDEntity>? = null, memberChangeType: MessageEntity.MemberChangeType? = null, unknownContentTypeName: String? = null, unknownContentData: ByteArray? = null, restrictedAssetMimeType: String? = null, restrictedAssetSize: Long? = null, restrictedAssetName: String? = null, failedToDecryptData: ByteArray? = null, isDecryptionResolved: Boolean? = null, conversationName: String? = null, allReactionsJson: String = "{}", selfReactionsJson: String = "[]", mentions: String = "[]", quotedMessageId: String? = null, quotedSenderId: QualifiedIDEntity? = null, isQuoteVerified: Boolean? = null, quotedSenderName: String? = null, quotedMessageDateTime: Instant? = null, quotedMessageEditTimestamp: Instant? = null, quotedMessageVisibility: MessageEntity.Visibility? = null, quotedMessageContentType: MessageEntity.ContentType? = null, quotedTextBody: String? = null, quotedAssetMimeType: String? = null, quotedAssetName: String? = null, quotedLocationName: String? = null, newConversationReceiptMode: Boolean? = null, conversationReceiptModeChanged: Boolean? = null, messageTimerChanged: Long? = null, recipientsFailedWithNoClientsList: List&lt;QualifiedIDEntity>? = null, recipientsFailedDeliveryList: List&lt;QualifiedIDEntity>? = null, buttonsJson: String = "[]", federationDomainList: List&lt;String>? = null, federationType: MessageEntity.FederationType? = null, conversationProtocolChanged: ConversationEntity.Protocol? = null, latitude: Float? = null, longitude: Float? = null, locationName: String? = null, locationZoom: Int? = null, legalHoldMemberList: List&lt;QualifiedIDEntity>? = null, legalHoldType: MessageEntity.LegalHoldType? = null, ): MessageEntity</ID>
        <ID>LongMethod:UserDAOTest.kt$UserDAOTest$@Test fun givenExistingUser_whenUpsertingIt_thenAllImportantFieldsAreProperlyUpdated()</ID>
        <ID>LongParameterList:ApiTest.kt$ApiTest$( responseBody: ByteReadChannel, statusCode: HttpStatusCode, assertion: (HttpRequestData.() -> Unit) = {}, headers: Map&lt;String, String>?, developmentApiEnabled: Boolean = false, networkStateObserver: NetworkStateObserver = DEFAULT_TEST_NETWORK_STATE_OBSERVER, )</ID>
        <ID>LongParameterList:ApiTest.kt$ApiTest$( responseBody: String, statusCode: HttpStatusCode, assertion: (HttpRequestData.() -> Unit) = {}, headers: Map&lt;String, String>? = null, developmentApiEnabled: Boolean = false, networkStateObserver: NetworkStateObserver = DEFAULT_TEST_NETWORK_STATE_OBSERVER, )</ID>
        <ID>LongParameterList:Calling.kt$Calling$( userId: String, clientId: String, readyHandler: ReadyHandler, sendHandler: SendHandler, sftRequestHandler: SFTRequestHandler, incomingCallHandler: IncomingCallHandler, missedCallHandler: MissedCallHandler, answeredCallHandler: AnsweredCallHandler, establishedCallHandler: EstablishedCallHandler, closeCallHandler: CloseCallHandler, metricsHandler: MetricsHandler, callConfigRequestHandler: CallConfigRequestHandler, constantBitRateStateChangeHandler: ConstantBitRateStateChangeHandler, videoReceiveStateHandler: VideoReceiveStateHandler, arg: Pointer? )</ID>
        <ID>LongParameterList:DetektConfigurationAccessors.kt$( group: String, name: String, version: String? = null, configuration: String? = null, classifier: String? = null, ext: String? = null, dependencyConfiguration: Action&lt;ExternalModuleDependency>? = null )</ID>
        <ID>LongParameterList:DetektPluginsConfigurationAccessors.kt$( group: String, name: String, version: String? = null, configuration: String? = null, classifier: String? = null, ext: String? = null, dependencyConfiguration: Action&lt;ExternalModuleDependency>? = null )</ID>
        <ID>LongParameterList:IncomingCallHandler.kt$IncomingCallHandler$( conversationId: String, messageTime: Uint32_t, userId: String, clientId: String, isVideoCall: Boolean, shouldRing: Boolean, conversationType: Int, arg: Pointer? )</ID>
        <ID>LongParameterList:Multiplatform.kt$( enableApple: Boolean, enableJs: Boolean, enableJsTests: Boolean, includeNativeInterop: Boolean, enableIntegrationTests: Boolean, androidNamespaceSuffix: String = this.name )</ID>
        <ID>LongParameterList:ToggleReactionUseCase.kt$ToggleReactionUseCase$( clientId: ClientId, conversationId: ConversationId, date: String, messageId: String, currentReactions: UserReactions, newReaction: String )</ID>
        <ID>LongParameterList:ToggleReactionUseCase.kt$ToggleReactionUseCase$( clientId: ClientId, conversationId: ConversationId, date: String, messageId: String, removedReaction: String, currentReactions: UserReactions )</ID>
        <ID>MagicNumber:ConversationStatus.kt$MutedConversationStatus.AllMuted$3</ID>
        <ID>MagicNumber:GlobalCallManager.kt$LogHandlerImpl$3</ID>
        <ID>MagicNumber:NetworkUtils.kt$300</ID>
        <ID>MagicNumber:NetworkUtils.kt$399</ID>
        <ID>MagicNumber:NetworkUtils.kt$400</ID>
        <ID>MagicNumber:NetworkUtils.kt$499</ID>
        <ID>MagicNumber:NetworkUtils.kt$500</ID>
        <ID>MagicNumber:NetworkUtils.kt$599</ID>
        <ID>MagicNumber:RegisterClientRequestJson.kt$RegisterClientRequestJson$999</ID>
        <ID>MatchingDeclarationName:ConversationStatus.kt$MutedConversationStatus</ID>
        <ID>MatchingDeclarationName:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$CryptoboxCRUDStore : PreKeyStore</ID>
        <ID>MatchingDeclarationName:CryptoboxSession.module_@wireapp_cryptobox.kt$CryptoboxSession</ID>
        <ID>MatchingDeclarationName:Encoder.module_@wireapp_cbor.kt$Encoder</ID>
        <ID>MatchingDeclarationName:FileUtilTest.kt$FileTestHelper</ID>
        <ID>MatchingDeclarationName:GetOtherUserClientsUseCaseTest.kt$ObserveClientsByUserIdUseCaseTest</ID>
        <ID>MatchingDeclarationName:IdentityKey.module_@wireapp_proteus.kt$IdentityKey</ID>
        <ID>MatchingDeclarationName:IdentityKeyPair.module_@wireapp_proteus.kt$IdentityKeyPair</ID>
        <ID>MatchingDeclarationName:KeyPair.module_@wireapp_proteus.kt$KeyPair</ID>
        <ID>MatchingDeclarationName:LegalHoldSystemMessageHandlerTest.kt$LegalHoldSystemMessagesHandlerTest</ID>
        <ID>MatchingDeclarationName:MemoryEngine.module_@wireapp_store-engine.kt$MemoryEngine : CRUDEngine</ID>
        <ID>MatchingDeclarationName:PreKey.module_@wireapp_proteus.kt$PreKey</ID>
        <ID>MatchingDeclarationName:PreKeyStore.module_@wireapp_proteus.kt$PreKeyStore</ID>
        <ID>MatchingDeclarationName:PublicKey.module_@wireapp_proteus.kt$PublicKey</ID>
        <ID>MatchingDeclarationName:SecretKey.module_@wireapp_proteus.kt$SecretKey</ID>
        <ID>MatchingDeclarationName:SessionResult.kt$GetAllSessionsResult</ID>
        <ID>MatchingDeclarationName:Widgets.kt$CustomScrollRegion : Widget</ID>
        <ID>MaxLineLength:BaseDatabaseTest.kt$BaseDatabaseTest$actual fun platformDBData(userId: UserIDEntity): PlatformDatabaseData</ID>
        <ID>MaxLineLength:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest.Arrangement$fun</ID>
        <ID>MaxLineLength:ConversationRepositoryTest.kt$ConversationRepositoryTest$keyingMaterialLastUpdate = (entity.protocolInfo as ConversationEntity.ProtocolInfo.MLS).keyingMaterialLastUpdate</ID>
        <ID>MaxLineLength:E2EIClientTest.kt$E2EIClientTest.Companion$"eyJhbGciOiJSUzI1NiIsImtpZCI6ImM5YWZkYTM2ODJlYmYwOWViMzA1NWMxYzRiZDM5Yjc1MWZiZjgxOTUiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJhenAiOiIzMzg4ODgxNTMwNzItNGZlcDZ0bjZrMTZ0bWNiaGc0bnQ0bHI2NXB2M2F2Z2kuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJhdWQiOiIzMzg4ODgxNTMwNzItNGZlcDZ0bjZrMTZ0bWNiaGc0bnQ0bHI2NXB2M2F2Z2kuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJzdWIiOiIxMTU0OTM2MTQ1MjMzNjgyNjc2OTAiLCJoZCI6IndpcmUuY29tIiwiZW1haWwiOiJtb2p0YWJhLmNoZW5hbmlAd2lyZS5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXRfaGFzaCI6IkRtZDhJQXdnWmVKX1QtUjBpRlpseGciLCJub25jZSI6IjEta2FZb1hRODdadEVlRGpVYTVQSVEiLCJuYW1lIjoiTW9qdGFiYSBDaGVuYW5pIiwicGljdHVyZSI6Imh0dHBzOi8vbGgzLmdvb2dsZXVzZXJjb250ZW50LmNvbS9hL0FHTm15eGFhaWFKa1Y4VDNmMW91d0RWVjNQck52UFBaVUpIZGdnMlJ4N0s0PXM5Ni1jIiwiZ2l2ZW5fbmFtZSI6Ik1vanRhYmEiLCJmYW1pbHlfbmFtZSI6IkNoZW5hbmkiLCJsb2NhbGUiOiJlbiIsImlhdCI6MTY4MzQ4MjIyOSwiZXhwIjoxNjgzNDg1ODI5fQ.r0hh1CtVUXncdWHoXsfAvhf0VuWGDooSRQnNqq0GrzAbYVENGwg0dm8P10Cq_UmCjjh56nC5laMQUcBu-sKW9mRbdKnHwdXXregTSgelQJFoIlusb_3VyHcWDY8Yf9xyuyZbu3wcduL8IndTvy8Sq7mIzGKhsHnLIy1UgHbCGMrzfY2LYCi9Df1ADqA8romigo8fdEAVUi9TAIC8SgHOcqLJt8mxlhKSPPwkJw5yZ3CRvF2NMNsVkYpE9hVYbHcZd6EAmJnljKPJ-NQLXUdjaU3ail80YQko4rcgF2QMZ3LBSMGJpI5LM2UhDxnktqBTpE2nLdwCFg64INS48DPDXQ"</ID>
        <ID>MaxLineLength:EphemeralMessageDeletionHandlerTest.kt$EphemeralMessageDeletionHandlerTest$fun</ID>
        <ID>MaxLineLength:IdentityKeyPair.module_@wireapp_proteus.kt$IdentityKeyPair$external open</ID>
        <ID>MaxLineLength:MemoryEngine.module_@wireapp_store-engine.kt$MemoryEngine$override fun &lt;PrimaryKey, ChangesType> updateOrCreate(tableName: String, primaryKey: PrimaryKey, changes: ChangesType): Promise&lt;PrimaryKey></ID>
        <ID>MaxLineLength:MessageSenderTest.kt$MessageSenderTest$fun</ID>
        <ID>MaxLineLength:NewGroupConversationSystemMessagesCreatorTest.kt$NewGroupConversationSystemMessagesCreatorTest$sysMessageCreator.conversationReadReceiptStatus(TestConversation.CONVERSATION_RESPONSE.copy(type = ConversationResponse.Type.ONE_TO_ONE))</ID>
        <ID>MaxLineLength:PreKeyBundle.module_@wireapp_proteus.kt$PreKeyBundle$constructor(publicIdentityKey: IdentityKey, preKeyId: Number, publicKey: PublicKey, signature: Uint8Array? = definedExternally, version: Number = definedExternally)</ID>
        <ID>MaxLineLength:SelfClientsUseCaseTest.kt$SelfClientsUseCaseTest$fetchSelfClientsFromRemoteUseCase = FetchSelfClientsFromRemoteUseCaseImpl(clientRepository, provideClientId = currentClientIdProvider)</ID>
        <ID>MaxLineLength:SendKnockUserCaseTest.kt$SendKnockUserCaseTest.Arrangement$ObserveSelfDeletionTimerSettingsForConversationUseCaseArrangement by ObserveSelfDeletionTimerSettingsForConversationUseCaseArrangementImpl()</ID>
        <ID>MaxLineLength:SendLocationUseCaseTest.kt$SendLocationUseCaseTest.Arrangement$ObserveSelfDeletionTimerSettingsForConversationUseCaseArrangement by ObserveSelfDeletionTimerSettingsForConversationUseCaseArrangementImpl()</ID>
        <ID>MaxLineLength:SyncSelfTeamUseCaseTest.kt$SyncSelfTeamUseCaseTest$fun</ID>
        <ID>MaximumLineLength:BaseDatabaseTest.kt$BaseDatabaseTest$ </ID>
        <ID>MaximumLineLength:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest.Arrangement$ </ID>
        <ID>MaximumLineLength:ConversationRepositoryTest.kt$ConversationRepositoryTest$ </ID>
        <ID>MaximumLineLength:E2EIClientTest.kt$E2EIClientTest.Companion$ </ID>
        <ID>MaximumLineLength:EphemeralMessageDeletionHandlerTest.kt$EphemeralMessageDeletionHandlerTest$ </ID>
        <ID>MaximumLineLength:MessageSenderTest.kt$MessageSenderTest$ </ID>
        <ID>MaximumLineLength:NewGroupConversationSystemMessagesCreatorTest.kt$NewGroupConversationSystemMessagesCreatorTest$ </ID>
        <ID>MaximumLineLength:SelfClientsUseCaseTest.kt$SelfClientsUseCaseTest$ </ID>
        <ID>MaximumLineLength:SendKnockUserCaseTest.kt$SendKnockUserCaseTest.Arrangement$ </ID>
        <ID>MaximumLineLength:SendLocationUseCaseTest.kt$SendLocationUseCaseTest.Arrangement$ </ID>
        <ID>MaximumLineLength:SyncSelfTeamUseCaseTest.kt$SyncSelfTeamUseCaseTest$ </ID>
        <ID>MayBeConst:ACMEActions.kt$ACMEActions$/** * URL Paths */ private val ACME_BASE_URL = "https://balderdash.hogwash.work:9000/acme/google-android/"</ID>
        <ID>MayBeConst:CommonDokkaConfig.kt$private val DOKKA_CACHE_DIR = ".cache/dokka"</ID>
        <ID>MayBeConst:ConversationDAOTest.kt$ConversationDAOTest.Companion$val messageTimer = 5000L</ID>
        <ID>MayBeConst:E2EIClientTest.kt$E2EIClientTest.Companion$val ACCESS_TOKEN_RESPONSE = """ { "expires_in":"300", "token":"eyJhbGciOiJFZERTQSIsInR5cCI6ImF0K2p3dCIsImp3ayI6eyJrdHkiOiJPS1AiLCJjcnYiOiJFZDI1NTE5IiwieCI6ImdxTk8wZ1FzRndfUUNQNm5xeV9BUWxNVDFQSTAtZ3lRMWZTMGhJZklyTWcifX0.eyJpYXQiOjE2ODM0NjgwODIsImV4cCI6MTY5MTI0NDA4MiwibmJmIjoxNjgzNDY4MDgyLCJpc3MiOiJodHRwczovL3N0YWdpbmcuemluZnJhLmlvL2NsaWVudHMvNGVlZGJmZTE2ZDI1YmJmMy9hY2Nlc3MtdG9rZW4iLCJzdWIiOiJpbTp3aXJlYXBwPVpURTFNamMwTXpFeU5EUTBOR0poWTJFMU5XWm1OakEyWlRrMU1qSXlNek0vNGVlZGJmZTE2ZDI1YmJmM0BzdGFnaW5nLnppbmZyYS5pbyIsImF1ZCI6Imh0dHBzOi8vc3RhZ2luZy56aW5mcmEuaW8vY2xpZW50cy80ZWVkYmZlMTZkMjViYmYzL2FjY2Vzcy10b2tlbiIsImp0aSI6ImM3ZjRhODAxLTVhZTUtNDNlOC04ZGJiLWRiYjE1ZmEwODM1ZSIsIm5vbmNlIjoiaEJWWTdjRjNSWC1lSnF0cW9nbVl0dyIsImNoYWwiOiJMeGpJNVBUeVZ2UU56ZW9yUWNPUm44OURtR1BaZEc3SyIsImNuZiI6eyJraWQiOiI3YXR6MldkcGxwSzNhbmtKVmp6cm1telVEZmdhNkFTMjRCRm1VbEJ2V1lFIn0sInByb29mIjoiZXlKaGJHY2lPaUpGWkVSVFFTSXNJblI1Y0NJNkltUndiM0FyYW5kMElpd2lhbmRySWpwN0ltdDBlU0k2SWs5TFVDSXNJbU55ZGlJNklrVmtNalUxTVRraUxDSjRJam9pVVZkUldrTklRemxSVFhOaVFtWk5SbmRrTmpONlZtNTFVbFZNVVVKSU1sVnNaRGh5WDBWTFNtSXlTU0o5ZlEuZXlKcFlYUWlPakUyT0RNME5qZ3dOemtzSW1WNGNDSTZNVFk0TXpRMk9ERXdPU3dpYm1KbUlqb3hOamd6TkRZNE1EYzVMQ0p6ZFdJaU9pSnBiVHAzYVhKbFlYQndQVnBVUlRGTmFtTXdUWHBGZVU1RVVUQk9SMHBvV1RKRk1VNVhXbTFPYWtFeVdsUnJNVTFxU1hsTmVrMHZOR1ZsWkdKbVpURTJaREkxWW1KbU0wQnpkR0ZuYVc1bkxucHBibVp5WVM1cGJ5SXNJbXAwYVNJNkltSmlOek5qTVdJekxUZ3dNMlF0TkRVMFlTMDROakl5TFdNellqUXlORFpoTTJZME9TSXNJbTV2Ym1ObElqb2lhRUpXV1RkalJqTlNXQzFsU25GMGNXOW5iVmwwZHlJc0ltaDBiU0k2SWxCUFUxUWlMQ0pvZEhVaU9pSm9kSFJ3Y3pvdkwzTjBZV2RwYm1jdWVtbHVabkpoTG1sdkwyTnNhV1Z1ZEhNdk5HVmxaR0ptWlRFMlpESTFZbUptTXk5aFkyTmxjM010ZEc5clpXNGlMQ0pqYUdGc0lqb2lUSGhxU1RWUVZIbFdkbEZPZW1WdmNsRmpUMUp1T0RsRWJVZFFXbVJITjBzaWZRLkl1YjJqTkRXY1lKdTZ0V1liX181UlNSSEhQQWV1ZmwwRkRPQzc3STY4UDZtcG96QjMxeGtmUEZUb2p3ckJtSEhLZHFLOWdJTTQ5YWcxb2pTclNlZkNnIiwiY2xpZW50X2lkIjoiaW06d2lyZWFwcD1aVEUxTWpjME16RXlORFEwTkdKaFkyRTFOV1ptTmpBMlpUazFNakl5TXpNLzRlZWRiZmUxNmQyNWJiZjNAc3RhZ2luZy56aW5mcmEuaW8iLCJhcGlfdmVyc2lvbiI6Mywic2NvcGUiOiJ3aXJlX2NsaWVudF9pZCJ9.kFoRHJotAJQTgLXXrH4m9ySutFJb2cc4Raa1nbOyRxNTFZyQuwbJT1jGAlIbziQmVEIZ5vneOg0TqBAyEtw3BQ", "type":"DPoP" }"""</ID>
        <ID>MayBeConst:E2EIClientTest.kt$E2EIClientTest.Companion$val AUTHZ_URL = "https://balderdash.hogwash.work:9000/acme/wire/authz/CSGJUN9BQ0mhELCBbvBJI7AlxcAH9ypD"</ID>
        <ID>MayBeConst:E2EIClientTest.kt$E2EIClientTest.Companion$val FINALIZE_ORDER_URL = "https://balderdash.hogwash.work:9000/acme/wire/order/Q4LJjBnX7rA8dwxVreikzmVJBfCvrVs0/finalize"</ID>
        <ID>MayBeConst:E2EIClientTest.kt$E2EIClientTest.Companion$val NONCE = "TGR6Rk45RlR2WDlzanMxWEpYd21YaFR0SkZBYTNzUWk"</ID>
        <ID>MayBeConst:E2EIClientTest.kt$E2EIClientTest.Companion$val OAUTH_ID_TOKEN = "eyJhbGciOiJSUzI1NiIsImtpZCI6ImM5YWZkYTM2ODJlYmYwOWViMzA1NWMxYzRiZDM5Yjc1MWZiZjgxOTUiLCJ0eXAiOiJKV1QifQ.eyJpc3MiOiJodHRwczovL2FjY291bnRzLmdvb2dsZS5jb20iLCJhenAiOiIzMzg4ODgxNTMwNzItNGZlcDZ0bjZrMTZ0bWNiaGc0bnQ0bHI2NXB2M2F2Z2kuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJhdWQiOiIzMzg4ODgxNTMwNzItNGZlcDZ0bjZrMTZ0bWNiaGc0bnQ0bHI2NXB2M2F2Z2kuYXBwcy5nb29nbGV1c2VyY29udGVudC5jb20iLCJzdWIiOiIxMTU0OTM2MTQ1MjMzNjgyNjc2OTAiLCJoZCI6IndpcmUuY29tIiwiZW1haWwiOiJtb2p0YWJhLmNoZW5hbmlAd2lyZS5jb20iLCJlbWFpbF92ZXJpZmllZCI6dHJ1ZSwiYXRfaGFzaCI6IkRtZDhJQXdnWmVKX1QtUjBpRlpseGciLCJub25jZSI6IjEta2FZb1hRODdadEVlRGpVYTVQSVEiLCJuYW1lIjoiTW9qdGFiYSBDaGVuYW5pIiwicGljdHVyZSI6Imh0dHBzOi8vbGgzLmdvb2dsZXVzZXJjb250ZW50LmNvbS9hL0FHTm15eGFhaWFKa1Y4VDNmMW91d0RWVjNQck52UFBaVUpIZGdnMlJ4N0s0PXM5Ni1jIiwiZ2l2ZW5fbmFtZSI6Ik1vanRhYmEiLCJmYW1pbHlfbmFtZSI6IkNoZW5hbmkiLCJsb2NhbGUiOiJlbiIsImlhdCI6MTY4MzQ4MjIyOSwiZXhwIjoxNjgzNDg1ODI5fQ.r0hh1CtVUXncdWHoXsfAvhf0VuWGDooSRQnNqq0GrzAbYVENGwg0dm8P10Cq_UmCjjh56nC5laMQUcBu-sKW9mRbdKnHwdXXregTSgelQJFoIlusb_3VyHcWDY8Yf9xyuyZbu3wcduL8IndTvy8Sq7mIzGKhsHnLIy1UgHbCGMrzfY2LYCi9Df1ADqA8romigo8fdEAVUi9TAIC8SgHOcqLJt8mxlhKSPPwkJw5yZ3CRvF2NMNsVkYpE9hVYbHcZd6EAmJnljKPJ-NQLXUdjaU3ail80YQko4rcgF2QMZ3LBSMGJpI5LM2UhDxnktqBTpE2nLdwCFg64INS48DPDXQ"</ID>
        <ID>MayBeConst:E2EIClientTest.kt$E2EIClientTest.Companion$val REFRESH_TOKEN = "YRjxLpsjRqL7zYuKstXogqioA_P3Z4fiEuga0NCVRcDSc8cy_9msxg"</ID>
        <ID>MayBeConst:E2EIRepositoryTest.kt$E2EIRepositoryTest.Arrangement.Companion$val ACME_BASE_URL = "https://balderdash.hogwash.work:9000"</ID>
        <ID>MayBeConst:E2EIRepositoryTest.kt$E2EIRepositoryTest.Arrangement.Companion$val RANDOM_ACCESS_TOKEN = "xxxxx"</ID>
        <ID>MayBeConst:E2EIRepositoryTest.kt$E2EIRepositoryTest.Arrangement.Companion$val RANDOM_ID_TOKEN = "xxxxx"</ID>
        <ID>MayBeConst:E2EIRepositoryTest.kt$E2EIRepositoryTest.Arrangement.Companion$val RANDOM_URL = "https://random.rn"</ID>
        <ID>MayBeConst:E2EIRepositoryTest.kt$E2EIRepositoryTest.Arrangement.Companion$val REFRESH_TOKEN = "YRjxLpsjRqL7zYuKstXogqioA_P3Z4fiEuga0NCVRcDSc8cy_9msxg"</ID>
        <ID>MayBeConst:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest.Companion$val ACME_BASE_URL = "https://balderdash.hogwash.work:9000"</ID>
        <ID>MayBeConst:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest.Companion$val RANDOM_DPoP_TOKEN = "dpopToken"</ID>
        <ID>MayBeConst:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest.Companion$val RANDOM_ID_TOKEN = "idToken"</ID>
        <ID>MayBeConst:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest.Companion$val RANDOM_LOCATION = "https://balderdash.hogwash.work:9000"</ID>
        <ID>MayBeConst:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest.Companion$val REFRESH_TOKEN = "YRjxLpsjRqL7zYuKstXogqioA_P3Z4fiEuga0NCVRcDSc8cy_9msxg"</ID>
        <ID>MayBeConst:PocIntegrationTest.kt$PocIntegrationTest.Companion$private val USER_EMAIL = "user@domain.com"</ID>
        <ID>MayBeConst:PocIntegrationTest.kt$PocIntegrationTest.Companion$private val USER_PASSWORD = "password"</ID>
        <ID>MayBeConst:RegisterMLSClientUseCaseTest.kt$RegisterMLSClientUseCaseTest.Arrangement.Companion$val RANDOM_URL = "https://random.rn"</ID>
        <ID>MayBeConst:TestStubs.kt$TestStubs$val messageTimer = 5000L</ID>
        <ID>ModifierOrder:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$external open</ID>
        <ID>ModifierOrder:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$CryptoboxCRUDStore$external open</ID>
        <ID>ModifierOrder:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$CryptoboxCRUDStore$override open</ID>
        <ID>ModifierOrder:CryptoboxSession.module_@wireapp_cryptobox.kt$CryptoboxSession$external open</ID>
        <ID>ModifierOrder:Decoder.module_@wireapp_cbor.kt$Decoder$external open</ID>
        <ID>ModifierOrder:Encoder.module_@wireapp_cbor.kt$Encoder$external open</ID>
        <ID>ModifierOrder:IdentityKey.module_@wireapp_proteus.kt$IdentityKey$external open</ID>
        <ID>ModifierOrder:IdentityKeyPair.module_@wireapp_proteus.kt$IdentityKeyPair$external open</ID>
        <ID>ModifierOrder:KeyPair.module_@wireapp_proteus.kt$KeyPair$external open</ID>
        <ID>ModifierOrder:MemoryEngine.module_@wireapp_store-engine.kt$MemoryEngine$external open</ID>
        <ID>ModifierOrder:PreKey.module_@wireapp_proteus.kt$PreKey$external open</ID>
        <ID>ModifierOrder:PreKeyBundle.module_@wireapp_proteus.kt$PreKeyBundle$external open</ID>
        <ID>ModifierOrder:PreKeyStore.module_@wireapp_proteus.kt$PreKeyStore$external open</ID>
        <ID>ModifierOrder:PublicKey.module_@wireapp_proteus.kt$PublicKey$external open</ID>
        <ID>ModifierOrder:SecretKey.module_@wireapp_proteus.kt$SecretKey$external open</ID>
        <ID>NestedBlockDepth:NetworkStateObserverImplTest.kt$NetworkStateObserverImplTest.Arrangement$fun changeNetworkBlocked(networkType: NetworkType, isBlocked: Boolean)</ID>
        <ID>NestedBlockDepth:NetworkStateObserverImplTest.kt$NetworkStateObserverImplTest.Arrangement$fun changeNetworkCapabilities(networkType: NetworkType, withInternetValidated: Boolean)</ID>
        <ID>NestedBlockDepth:NetworkStateObserverImplTest.kt$NetworkStateObserverImplTest.Arrangement$fun disconnectNetwork(networkType: NetworkType)</ID>
        <ID>NestedBlockDepth:NetworkStateObserverImplTest.kt$NetworkStateObserverImplTest.Arrangement$private fun changeDefaultNetwork(network: Network)</ID>
        <ID>NestedBlockDepth:ValidateSSOCodeUseCase.kt$ValidateSSOCodeUseCaseImpl$override fun invoke(ssoCode: String): ValidateSSOCodeResult</ID>
        <ID>NewLineAtEndOfFile:detekt.gradle.kts$scripts.detekt.gradle.kts</ID>
        <ID>NoBlankLinesInChainedMethodCalls:ClearConversationContentUseCaseTest.kt$ClearConversationContentUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:ACMEApiResponseJsonSample.kt$ACMEApiResponseJsonSample$ </ID>
        <ID>NoConsecutiveBlankLines:AccountRepositoryTest.kt$AccountRepositoryTest$ </ID>
        <ID>NoConsecutiveBlankLines:AddAuthenticatedUserUseCaseTest.kt$AddAuthenticatedUserUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:Android.kt$ </ID>
        <ID>NoConsecutiveBlankLines:AnswerCallUseCaseTest.kt$AnswerCallUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:BaseProteusClientTest.kt$BaseProteusClientTest$ </ID>
        <ID>NoConsecutiveBlankLines:ButtonActionConfirmationHandlerTest.kt$ButtonActionConfirmationHandlerTest$ </ID>
        <ID>NoConsecutiveBlankLines:ClientDAOTest.kt$ClientDAOTest$ </ID>
        <ID>NoConsecutiveBlankLines:ClientFingerprintUseCaseTest.kt$ClientFingerprintUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:ClientFingerprintUseCaseTest.kt$ClientFingerprintUseCaseTest.Arrangement$ </ID>
        <ID>NoConsecutiveBlankLines:CommonDokkaConfig.kt$ </ID>
        <ID>NoConsecutiveBlankLines:ConnectionMapperTest.kt$ </ID>
        <ID>NoConsecutiveBlankLines:ConnectionMapperTest.kt$ConnectionMapperTest$ </ID>
        <ID>NoConsecutiveBlankLines:ConversationDAOTest.kt$ConversationDAOTest$ </ID>
        <ID>NoConsecutiveBlankLines:ConversationEventReceiverTest.kt$ConversationEventReceiverTest$ </ID>
        <ID>NoConsecutiveBlankLines:ConversationGroupRepositoryArrangement.kt$ </ID>
        <ID>NoConsecutiveBlankLines:CurrentClientIdProviderArrangement.kt$ </ID>
        <ID>NoConsecutiveBlankLines:CustomServerConfigRepositoryTest.kt$CustomServerConfigRepositoryTest.Arrangement$ </ID>
        <ID>NoConsecutiveBlankLines:DatabaseImporterTest.kt$DatabaseImporterTest$ </ID>
        <ID>NoConsecutiveBlankLines:DomainLookupUseCaseTest.kt$DomainLookupUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:E2EIClientProviderArrangement.kt$E2EIClientProviderArrangementImpl$ </ID>
        <ID>NoConsecutiveBlankLines:EndCallUseCaseTest.kt$EndCallUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:EphemeralMessageDeletionHandlerTest.kt$EphemeralMessageDeletionHandlerTest$ </ID>
        <ID>NoConsecutiveBlankLines:FetchSSOSettingsUseCaseTest.kt$FetchSSOSettingsUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:FlowTest.kt$FlowTest$ </ID>
        <ID>NoConsecutiveBlankLines:GetOrRegisterClientUseCaseTest.kt$ </ID>
        <ID>NoConsecutiveBlankLines:GetPublicAssetUseCaseTest.kt$GetPublicAssetUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:GetUpdatedSelfTeamUseCaseTest.kt$GetUpdatedSelfTeamUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:GetUserInfoUseCaseTest.kt$ </ID>
        <ID>NoConsecutiveBlankLines:IgnoreJvm.kt$ </ID>
        <ID>NoConsecutiveBlankLines:IsE2EIEnabledUseCaseArrangement.kt$ </ID>
        <ID>NoConsecutiveBlankLines:JoinExistingMLSConversationsUseCaseTest.kt$JoinExistingMLSConversationsUseCaseTest.Arrangement$ </ID>
        <ID>NoConsecutiveBlankLines:KaliumBuild.kt$ </ID>
        <ID>NoConsecutiveBlankLines:KaliumPreferencesTest.kt$KaliumPreferencesTest$ </ID>
        <ID>NoConsecutiveBlankLines:LegalHoldSystemMessageHandlerTest.kt$LegalHoldSystemMessagesHandlerTest.Arrangement$ </ID>
        <ID>NoConsecutiveBlankLines:LoginRepositoryTest.kt$LoginRepositoryTest$ </ID>
        <ID>NoConsecutiveBlankLines:LogoutUseCaseTest.kt$ </ID>
        <ID>NoConsecutiveBlankLines:MLSConversationRepositoryArrangement.kt$MLSConversationRepositoryArrangement$ </ID>
        <ID>NoConsecutiveBlankLines:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest$ </ID>
        <ID>NoConsecutiveBlankLines:MLSConversationsVerificationStatusesHandlerTest.kt$MLSConversationsVerificationStatusesHandlerTest.Arrangement$ </ID>
        <ID>NoConsecutiveBlankLines:MLSMessageCreatorTest.kt$MLSMessageCreatorTest$ </ID>
        <ID>NoConsecutiveBlankLines:MLSMigrationConfigHandlerTest.kt$ </ID>
        <ID>NoConsecutiveBlankLines:MemberDAOArrangement.kt$ </ID>
        <ID>NoConsecutiveBlankLines:MemberDAOArrangement.kt$MemberDAOArrangementImpl$ </ID>
        <ID>NoConsecutiveBlankLines:MemberDAOTest.kt$MemberDAOTest$ </ID>
        <ID>NoConsecutiveBlankLines:MessageDAOBenchmarkTest.kt$MessageDAOBenchmarkTest$ </ID>
        <ID>NoConsecutiveBlankLines:MessageMetadataDAOTest.kt$MessageMetadataDAOTest$ </ID>
        <ID>NoConsecutiveBlankLines:MessageMetadataRepositoryTest.kt$MessageMetadataRepositoryTest$ </ID>
        <ID>NoConsecutiveBlankLines:NeedsToRegisterClientUseCaseTest.kt$NeedsToRegisterClientUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:NewConversationEventHandlerTest.kt$NewConversationEventHandlerTest.Arrangement$ </ID>
        <ID>NoConsecutiveBlankLines:ObserveAllServicesUseCaseTest.kt$ObserveAllServicesUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:ObserveSelfDeletingMessagesUseCaseTest.kt$ObserveSelfDeletingMessagesUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:OneOnOneResolverArrangement.kt$ </ID>
        <ID>NoConsecutiveBlankLines:PersistReactionUseCaseTest.kt$PersistReactionUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:ProteusPreKeyRefillerTest.kt$ProteusPreKeyRefillerTest$ </ID>
        <ID>NoConsecutiveBlankLines:RecipientDeliveryFailureMapperTest.kt$ </ID>
        <ID>NoConsecutiveBlankLines:RegisterMLSClientUseCaseTest.kt$RegisterMLSClientUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:RequestActivationCodeUseCaseTest.kt$RequestActivationCodeUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:RestartSlowSyncProcessForRecoveryUseCaseTest.kt$RestartSlowSyncProcessForRecoveryUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:RestoreBackupUseCaseTest.kt$RestoreBackupUseCaseTest.Arrangement$ </ID>
        <ID>NoConsecutiveBlankLines:RevokeGuestRoomLinkUseCaseTest.kt$RevokeGuestRoomLinkUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:ScheduleNewAssetMessageUseCaseTest.kt$ScheduleNewAssetMessageUseCaseTest.Arrangement$ </ID>
        <ID>NoConsecutiveBlankLines:SearchByHandleUseCaseTest.kt$SearchByHandleUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:SelfTeamIdProviderArrangement.kt$ </ID>
        <ID>NoConsecutiveBlankLines:SendKnockUserCaseTest.kt$SendKnockUserCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:SendKnockUserCaseTest.kt$SendKnockUserCaseTest.Arrangement$ </ID>
        <ID>NoConsecutiveBlankLines:SendLocationUseCaseTest.kt$SendLocationUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:SendLocationUseCaseTest.kt$SendLocationUseCaseTest.Arrangement$ </ID>
        <ID>NoConsecutiveBlankLines:ServiceRepositoryTest.kt$ServiceRepositoryTest$ </ID>
        <ID>NoConsecutiveBlankLines:SessionEstablisherTest.kt$SessionEstablisherTest.Arrangement$ </ID>
        <ID>NoConsecutiveBlankLines:SessionRepositoryArrangement.kt$ </ID>
        <ID>NoConsecutiveBlankLines:SetTestPreviewActiveUseCaseTest.kt$ </ID>
        <ID>NoConsecutiveBlankLines:SetTestRemoteVideoStatesUseCaseTest.kt$ </ID>
        <ID>NoConsecutiveBlankLines:SetTestVideoTypeUseCaseTest.kt$ </ID>
        <ID>NoConsecutiveBlankLines:SlowSyncWorkerTest.kt$SlowSyncWorkerTest$ </ID>
        <ID>NoConsecutiveBlankLines:StaleEpochVerifierTest.kt$StaleEpochVerifierTest$ </ID>
        <ID>NoConsecutiveBlankLines:SupportedApiVersionTest.kt$SupportedApiVersionTest$ </ID>
        <ID>NoConsecutiveBlankLines:SyncFeatureConfigsUseCaseTest.kt$SyncFeatureConfigsUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:SyncManagerArrangement.kt$SyncManagerArrangementImpl$ </ID>
        <ID>NoConsecutiveBlankLines:TeamRepositoryTest.kt$TeamRepositoryTest$ </ID>
        <ID>NoConsecutiveBlankLines:UpdateApiVersionUseCaseTest.kt$UpdateApiVersionUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:UpdateEmailUseCaseTest.kt$UpdateEmailUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:VerifyActivationCodeUseCaseTest.kt$ </ID>
        <ID>NoConsecutiveBlankLines:VerifyActivationCodeUseCaseTest.kt$VerifyActivationCodeUseCaseTest$ </ID>
        <ID>NoConsecutiveBlankLines:VerifyExistingClientUseCaseTest.kt$ </ID>
        <ID>NoMultipleSpaces:CheckRevocationListUseCaseTest.kt$CheckRevocationListUseCaseTest.Arrangement$ </ID>
        <ID>NoMultipleSpaces:CommonDokkaConfig.kt$ </ID>
        <ID>NoMultipleSpaces:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$ </ID>
        <ID>NoMultipleSpaces:GetOrCreateOneToOneConversationUseCaseTest.kt$GetOrCreateOneToOneConversationUseCaseTest$ </ID>
        <ID>NoMultipleSpaces:GlobalDBBaseTest.kt$GlobalDBBaseTest$ </ID>
        <ID>NoMultipleSpaces:HttpClientConnectionSpecsTest.kt$HttpClientConnectionSpecsTest$ </ID>
        <ID>NoMultipleSpaces:IgnoreIOS.kt$IgnoreIOS$ </ID>
        <ID>NoMultipleSpaces:LeaveSubconversationUseCaseTest.kt$LeaveSubconversationUseCaseTest$ </ID>
        <ID>NoMultipleSpaces:MessageMetadataRepositoryTest.kt$MessageMetadataRepositoryTest$ </ID>
        <ID>NoMultipleSpaces:ServerConfigTest.kt$ServerConfigTest$ </ID>
        <ID>NoMultipleSpaces:ValidatePasswordUseCaseTest.kt$ValidatePasswordUseCaseTest.Companion$ </ID>
        <ID>NoMultipleSpaces:readBinaryResource.kt$ </ID>
        <ID>NoSemicolons:ClientDAO.kt$ClientTypeEntity.LegalHold$;</ID>
        <ID>NoSemicolons:ClientDAO.kt$DeviceTypeEntity.Unknown$;</ID>
        <ID>NoSemicolons:ClientModel.kt$ClientCapability.LegalHoldImplicitConsent$;</ID>
        <ID>NoSemicolons:ClientModel.kt$ClientType.LegalHold$;</ID>
        <ID>NoSemicolons:ClientModel.kt$DeviceType.Unknown$;</ID>
        <ID>NoSemicolons:ClientRequest.kt$MLSPublicKeyTypeDTO.ED25519$;</ID>
        <ID>NoSemicolons:Conversation.kt$Conversation.Access.CODE$;</ID>
        <ID>NoSemicolons:Conversation.kt$Conversation.AccessRole.EXTERNAL$;</ID>
        <ID>NoSemicolons:FeatureConfigResponse.kt$FeatureFlagStatusDTO.DISABLED$;</ID>
        <ID>NoSemicolons:GetAssetSizeLimitUseCaseTest.kt$;</ID>
        <ID>NoSemicolons:IDs.kt$CryptoCertificateStatus.REVOKED$;</ID>
        <ID>NoSemicolons:LogoutReason.kt$LogoutReason.SESSION_EXPIRED$;</ID>
        <ID>NoSemicolons:MLSClient.kt$E2EIConversationState.NOT_ENABLED$;</ID>
        <ID>NoSemicolons:MessageEntity.kt$MessageEntity.MemberChangeType.REMOVED_FROM_TEAM$;</ID>
        <ID>NoSemicolons:NetworkErrorLabel.kt$AuthenticationCodeFailure.INVALID_OR_EXPIRED_AUTHENTICATION_CODE$;</ID>
        <ID>NoSemicolons:ProteusException.kt$ProteusException.Code.LOCAL_FILES_NOT_FOUND$;</ID>
        <ID>NoSemicolons:TeamPermission.kt$TeamPermission.SET_MEMBER_PERMISSIONS$;</ID>
        <ID>NoSemicolons:UserDAO.kt$UserTypeEntity.NONE$;</ID>
        <ID>NoSemicolons:UserType.kt$UserType.NONE$;</ID>
        <ID>NoTrailingSpaces:CallRepositoryTest.kt$CallRepositoryTest$ </ID>
        <ID>NoTrailingSpaces:ConversationRepositoryTest.kt$ConversationRepositoryTest$ </ID>
        <ID>NoTrailingSpaces:CustomServerConfigRepositoryTest.kt$CustomServerConfigRepositoryTest.Arrangement$ </ID>
        <ID>NoUnusedImports:ACMEActions.kt$action.ACMEActions.kt</ID>
        <ID>NoUnusedImports:AddServiceToConversationUseCaseTest.kt$com.wire.kalium.logic.feature.conversation.AddServiceToConversationUseCaseTest.kt</ID>
        <ID>NoUnusedImports:AppLockTeamFeatureConfigObserverTest.kt$com.wire.kalium.logic.feature.applock.AppLockTeamFeatureConfigObserverTest.kt</ID>
        <ID>NoUnusedImports:CheckCrlRevocationListUseCaseTest.kt$com.wire.kalium.logic.feature.e2ei.CheckCrlRevocationListUseCaseTest.kt</ID>
        <ID>NoUnusedImports:ClientRemoteRepositoryTest.kt$com.wire.kalium.logic.data.client.ClientRemoteRepositoryTest.kt</ID>
        <ID>NoUnusedImports:ClientRepositoryTest.kt$com.wire.kalium.logic.data.client.ClientRepositoryTest.kt</ID>
        <ID>NoUnusedImports:CommonUtilsTest.kt$com.wire.kalium.logic.util.CommonUtilsTest.kt</ID>
        <ID>NoUnusedImports:ConversationApiV0Test.kt$com.wire.kalium.api.v0.conversation.ConversationApiV0Test.kt</ID>
        <ID>NoUnusedImports:ConversationApiV5Test.kt$com.wire.kalium.api.v5.ConversationApiV5Test.kt</ID>
        <ID>NoUnusedImports:ConversationDetailsResponse.kt$com.wire.kalium.model.conversation.ConversationDetailsResponse.kt</ID>
        <ID>NoUnusedImports:DomainLookupUseCaseTest.kt$com.wire.kalium.logic.feature.auth.DomainLookupUseCaseTest.kt</ID>
        <ID>NoUnusedImports:E2EIClientProviderTest.kt$com.wire.kalium.logic.client.E2EIClientProviderTest.kt</ID>
        <ID>NoUnusedImports:EncryptedSettingsBuilderTest.kt$com.wire.kalium.persistence.kmmSettings.EncryptedSettingsBuilderTest.kt</ID>
        <ID>NoUnusedImports:EnvelopeProtoMapperTest.kt$com.wire.kalium.api.v0.message.EnvelopeProtoMapperTest.kt</ID>
        <ID>NoUnusedImports:FeatureConfigJson.kt$com.wire.kalium.model.FeatureConfigJson.kt</ID>
        <ID>NoUnusedImports:FeatureConfigMapperTest.kt$com.wire.kalium.logic.data.event.FeatureConfigMapperTest.kt</ID>
        <ID>NoUnusedImports:GetOtherUserClientsUseCaseTest.kt$com.wire.kalium.logic.feature.client.GetOtherUserClientsUseCaseTest.kt</ID>
        <ID>NoUnusedImports:GetUserE2eiAllCertificateStatusesUseCaseTest.kt$com.wire.kalium.logic.feature.e2ei.GetUserE2eiAllCertificateStatusesUseCaseTest.kt</ID>
        <ID>NoUnusedImports:MLSConversationRepositoryTest.kt$com.wire.kalium.logic.data.conversation.MLSConversationRepositoryTest.kt</ID>
        <ID>NoUnusedImports:MarkMessagesAsNotifiedUseCaseTest.kt$com.wire.kalium.logic.feature.message.MarkMessagesAsNotifiedUseCaseTest.kt</ID>
        <ID>NoUnusedImports:MessageRepositoryTest.kt$com.wire.kalium.logic.data.message.MessageRepositoryTest.kt</ID>
        <ID>NoUnusedImports:NewClientDAOTest.kt$com.wire.kalium.persistence.dao.newclient.NewClientDAOTest.kt</ID>
        <ID>NoUnusedImports:ObserveGuestRoomLinkUseCaseTest.kt$com.wire.kalium.logic.feature.conversation.guestroomlink.ObserveGuestRoomLinkUseCaseTest.kt</ID>
        <ID>NoUnusedImports:ObserveIsServiceMemberUseCaseTest.kt$com.wire.kalium.logic.feature.service.ObserveIsServiceMemberUseCaseTest.kt</ID>
        <ID>NoUnusedImports:ObserveScreenshotCensoringConfigUseCaseTest.kt$com.wire.kalium.logic.feature.user.screeenshotCensoring.ObserveScreenshotCensoringConfigUseCaseTest.kt</ID>
        <ID>NoUnusedImports:QualifiedSendMessageRequestJson.kt$com.wire.kalium.model.QualifiedSendMessageRequestJson.kt</ID>
        <ID>NoUnusedImports:ReceiptsMapperTest.kt$com.wire.kalium.logic.data.message.receipt.ReceiptsMapperTest.kt</ID>
        <ID>NoUnusedImports:RegisterClientUseCaseTest.kt$com.wire.kalium.logic.feature.client.RegisterClientUseCaseTest.kt</ID>
        <ID>NoUnusedImports:RequestSecondFactorVerificationCodeUseCaseTest.kt$com.wire.kalium.logic.feature.auth.verification.RequestSecondFactorVerificationCodeUseCaseTest.kt</ID>
        <ID>NoUnusedImports:RestoreBackupUseCaseTest.kt$com.wire.kalium.logic.feature.backup.RestoreBackupUseCaseTest.kt</ID>
        <ID>NoUnusedImports:SendButtonMessageCaseTest.kt$com.wire.kalium.logic.feature.message.composite.SendButtonMessageCaseTest.kt</ID>
        <ID>NoUnusedImports:SendKnockUserCaseTest.kt$com.wire.kalium.logic.feature.message.SendKnockUserCaseTest.kt</ID>
        <ID>NoUnusedImports:ServerConfigDTOJson.kt$util.ServerConfigDTOJson.kt</ID>
        <ID>NoUnusedImports:SlowSyncRepositoryTest.kt$com.wire.kalium.logic.data.sync.SlowSyncRepositoryTest.kt</ID>
        <ID>NoUnusedImports:StaleEpochVerifierTest.kt$com.wire.kalium.logic.feature.message.StaleEpochVerifierTest.kt</ID>
        <ID>NoUnusedImports:SyncMigrationStepsProviderArrangement.kt$com.wire.kalium.logic.util.arrangement.provider.SyncMigrationStepsProviderArrangement.kt</ID>
        <ID>NoUnusedImports:SyncSelfTeamUseCaseTest.kt$com.wire.kalium.logic.feature.team.SyncSelfTeamUseCaseTest.kt</ID>
        <ID>NoUnusedImports:TestNetworkStateObserver.kt$.TestNetworkStateObserver.kt</ID>
        <ID>NoUnusedImports:UpdateClientVerificationStatusUseCaseTest.kt$com.wire.kalium.logic.feature.client.UpdateClientVerificationStatusUseCaseTest.kt</ID>
        <ID>NoUnusedImports:UpdateConversationArchivedStatusUseCaseTest.kt$com.wire.kalium.logic.feature.conversation.UpdateConversationArchivedStatusUseCaseTest.kt</ID>
        <ID>NoUnusedImports:UserConfigRepositoryArrangement.kt$com.wire.kalium.logic.util.arrangement.repository.UserConfigRepositoryArrangement.kt</ID>
        <ID>NoUnusedImports:UserConfigStorageTest.kt$com.wire.kalium.persistence.config.UserConfigStorageTest.kt</ID>
        <ID>NoUnusedImports:UserDetailsApiV4Test.kt$com.wire.kalium.api.v4.UserDetailsApiV4Test.kt</ID>
        <ID>NoUnusedImports:ValidateSSOCodeUseCaseTest.kt$com.wire.kalium.logic.feature.auth.sso.ValidateSSOCodeUseCaseTest.kt</ID>
        <ID>NoWildcardImports:ACMEApiTest.kt$import com.wire.kalium.network.api.base.unbound.acme.*</ID>
        <ID>NoWildcardImports:ACMEApiTest.kt$import io.ktor.http.*</ID>
        <ID>NoWildcardImports:ACMEApiTest.kt$import kotlin.test.*</ID>
        <ID>NoWildcardImports:ConversionDAOArrangement.kt$import io.mockative.*</ID>
        <ID>NoWildcardImports:UpdateAssetMessageTransferStatusUseCaseTest.kt$import io.mockative.*</ID>
        <ID>ObjectPropertyNaming:Decoder.module_@wireapp_cbor.kt$Decoder.Companion$var _check_overflow: Any</ID>
        <ID>PackageName:TestKaliumDispatcher.kt$package com.wire.kalium.logic.test_util</ID>
        <ID>PackageName:TestNetworkException.kt$package com.wire.kalium.logic.test_util</ID>
        <ID>PackageName:TimeUtils.kt$package com.wire.kalium.logic.test_util</ID>
        <ID>ParameterListWrapping:ACMEApi.kt$ACMEApi$(url: String, body: ByteArray? = null)</ID>
        <ID>ParameterListWrapping:AccessTokenApiV0.kt$AccessTokenApiV0$(refreshToken: String, clientId: String?)</ID>
        <ID>ParameterListWrapping:AccessTokenApiV3.kt$AccessTokenApiV3$(refreshToken: String, clientId: String?)</ID>
        <ID>ParameterListWrapping:AccountsDAO.kt$AccountsDAO$(userIDEntity: UserIDEntity, ssoIdEntity: SsoIdEntity?, managedBy: ManagedByEntity?)</ID>
        <ID>ParameterListWrapping:AddMemberToConversationUseCase.kt$AddMemberToConversationUseCaseImpl$(conversationId: ConversationId, userIdList: List&lt;UserId>)</ID>
        <ID>ParameterListWrapping:ApiTest.kt$ApiTest$(expectedHost: String)</ID>
        <ID>ParameterListWrapping:ApiTest.kt$ApiTest$(name: String, hasValue: String)</ID>
        <ID>ParameterListWrapping:ApiTest.kt$ApiTest$(pathAndQuery: String)</ID>
        <ID>ParameterListWrapping:AssetApi.kt$AssetApi$(assetId: String, assetDomain: String?, assetToken: String?, tempFileSink: Sink)</ID>
        <ID>ParameterListWrapping:AssetApiV0.kt$AssetApiV0$(assetId: String, assetDomain: String?)</ID>
        <ID>ParameterListWrapping:AssetMapper.kt$AssetMapper$(uploadAssetMetadata: UploadAssetData, kaliumFileSystem: KaliumFileSystem)</ID>
        <ID>ParameterListWrapping:AssetMapper.kt$AssetMapperImpl$(uploadAssetMetadata: UploadAssetData, kaliumFileSystem: KaliumFileSystem)</ID>
        <ID>ParameterListWrapping:BaseDatabaseTest.kt$BaseDatabaseTest$( userId: UserIDEntity, passphrase: UserDBSecret?, enableWAL: Boolean)</ID>
        <ID>ParameterListWrapping:ClientApiV2.kt$ClientApiV2$(userIds: List&lt;UserId>)</ID>
        <ID>ParameterListWrapping:ClientDAO.kt$ClientDAO$(redundantClientsOfUsers: Map&lt;UserIDEntity, List&lt;String>>)</ID>
        <ID>ParameterListWrapping:ClientRegistrationStorageImpl.kt$ClientRegistrationStorageImpl$(retainedClientId: String)</ID>
        <ID>ParameterListWrapping:ClientRepository.kt$ClientDataSource$(token: String)</ID>
        <ID>ParameterListWrapping:ClientRepository.kt$ClientRepository$(clients: List&lt;InsertClientParam>)</ID>
        <ID>ParameterListWrapping:ClientRepository.kt$ClientRepository$(conversationId: ConversationId)</ID>
        <ID>ParameterListWrapping:ClientRepository.kt$ClientRepository$(userId: UserId, clientId: ClientId)</ID>
        <ID>ParameterListWrapping:CommitBundleEventReceiver.kt$CommitBundleEventReceiverImpl$(event: Event.Conversation, deliveryInfo: EventDeliveryInfo)</ID>
        <ID>ParameterListWrapping:CompositeMessageDAO.kt$CompositeMessageDAOImpl$(messageId: String, conversationId: QualifiedIDEntity, buttonId: String)</ID>
        <ID>ParameterListWrapping:ConnectionRepository.kt$ConnectionRepository$(userId: UserId, connectionState: ConnectionState)</ID>
        <ID>ParameterListWrapping:ConversationDAO.kt$ConversationDAO$(conversationID: QualifiedIDEntity, receiptMode: ConversationEntity.ReceiptMode)</ID>
        <ID>ParameterListWrapping:ConversationDAO.kt$ConversationDAO$(conversationId: QualifiedIDEntity, legalHoldStatus: ConversationEntity.LegalHoldStatus)</ID>
        <ID>ParameterListWrapping:ConversationDAO.kt$ConversationDAO$(conversationId: QualifiedIDEntity, protocol: ConversationEntity.Protocol)</ID>
        <ID>ParameterListWrapping:ConversationDAO.kt$ConversationDAO$(verificationStatus: ConversationEntity.VerificationStatus, conversationId: QualifiedIDEntity)</ID>
        <ID>ParameterListWrapping:ConversationEventReceiver.kt$ConversationEventReceiverImpl$(event: Event.Conversation, deliveryInfo: EventDeliveryInfo)</ID>
        <ID>ParameterListWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest.Arrangement$(result: Array&lt;NetworkResponse&lt;ConversationResponse>>)</ID>
        <ID>ParameterListWrapping:ConversationMapper.kt$ConversationMapper$(apiModel: ConversationResponse, mlsGroupState: GroupState?, selfUserTeamId: TeamId?)</ID>
        <ID>ParameterListWrapping:ConversationMapper.kt$ConversationMapper$(name: String?, members: List&lt;UserId>, teamId: String?, options: ConversationOptions)</ID>
        <ID>ParameterListWrapping:ConversationMapper.kt$ConversationMapper$(verificationStatus: Conversation.VerificationStatus)</ID>
        <ID>ParameterListWrapping:ConversationMapper.kt$ConversationMapper$(verificationStatus: ConversationEntity.VerificationStatus)</ID>
        <ID>ParameterListWrapping:ConversationMapper.kt$ConversationMapperImpl$(conversationId: NetworkQualifiedId)</ID>
        <ID>ParameterListWrapping:ConversationRepository.kt$ConversationDataSource$(conversationID: ConversationId)</ID>
        <ID>ParameterListWrapping:ConversationRepository.kt$ConversationDataSource$(conversationId: ConversationId)</ID>
        <ID>ParameterListWrapping:ConversationRepository.kt$ConversationDataSource$(qualifiedID: QualifiedID, date: Instant)</ID>
        <ID>ParameterListWrapping:ConversationRepository.kt$ConversationRepository$(conversationID: ConversationId)</ID>
        <ID>ParameterListWrapping:ConversationRepository.kt$ConversationRepository$(conversationId: ConversationId)</ID>
        <ID>ParameterListWrapping:ConversationRepository.kt$ConversationRepository$(conversationId: ConversationId, protocol: Conversation.Protocol)</ID>
        <ID>ParameterListWrapping:ConversationRepository.kt$ConversationRepository$(conversationId: ConversationId, selfDeletionTimer: SelfDeletionTimer)</ID>
        <ID>ParameterListWrapping:ConversationRepository.kt$ConversationRepository$(conversationId: ConversationId, userIDList: List&lt;UserId>)</ID>
        <ID>ParameterListWrapping:ConversationRepository.kt$ConversationRepository$(teamId: TeamId)</ID>
        <ID>ParameterListWrapping:ConversationRepositoryArrangement.kt$ConversationRepositoryArrangement$(isInformed: Either&lt;StorageFailure, Boolean>)</ID>
        <ID>ParameterListWrapping:ConversationRepositoryArrangement.kt$ConversationRepositoryArrangement$(result: Either&lt;StorageFailure, Conversation.ProtocolInfo>)</ID>
        <ID>ParameterListWrapping:ConversationRepositoryArrangement.kt$ConversationRepositoryArrangement$(result: Either&lt;StorageFailure, ConversationDetails>)</ID>
        <ID>ParameterListWrapping:ConversationResources.kt$ConversationResources$(@PathParam("id") id: String, @Valid request: SendButtonActionConfirmationRequest)</ID>
        <ID>ParameterListWrapping:ConversationStatusMapper.kt$ConversationStatusMapperImpl$(mutedStatus: MutedConversationStatus, mutedStatusTimestamp: Long)</ID>
        <ID>ParameterListWrapping:CreateBackupUseCase.kt$CreateBackupResult.Success$(val backupFilePath: Path, val backupFileSize: Long, val backupFileName: String)</ID>
        <ID>ParameterListWrapping:CustomServerConfigRepository.kt$CustomServerConfigRepository$(date: String)</ID>
        <ID>ParameterListWrapping:CustomServerConfigRepository.kt$CustomServerConfigRepository$(links: ServerConfig.Links, metadata: ServerConfig.MetaData)</ID>
        <ID>ParameterListWrapping:DeleteMessageUseCase.kt$DeleteMessageUseCase$(conversationId: ConversationId, messageId: String, deleteForEveryone: Boolean)</ID>
        <ID>ParameterListWrapping:E2EIApiV0.kt$E2EIApiV0$(clientId: String)</ID>
        <ID>ParameterListWrapping:E2EIClientTest.kt$E2EIClientTest.SampleUser$( val id: CryptoQualifiedID, val clientId: CryptoClientId, val name: String, val handle: String, val teamId: String? = "" )</ID>
        <ID>ParameterListWrapping:E2EIRepository.kt$E2EIRepository$(certificateChain: String, isNewClient: Boolean = false)</ID>
        <ID>ParameterListWrapping:E2EIRepository.kt$E2EIRepository$(prevNonce: Nonce, createOrderEndpoint: String)</ID>
        <ID>ParameterListWrapping:E2eiCertificate.kt$E2eiCertificate.Companion$(identity: WireIdentity, certificateStatusMapper: CertificateStatusMapper)</ID>
        <ID>ParameterListWrapping:Either.kt$(initialValue: R, fn: (item: T, accumulated: R) -> Either&lt;L, R>)</ID>
        <ID>ParameterListWrapping:Either.kt$(item: T, accumulated: R)</ID>
        <ID>ParameterListWrapping:EnrollE2EIUseCase.kt$EnrollE2EIUseCase$(isNewClientRegistration: Boolean = false)</ID>
        <ID>ParameterListWrapping:EnrollE2EIUseCase.kt$EnrollE2EIUseCaseImpl$(isNewClientRegistration: Boolean)</ID>
        <ID>ParameterListWrapping:EphemeralEventsNotificationManagerImpl.kt$EphemeralEventsNotificationManager$(ephemeralConversationNotification: EphemeralConversationNotification)</ID>
        <ID>ParameterListWrapping:FakeSecondFactorVerificationRepository.kt$FakeSecondFactorVerificationRepository$(email: String, verifiableAction: VerifiableAction)</ID>
        <ID>ParameterListWrapping:FederationEventReceiverTest.kt$FederationEventReceiverTest$(conversationId: ConversationId, otherUserId: UserId)</ID>
        <ID>ParameterListWrapping:GetMembersE2EICertificateStatusesUseCase.kt$GetMembersE2EICertificateStatusesUseCaseImpl$(conversationId: ConversationId, userIds: List&lt;UserId>)</ID>
        <ID>ParameterListWrapping:GetServerConfigUseCase.kt$GetServerConfigUseCase$(url: String)</ID>
        <ID>ParameterListWrapping:ImportClientUseCase.kt$ImportClientUseCase$(clientId: ClientId, registerClientParam: RegisterClientUseCase.RegisterClientParam)</ID>
        <ID>ParameterListWrapping:IsEligibleToStartCallUseCase.kt$IsEligibleToStartCallUseCase$(conversationId: ConversationId, conversationType: Conversation.Type)</ID>
        <ID>ParameterListWrapping:JoinSubconversationUseCase.kt$JoinSubconversationUseCase$(conversationId: ConversationId, subconversationId: SubconversationId)</ID>
        <ID>ParameterListWrapping:KaliumFileSystemImpl.kt$KaliumFileSystemImpl$(assetName: String)</ID>
        <ID>ParameterListWrapping:LeaveConversationEventAction.kt$LeaveConversationEventAction$(monkeyPool: MonkeyPool, conversationPool: ConversationPool)</ID>
        <ID>ParameterListWrapping:LeaveSubconversationUseCase.kt$LeaveSubconversationUseCase$(conversationId: ConversationId, subconversationId: SubconversationId)</ID>
        <ID>ParameterListWrapping:LeaveSubconversationUseCase.kt$LeaveSubconversationUseCaseImpl$(conversationId: ConversationId, subconversationId: SubconversationId)</ID>
        <ID>ParameterListWrapping:LegalHoldHandler.kt$LegalHoldHandler$(message: MessageUnpackResult.ApplicationMessage, isLive: Boolean)</ID>
        <ID>ParameterListWrapping:LegalHoldHandlerTest.kt$LegalHoldHandlerTest.Companion$(legalHoldStatus: Conversation.LegalHoldStatus)</ID>
        <ID>ParameterListWrapping:LocalNotificationMessageMapper.kt$LocalNotificationMessageMapper$(message: Message, messageContent: MessageContent.TextEdited)</ID>
        <ID>ParameterListWrapping:MLSConversationRepository.kt$MLSConversationRepository$(groupID: GroupID, clientIdList: List&lt;QualifiedClientID>)</ID>
        <ID>ParameterListWrapping:MLSConversationsVerificationStatusesHandler.kt$MLSConversationsVerificationStatusesHandlerImpl$(newStatusFromCC: VerificationStatus, currentStatus: VerificationStatus)</ID>
        <ID>ParameterListWrapping:MLSMessageUnpacker.kt$MLSMessageUnpacker$(bundle: DecryptedMessageBundle, conversationId: ConversationId, timestamp: Instant)</ID>
        <ID>ParameterListWrapping:MLSMessageUnpacker.kt$MLSMessageUnpacker$(event: Event.Conversation.NewMLSMessage)</ID>
        <ID>ParameterListWrapping:MemberDAO.kt$MemberDAO$(conversationId: QualifiedIDEntity, userId: UserIDEntity, role: MemberEntity.Role)</ID>
        <ID>ParameterListWrapping:MembersToMentionUseCase.kt$MembersToMentionUseCase$(conversationId: ConversationId, searchQuery: String)</ID>
        <ID>ParameterListWrapping:MessageDAO.kt$MessageDAO$(conversationId: QualifiedIDEntity, messageId: String, newMembers: List&lt;QualifiedIDEntity>)</ID>
        <ID>ParameterListWrapping:MessageDAO.kt$MessageDAO$(messageId: String, conversationId: QualifiedIDEntity)</ID>
        <ID>ParameterListWrapping:MessageDAO.kt$MessageDAO$(transferStatus: AssetTransferStatusEntity, id: String, conversationId: QualifiedIDEntity)</ID>
        <ID>ParameterListWrapping:MessageDraftRepository.kt$MessageDraftRepository$(conversationId: ConversationId, messageDraft: MessageDraft)</ID>
        <ID>ParameterListWrapping:MessageEntity.kt$MessageEntityContent.LegalHold$(val memberUserIdList: List&lt;QualifiedIDEntity>, val type: MessageEntity.LegalHoldType)</ID>
        <ID>ParameterListWrapping:MessageMapper.kt$MessageMapperImpl$(regularMessage: MessageContent.Regular)</ID>
        <ID>ParameterListWrapping:MessageMetadataRepository.kt$MessageMetadataSource$(conversationId: ConversationId, messageId: MessageId)</ID>
        <ID>ParameterListWrapping:MessageSender.kt$MessageSenderImpl$(envelope: MessageEnvelope, message: Message, messageSent: MessageSent)</ID>
        <ID>ParameterListWrapping:NewGroupConversationSystemMessagesCreator.kt$NewGroupConversationSystemMessagesCreator$(conversationId: ConversationIDEntity, validUsers: List&lt;UserId>)</ID>
        <ID>ParameterListWrapping:NotificationApiV0.kt$NotificationApiV0$(querySize: Int, queryClient: String)</ID>
        <ID>ParameterListWrapping:ObserveConversationInteractionAvailabilityUseCase.kt$ObserveConversationInteractionAvailabilityUseCase$(conversationId: ConversationId)</ID>
        <ID>ParameterListWrapping:ObserveMessageReactionsUseCaseTest.kt$ObserveMessageReactionsUseCaseTest.&lt;no name provided>$(conversationId: ConversationId, messageId: String)</ID>
        <ID>ParameterListWrapping:ObserveSelfDeletionTimerSettingsForConversationUseCase.kt$ObserveSelfDeletionTimerSettingsForConversationUseCase$(conversationId: ConversationId, considerSelfUserSettings: Boolean)</ID>
        <ID>ParameterListWrapping:ObserveUsersTypingUseCase.kt$ObserveUsersTypingUseCaseImpl$(conversationId: ConversationId)</ID>
        <ID>ParameterListWrapping:OnMissedCall.kt$OnMissedCall$(conversationId: String, messageTime: Uint32_t, userId: String, isVideoCall: Boolean, arg: Pointer?)</ID>
        <ID>ParameterListWrapping:OnParticipantsVideoStateChanged.kt$OnParticipantsVideoStateChanged$(conversationId: String, userId: String, clientId: String, state: Int, arg: Pointer?)</ID>
        <ID>ParameterListWrapping:PersistMigratedMessagesUseCase.kt$PersistMigratedMessagesUseCaseImpl$(messages: List&lt;MigratedMessage>, coroutineScope: CoroutineScope)</ID>
        <ID>ParameterListWrapping:PersistNewSelfDeletionTimerUseCase.kt$PersistNewSelfDeletionTimerUseCaseImpl$(conversationId: ConversationId, newSelfDeletionTimer: SelfDeletionTimer)</ID>
        <ID>ParameterListWrapping:PlatformUserStorageProvider.kt$PlatformUserStorageProvider$(userId: UserId, shouldEncryptData: Boolean, platformProperties: PlatformUserStorageProperties)</ID>
        <ID>ParameterListWrapping:ProteusClientCryptoBoxImpl.kt$ProteusClientCryptoBoxImpl.Companion$(localIdentityKey: IdentityKey, preKey: com.wire.kalium.cryptography.externals.PreKey)</ID>
        <ID>ParameterListWrapping:RemoteMonkey.kt$RemoteMonkey$(monkeyConfig: MonkeyConfig.Remote, monkeyType: MonkeyType, internalId: MonkeyId)</ID>
        <ID>ParameterListWrapping:RemoveMemberFromConversationUseCase.kt$RemoveMemberFromConversationUseCaseImpl$(conversationId: ConversationId, userIdToRemove: UserId)</ID>
        <ID>ParameterListWrapping:RestoreWebBackupUseCase.kt$RestoreWebBackupUseCaseImpl$(filePath: Path, coroutineScope: CoroutineScope)</ID>
        <ID>ParameterListWrapping:SaveMessageDraftUseCase.kt$SaveMessageDraftUseCaseImpl$(conversationId: ConversationId, messageDraft: MessageDraft)</ID>
        <ID>ParameterListWrapping:SearchDAO.kt$SearchDAO$(conversationId: ConversationIDEntity, query: String)</ID>
        <ID>ParameterListWrapping:SendKnockUseCase.kt$SendKnockUseCase$(conversationId: ConversationId, hotKnock: Boolean)</ID>
        <ID>ParameterListWrapping:ServerConfigRepository.kt$ServerConfigRepository$(links: ServerConfig.Links, metadata: ServerConfig.MetaData)</ID>
        <ID>ParameterListWrapping:SessionRepository.kt$SessionRepository$(userId: UserId, isPersistentWebSocketEnabled: Boolean)</ID>
        <ID>ParameterListWrapping:SessionRepository.kt$SessionRepository$(userId: UserId, ssoId: SsoId?, managedBy: ManagedByDTO?)</ID>
        <ID>ParameterListWrapping:SessionResetSender.kt$SessionResetSender$(conversationId: ConversationId, userId: UserId, clientId: ClientId)</ID>
        <ID>ParameterListWrapping:StoreServerConfigUseCase.kt$StoreServerConfigUseCase$(links: ServerConfig.Links, versionInfo: ServerConfig.VersionInfo)</ID>
        <ID>ParameterListWrapping:TeamsApi.kt$TeamsApi$(teamId: TeamId, limitTo: Int?, pagingState: String? = null)</ID>
        <ID>ParameterListWrapping:TeamsApi.kt$TeamsApi$(teamId: TeamId, size: Int = DEFAULT_SERVICES_SIZE)</ID>
        <ID>ParameterListWrapping:TeamsApi.kt$TeamsApi$(teamId: TeamId, teamMemberIdList: TeamMemberIdList)</ID>
        <ID>ParameterListWrapping:TeamsApi.kt$TeamsApi$(teamId: TeamId, userId: NonQualifiedUserId)</ID>
        <ID>ParameterListWrapping:TeamsApi.kt$TeamsApi$(teamId: TeamId, userId: NonQualifiedUserId, password: String?)</ID>
        <ID>ParameterListWrapping:UpdateApiVersionsUseCase.kt$UpdateApiVersionsUseCaseImpl$(serverConfig: ServerConfig, proxyCredentials: ProxyCredentials?)</ID>
        <ID>ParameterListWrapping:UpdateConversationProtocolResponse.kt$UpdateConversationProtocolResponse.ProtocolUpdated$(val event: EventContentDTO.Conversation.ProtocolUpdate)</ID>
        <ID>ParameterListWrapping:UpdateConversationReceiptModeResponse.kt$UpdateConversationReceiptModeResponse.ReceiptModeUpdated$(val event: EventContentDTO.Conversation.ReceiptModeUpdate)</ID>
        <ID>ParameterListWrapping:UserDAO.kt$UserDAO$(connectionState: ConnectionEntity.State)</ID>
        <ID>ParameterListWrapping:UserDAO.kt$UserDAO$(qualifiedID: QualifiedIDEntity)</ID>
        <ID>ParameterListWrapping:UserDatabaseDataGenerator.kt$UserDatabaseDataGenerator$(conversationAmount: Int)</ID>
        <ID>ParameterListWrapping:UserRepository.kt$UserDataSource$(newName: String?, newAccent: Int?, newAssetId: String?)</ID>
        <ID>ParameterListWrapping:UserRepository.kt$UserRepository$(conversationId: ConversationId)</ID>
        <ID>ParameterListWrapping:UserRepository.kt$UserRepository$(newName: String? = null, newAccent: Int? = null, newAssetId: String? = null)</ID>
        <ID>ParameterListWrapping:UserRepository.kt$UserRepository$(userId: UserId)</ID>
        <ID>ParameterListWrapping:ValidateUserHandleUseCase.kt$ValidateUserHandleResult.Invalid$(handleWithoutInvalidCharacters: String)</ID>
        <ID>ParameterWrapping:ConversationResponse.kt$ConversationMemberDTO.Self$@SerialName("otr_muted_status") @Serializable(with = MutedStatusSerializer::class) val otrMutedStatus: MutedStatus? = null</ID>
        <ID>ParameterWrapping:EventContentDTO.kt$EventContentDTO.Conversation.MemberJoinDTO$@Deprecated("use qualifiedFrom", replaceWith = ReplaceWith("this.qualifiedFrom")) @SerialName("from") val from: String</ID>
        <ID>ParameterWrapping:MemberUpdateDTO.kt$MemberUpdateDTO$@SerialName("otr_muted_status") @Serializable(with = MutedStatusSerializer::class) val otrMutedStatus: MutedStatus? = null</ID>
        <ID>ParameterWrapping:SlowSyncManager.kt$SlowSyncManager$private val exponentialDurationHelper: ExponentialDurationHelper = ExponentialDurationHelperImpl(MIN_RETRY_DELAY, MAX_RETRY_DELAY)</ID>
        <ID>ParameterWrapping:UpdateApiVersionsUseCase.kt$UpdateApiVersionsUseCaseImpl$private val serverConfigRepoProvider: (serverConfig: ServerConfig, proxyCredentials: ProxyCredentials?) -> ServerConfigRepository</ID>
        <ID>PropertyWrapping:AccessTokenRefresherTest.kt$AccessTokenRefresherTest$val expected = AccountTokens(userId = TestUser.USER_ID, TEST_REFRESH_RESULT.accessToken, TEST_REFRESH_RESULT.refreshToken, null)</ID>
        <ID>PropertyWrapping:AssetRepository.kt$AssetDataSource$val uploadAssetData = UploadAssetData(tempEncryptedDataPath, encryptedDataSize, mimeType, false, RetentionType.PERSISTENT)</ID>
        <ID>PropertyWrapping:BackupCoder.kt$BackupCoder$val expectedHashedUserId = hashUserId(userId, decodedHeader.salt, decodedHeader.opslimit, decodedHeader.memlimit)</ID>
        <ID>PropertyWrapping:ClearUsersTypingEventsUseCaseTest.kt$ClearUsersTypingEventsUseCaseTest.Arrangement$@Mock val typingIndicatorIncomingRepository: TypingIndicatorIncomingRepository = mock(TypingIndicatorIncomingRepository::class)</ID>
        <ID>PropertyWrapping:CommitBundleEventReceiver.kt$CommitBundleEventReceiverImpl$val exception = IllegalArgumentException("Unexpected event received by commit bundle: ${event.toLogString()}")</ID>
        <ID>PropertyWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$val expectedInitialUsers = listOf(TestConversation.USER_1, TestUser.OTHER_FEDERATED_USER_ID_2, TestUser.OTHER_FEDERATED_USER_ID)</ID>
        <ID>PropertyWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$val expectedInitialUsers = listOf(TestConversation.USER_1.copy(domain = failedDomain), TestUser.OTHER_FEDERATED_USER_ID)</ID>
        <ID>PropertyWrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest.Arrangement$@Mock val joinExistingMLSConversation: JoinExistingMLSConversationUseCase = mock(JoinExistingMLSConversationUseCase::class)</ID>
        <ID>PropertyWrapping:ConversationMessageTimerEventHandlerTest.kt$ConversationMessageTimerEventHandlerTest.Arrangement$private val conversationMessageTimerEventHandler: ConversationMessageTimerEventHandler = ConversationMessageTimerEventHandlerImpl( conversationDAO, persistMessageUseCase )</ID>
        <ID>PropertyWrapping:CreateGroupConversationUseCaseTest.kt$CreateGroupConversationUseCaseTest$val conversationOptions = ConversationOptions(protocol = ConversationOptions.Protocol.MLS, creatorClientId = creatorClientId)</ID>
        <ID>PropertyWrapping:DeleteClientUseCaseTest.kt$DeleteClientUseCaseTest.Arrangement$@Mock val updateSupportedProtocolsAndResolveOneOnOnes = mock(classOf&lt;UpdateSupportedProtocolsAndResolveOneOnOnesUseCase>())</ID>
        <ID>PropertyWrapping:EphemeralMessageDeletionHandlerTest.kt$EphemeralMessageDeletionHandlerTest.Arrangement$@Mock val deleteEphemeralMessageForSelfUserAsSender = mock(classOf&lt;DeleteEphemeralMessageForSelfUserAsSenderUseCase>())</ID>
        <ID>PropertyWrapping:EventRepositoryTest.kt$EventRepositoryTest.Arrangement$private val eventRepository: EventRepository = EventDataSource(notificationApi, metaDAO, clientIdProvider, TestUser.SELF.id)</ID>
        <ID>PropertyWrapping:FeatureConfigEventReceiverTest.kt$FeatureConfigEventReceiverTest.Arrangement$@Mock val updateSupportedProtocolsAndResolveOneOnOnes = mock(classOf&lt;UpdateSupportedProtocolsAndResolveOneOnOnesUseCase>())</ID>
        <ID>PropertyWrapping:FederationEventReceiverTest.kt$FederationEventReceiverTest$val defederatedUserIdList = List(defederatedUsersCount) { UserId(value = "defId$it", domain = defederatedDomain) }</ID>
        <ID>PropertyWrapping:FederationEventReceiverTest.kt$FederationEventReceiverTest$val defederatedUserIdListTwo = List(defederatedUsersCountTwo) { UserId(value = "defIdTwo$it", domain = defederatedDomainTwo) }</ID>
        <ID>PropertyWrapping:IncrementalSyncManagerTest.kt$IncrementalSyncManagerTest.Arrangement$@Mock val incrementalSyncRepository = configure(mock(classOf&lt;IncrementalSyncRepository>())) { stubsUnitByDefault = true }</ID>
        <ID>PropertyWrapping:LegalHoldHandler.kt$LegalHoldHandlerImpl$val isStatusChangedForConversation = handleForConversation(conversationId, newStatus, systemMessageTimestampIso)</ID>
        <ID>PropertyWrapping:LegalHoldHandlerTest.kt$LegalHoldHandlerTest.Arrangement$@Mock val legalHoldSystemMessagesHandler = configure(mock(LegalHoldSystemMessagesHandler::class)) { stubsUnitByDefault = true }</ID>
        <ID>PropertyWrapping:LegalHoldSystemMessageHandlerTest.kt$LegalHoldSystemMessagesHandlerTest$val legalHoldMessage = testLegalHoldSystemMessage(MessageContent.LegalHold.ForMembers.Disabled(listOf(TestUser.OTHER_USER_ID_2)))</ID>
        <ID>PropertyWrapping:LegalHoldSystemMessageHandlerTest.kt$LegalHoldSystemMessagesHandlerTest$val legalHoldMessage = testLegalHoldSystemMessage(MessageContent.LegalHold.ForMembers.Enabled(listOf(TestUser.OTHER_USER_ID_2)))</ID>
        <ID>PropertyWrapping:LoginUseCaseTest.kt$LoginUseCaseTest$val loginUserCaseResult = loginUseCase(TEST_EMAIL, TEST_PASSWORD, TEST_PERSIST_CLIENT, TEST_LABEL, TEST_2FA_CODE)</ID>
        <ID>PropertyWrapping:LoginUseCaseTest.kt$LoginUseCaseTest$val loginUserCaseResult = loginUseCase(dirtyEmail, TEST_PASSWORD, TEST_PERSIST_CLIENT, TEST_LABEL, TEST_2FA_CODE)</ID>
        <ID>PropertyWrapping:LoginUseCaseTest.kt$LoginUseCaseTest$val loginUserCaseResult = loginUseCase(dirtyHandle, TEST_PASSWORD, TEST_PERSIST_CLIENT, TEST_LABEL, TEST_2FA_CODE)</ID>
        <ID>PropertyWrapping:LoginUseCaseTest.kt$LoginUseCaseTest.Arrangement$val secondFactorVerificationRepository: SecondFactorVerificationRepository = FakeSecondFactorVerificationRepository()</ID>
        <ID>PropertyWrapping:LogoutUseCaseTest.kt$LogoutUseCaseTest.Arrangement$@Mock val userSessionScopeProvider = configure(mock(classOf&lt;UserSessionScopeProvider>())) { stubsUnitByDefault = true }</ID>
        <ID>PropertyWrapping:LogoutUseCaseTest.kt$LogoutUseCaseTest.Arrangement$@Mock val userSessionWorkScheduler = configure(mock(classOf&lt;UserSessionWorkScheduler>())) { stubsUnitByDefault = true }</ID>
        <ID>PropertyWrapping:MLSClientImpl.kt$MLSClientImpl$private val defaultGroupConfiguration = CustomConfiguration(keyRotationDuration.toJavaDuration(), MlsWirePolicy.PLAINTEXT)</ID>
        <ID>PropertyWrapping:MLSWelcomeEventHandlerTest.kt$MLSWelcomeEventHandlerTest.Arrangement$@Mock val certificateRevocationListRepository: CertificateRevocationListRepository = mock(classOf&lt;CertificateRevocationListRepository>())</ID>
        <ID>PropertyWrapping:MarkLegalHoldChangeAsNotifiedForSelfUseCaseTest.kt$MarkLegalHoldChangeAsNotifiedForSelfUseCaseTest.Arrangement$val useCase: MarkLegalHoldChangeAsNotifiedForSelfUseCase = MarkLegalHoldChangeAsNotifiedForSelfUseCaseImpl(userConfigRepository)</ID>
        <ID>PropertyWrapping:MemberChangeEventHandlerTest.kt$MemberChangeEventHandlerTest.Arrangement$private val memberChangeEventHandler: MemberChangeEventHandler = MemberChangeEventHandlerImpl(conversationRepository)</ID>
        <ID>PropertyWrapping:MessageDAOImpl.kt$MessageDAOImpl$override val platformExtensions: MessageExtensions = MessageExtensionsImpl(queries, assetViewQueries, mapper, coroutineContext)</ID>
        <ID>PropertyWrapping:MessageLegalHoldTest.kt$MessageLegalHoldTest.Companion$val ORIGINAL_MESSAGE = newSystemMessageEntity(ORIGINAL_MESSAGE_ID, ORIGINAL_CONTENT, CONVERSATION_ID, OTHER_USER.id)</ID>
        <ID>PropertyWrapping:MessageScope.kt$MessageScope$val deleteEphemeralMessageEndDate: DeleteEphemeralMessagesAfterEndDateUseCase = DeleteEphemeralMessagesAfterEndDateUseCaseImpl( ephemeralMessageDeletionHandler = ephemeralMessageDeletionHandler )</ID>
        <ID>PropertyWrapping:MessageSendFailureHandlerTest.kt$MessageSendFailureHandlerTest$val failureData = ProteusSendMessageFailure(mapOf(arrangement.userOne, arrangement.userTwo), mapOf(), mapOf(), null)</ID>
        <ID>PropertyWrapping:MimeTypeUtil.kt$private val mimeTypeToExtensionMap: Map&lt;String, String> = // TODO: remove after all platforms have their own proper implementations mapOf( "image/jpg" to "jpg", "image/jpeg" to "jpeg", "image/png" to "png", "image/heic" to "heic", "image/gif" to "gif", "image/webp" to "webp", "audio/mpeg" to "mp3", "audio/ogg" to "ogg", "audio/wav" to "wav", "audio/x-wav" to "wav", "audio/x-pn-wav" to "wav", "video/mp4" to "mp4", "video/webm" to "webm", "video/3gpp" to "3gpp", "video/mkv" to "mkv" )</ID>
        <ID>PropertyWrapping:MimeTypeUtil.kt$private val mimeTypeToExtensionMap: Map&lt;String, String> = // TODO: remove after all platforms have their own proper implementations mapOf( "image/jpg" to "jpg", "image/jpeg" to "jpeg", "image/png" to "png", "image/heic" to "heic", "image/gif" to "gif", "image/webp" to "webp", "audio/mpeg" to "mp3", "audio/ogg" to "ogg", "audio/wav" to "wav", "audio/x-wav" to "wav", "audio/x-pn-wav" to "wav", "video/mp4" to "mp4", "video/webm" to "webm", "video/3gpp" to "3gpp", "video/mkv" to "mkv", "application/zip" to "zip", "application/pdf" to "pdf" )</ID>
        <ID>PropertyWrapping:ObserveNewClientsUseCaseTest.kt$ObserveNewClientsUseCaseTest.Arrangement$@Mock val userClientRepositoryProvider = configure(mock(classOf&lt;UserClientRepositoryProvider>())) { stubsUnitByDefault = true }</ID>
        <ID>PropertyWrapping:ObserveSelfDeletionTimerSettingsForConversationUseCaseArrangement.kt$ObserveSelfDeletionTimerSettingsForConversationUseCaseArrangementImpl$@Mock override val observeSelfDeletionTimerSettingsForConversation: ObserveSelfDeletionTimerSettingsForConversationUseCase = mock(ObserveSelfDeletionTimerSettingsForConversationUseCase::class)</ID>
        <ID>PropertyWrapping:OneOnOneResolverTest.kt$OneOnOneResolverTest$val oneOnOneUsers = listOf(TestUser.OTHER.copy(id = TestUser.OTHER_USER_ID), TestUser.OTHER.copy(id = TestUser.OTHER_USER_ID_2))</ID>
        <ID>PropertyWrapping:ProteusClientCoreCryptoImpl.kt$ProteusClientCoreCryptoImpl$val decryptedMessage = toByteArray(coreCrypto.proteusSessionFromMessage(sessionId.value, toUByteList(message)))</ID>
        <ID>PropertyWrapping:ProteusMessageUnpacker.kt$ProteusMessageUnpackerImpl$val rootCause = IllegalArgumentException("Null external content when processing external message instructions.")</ID>
        <ID>PropertyWrapping:ProteusMessageUnpacker.kt$ProteusMessageUnpackerImpl$val rootCause = IllegalArgumentException("! External message can't contain another external message inside!")</ID>
        <ID>PropertyWrapping:ProteusMessageUnpackerTest.kt$ProteusMessageUnpackerTest$val encryptedProtobufExternalContent = encryptDataWithAES256(PlainData(protobufExternalContent.encodeToByteArray()), aesKey)</ID>
        <ID>PropertyWrapping:ProtoContentMapperTest.kt$ProtoContentMapperTest$val genericMessage = GenericMessage(TEST_MESSAGE_UUID, GenericMessage.Content.Edited(MessageEdit(replacedMessageId, textContent)))</ID>
        <ID>PropertyWrapping:RegisterClientUseCaseTest.kt$RegisterClientUseCaseTest.Arrangement$val secondFactorVerificationRepository: SecondFactorVerificationRepository = FakeSecondFactorVerificationRepository()</ID>
        <ID>PropertyWrapping:RenamedConversationEventHandlerTest.kt$RenamedConversationEventHandlerTest.Arrangement$private val renamedConversationEventHandler: RenamedConversationEventHandler = RenamedConversationEventHandlerImpl( conversationDao, persistMessage )</ID>
        <ID>PropertyWrapping:ScheduleNewAssetMessageUseCaseTest.kt$ScheduleNewAssetMessageUseCaseTest.Arrangement$@Mock val observeSelfDeletionTimerSettingsForConversation = mock(classOf&lt;ObserveSelfDeletionTimerSettingsForConversationUseCase>())</ID>
        <ID>PropertyWrapping:SendButtonMessageCaseTest.kt$SendButtonMessageCaseTest.Arrangement$@Mock val messageSendFailureHandler = configure(mock(classOf&lt;MessageSendFailureHandler>())) { stubsUnitByDefault = true }</ID>
        <ID>PropertyWrapping:SendEditTextMessageUseCaseTest.kt$SendEditTextMessageUseCaseTest$val result = sendEditTextMessage(TestConversation.ID, originalMessageId, editedMessageText, listOf(), editedMessageId)</ID>
        <ID>PropertyWrapping:SendEditTextMessageUseCaseTest.kt$SendEditTextMessageUseCaseTest.Arrangement$@Mock val messageSendFailureHandler = configure(mock(classOf&lt;MessageSendFailureHandler>())) { stubsUnitByDefault = true }</ID>
        <ID>PropertyWrapping:SendKnockUserCaseTest.kt$SendKnockUserCaseTest.Arrangement$@Mock val messageSendFailureHandler = configure(mock(classOf&lt;MessageSendFailureHandler>())) { stubsUnitByDefault = true }</ID>
        <ID>PropertyWrapping:SendLocationUseCaseTest.kt$SendLocationUseCaseTest.Arrangement$@Mock val messageSendFailureHandler = configure(mock(classOf&lt;MessageSendFailureHandler>())) { stubsUnitByDefault = true }</ID>
        <ID>PropertyWrapping:SendTextMessageCaseTest.kt$SendTextMessageCaseTest.Arrangement$@Mock val messageSendFailureHandler = configure(mock(classOf&lt;MessageSendFailureHandler>())) { stubsUnitByDefault = true }</ID>
        <ID>PropertyWrapping:SendTextMessageCaseTest.kt$SendTextMessageCaseTest.Arrangement$@Mock val observeSelfDeletionTimerSettingsForConversation = mock(ObserveSelfDeletionTimerSettingsForConversationUseCase::class)</ID>
        <ID>PropertyWrapping:SendTypingEventUseCaseTest.kt$SendTypingEventUseCaseTest.Arrangement$@Mock val typingIndicatorRepository: TypingIndicatorOutgoingRepository = mock(TypingIndicatorOutgoingRepository::class)</ID>
        <ID>PropertyWrapping:SessionEstablisher.kt$SessionEstablisherImpl$val cryptoSessionID = CryptoSessionId(idMapper.toCryptoQualifiedIDId(recipientUserId), CryptoClientId(client.value))</ID>
        <ID>PropertyWrapping:SessionEstablisherTest.kt$SessionEstablisherTest$val userPreKeysResult = mapOf(TEST_USER_ID_1.domain to mapOf(TEST_USER_ID_1.value to mapOf(TEST_CLIENT_ID_1.value to preKey)))</ID>
        <ID>PropertyWrapping:SlowSyncManagerTest.kt$SlowSyncManagerTest.Arrangement$@Mock val slowSyncRepository: SlowSyncRepository = configure(mock(classOf&lt;SlowSyncRepository>())) { stubsUnitByDefault = true }</ID>
        <ID>PropertyWrapping:SlowSyncWorkerTest.kt$SlowSyncWorkerTest.Arrangement$@Mock val updateSupportedProtocols: UpdateSelfUserSupportedProtocolsUseCase = mock(UpdateSelfUserSupportedProtocolsUseCase::class)</ID>
        <ID>PropertyWrapping:SyncFeatureConfigsUseCaseTest.kt$SyncFeatureConfigsUseCaseTest.Arrangement$@Mock val updateSupportedProtocolsAndResolveOneOnOnes = mock(classOf&lt;UpdateSupportedProtocolsAndResolveOneOnOnesUseCase>())</ID>
        <ID>PropertyWrapping:ToggleReactionUseCaseTest.kt$ToggleReactionUseCaseTest.Arrangement$val currentClientIdProvider: CurrentClientIdProvider = CurrentClientIdProvider { Either.Right(TEST_CURRENT_CLIENT) }</ID>
        <ID>PropertyWrapping:TriggerBuffer.kt$TriggerBuffer$private val newItemFlow = MutableSharedFlow&lt;Unit>(extraBufferCapacity = 1, onBufferOverflow = BufferOverflow.DROP_OLDEST)</ID>
        <ID>PropertyWrapping:TypingIndicatorHandlerTest.kt$TypingIndicatorHandlerTest.Arrangement$@Mock val typingIndicatorIncomingRepository: TypingIndicatorIncomingRepository = mock(TypingIndicatorIncomingRepository::class)</ID>
        <ID>PropertyWrapping:UpdateConversationArchivedStatusUseCaseTest.kt$UpdateConversationArchivedStatusUseCaseTest$val result = updateConversationArchivedStatus(conversationId, isConversationArchived, onlyLocally, archivedStatusTimestamp)</ID>
        <ID>PropertyWrapping:UpdateCurrentSessionUseCaseTest.kt$UpdateCurrentSessionUseCaseTest$@Mock val sessionRepository: SessionRepository = configure(mock(classOf&lt;SessionRepository>())) { stubsUnitByDefault = true }</ID>
        <ID>PropertyWrapping:UploadUserAvatarUseCaseTest.kt$UploadUserAvatarUseCaseTest.Arrangement$private val uploadUserAvatarUseCase: UploadUserAvatarUseCase = UploadUserAvatarUseCaseImpl(userRepository, assetRepository)</ID>
        <ID>PropertyWrapping:UserDAOTest.kt$UserDAOTest$val usersToInsert = listOf(user1.copy(name = "other name to make sure this one wasn't inserted nor edited"), user2)</ID>
        <ID>PropertyWrapping:UserRepositoryTest.kt$UserRepositoryTest$val knownUserEntities = listOf(TestUser.DETAILS_ENTITY.copy(id = UserIDEntity(value = "id1", domain = "domain1")))</ID>
        <ID>ReturnCount:NetworkUtils.kt$internal fun String.splitSetCookieHeader(): List&lt;String></ID>
        <ID>SpacingAroundColon:BaseMLSClientTest.kt$BaseMLSClientTest$:</ID>
        <ID>SpacingAroundColon:CompositeMessageRepositoryArrangement.kt$CompositeMessageRepositoryArrangementImpl$:</ID>
        <ID>SpacingAroundColon:DeleteEphemeralMessageForSelfUserAsReceiverUseCaseTest.kt$DeleteEphemeralMessageForSelfUserAsReceiverUseCaseTest.Arrangement$:</ID>
        <ID>SpacingAroundColon:FeatureFlagSyncWorkerTest.kt$FeatureFlagSyncWorkerTest.&lt;no name provided>$:</ID>
        <ID>SpacingAroundColon:FederatedSearchParserTest.kt$FederatedSearchParserTest.Arrangement$:</ID>
        <ID>SpacingAroundColon:IncrementalSyncRepositoryArrangement.kt$IncrementalSyncRepositoryArrangementImpl$:</ID>
        <ID>SpacingAroundColon:LastMessageListTest.kt$LastMessageListTest$:</ID>
        <ID>SpacingAroundColon:MessageMapperTest.kt$MessageMapperTest.Arrangement$:</ID>
        <ID>SpacingAroundColon:MessageSenderTest.kt$MessageSenderTest.Arrangement$:</ID>
        <ID>SpacingAroundColon:SlowSyncManagerTest.kt$SlowSyncManagerTest.Arrangement$:</ID>
        <ID>SpacingAroundColon:SyncMigrationStub.kt$FailureSyncMigration$:</ID>
        <ID>SpacingAroundColon:SyncMigrationStub.kt$MigrationCrashStep$:</ID>
        <ID>SpacingAroundColon:SyncMigrationStub.kt$SuccessSyncMigration$:</ID>
        <ID>SpacingAroundColon:SystemMessageInserterArrangement.kt$SystemMessageInserterArrangementImpl$:</ID>
        <ID>SpacingAroundColon:UpdateSupportedProtocolsAndResolveOneOnOnesArrangement.kt$UpdateSupportedProtocolsAndResolveOneOnOnesArrangementImpl$:</ID>
        <ID>SpacingAroundComma:BaseProteusClientTest.kt$BaseProteusClientTest$,</ID>
        <ID>SpacingAroundComma:E2EIClientProviderTest.kt$E2EIClientProviderTest$,</ID>
        <ID>SpacingAroundComma:E2EIClientTest.kt$E2EIClientTest$,</ID>
        <ID>SpacingAroundComma:ObserveConversationListDetailsUseCaseTest.kt$ObserveConversationListDetailsUseCaseTest$,</ID>
        <ID>SpacingAroundCurly:DeleteClientUseCaseTest.kt$DeleteClientUseCaseTest.Arrangement${</ID>
        <ID>SpacingAroundCurly:DeleteMessageUseCaseTest.kt$DeleteMessageUseCaseTest.Arrangement${</ID>
        <ID>SpacingAroundCurly:MLSConfigHandlerTest.kt$MLSConfigHandlerTest.Arrangement${</ID>
        <ID>SpacingAroundCurly:MLSMigrationConfigHandlerTest.kt$MLSMigrationConfigHandlerTest.Arrangement${</ID>
        <ID>SpacingAroundCurly:MessageSenderTest.kt$MessageSenderTest.Arrangement${</ID>
        <ID>SpacingAroundCurly:OneOnOneMigratorTest.kt$OneOnOneMigratorTest.Arrangement${</ID>
        <ID>SpacingAroundCurly:ProtocolUpdateEventHandlerTest.kt$ProtocolUpdateEventHandlerTest.Arrangement${</ID>
        <ID>SpacingAroundCurly:RejectCallUseCaseTest.kt$RejectCallUseCaseTest${</ID>
        <ID>SpacingAroundCurly:SlowSyncManagerTest.kt$SlowSyncManagerTest${</ID>
        <ID>SpacingAroundCurly:StaleEpochVerifierTest.kt$StaleEpochVerifierTest.Arrangement${</ID>
        <ID>SpacingAroundKeyword:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$if</ID>
        <ID>SpacingAroundOperators:E2EIClientProviderTest.kt$E2EIClientProviderTest$=</ID>
        <ID>SpacingAroundOperators:MLSWelcomeEventHandlerTest.kt$MLSWelcomeEventHandlerTest$=</ID>
        <ID>SpacingAroundOperators:ServerConfigDTOJson.kt$ServerConfigDTOJson$-></ID>
        <ID>SpacingAroundOperators:UserDAOTest.kt$UserDAOTest$=</ID>
        <ID>SpacingAroundParens:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest.Arrangement$)</ID>
        <ID>SpacingAroundParens:MLSClientTest.kt$MLSClientTest$(</ID>
        <ID>SpacingAroundParens:MessageTextEditHandlerTest.kt$MessageTextEditHandlerTest$)</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ApiMigrationManagerTest.kt$ApiMigrationManagerTest.Arrangement$@Mock val metadataDAO = mock(MetadataDAO::class)</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ApproveLegalHoldRequestUseCaseTest.kt$ApproveLegalHoldRequestUseCaseTest.Arrangement$@Mock val selfTeamIdProvider: SelfTeamIdProvider = mock(SelfTeamIdProvider::class)</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ClearConversationContentUseCaseTest.kt$ClearConversationContentUseCaseTest.Arrangement$@Mock val currentClientIdProvider = mock(classOf&lt;CurrentClientIdProvider>())</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ClientApiV0Test.kt$ClientApiV0Test$@Test fun givenAValidUpdateClientCapabilitiesRequest_whenCallingTheUpdateClientEndpoint_theRequestShouldBeConfiguredCorrectly()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:CommonUtilsTest.kt$CommonUtilsTest$@Test fun givenAFileNameWithMultipleDotsAndStartingWithADot_whenGettingItsFileExtension_itReturnsItCorrectly()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ConversationAccessDTO.kt$ConversationAccessDTO$CODE</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ConversationAccessDTO.kt$ConversationAccessDTO$INVITE</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ConversationAccessDTO.kt$ConversationAccessDTO$LINK</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ConversationAccessDTO.kt$ConversationAccessDTO$SELF_INVITE</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ConversationAccessRoleDTO.kt$ConversationAccessRoleDTO$EXTERNAL</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ConversationAccessRoleDTO.kt$ConversationAccessRoleDTO$GUEST</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ConversationAccessRoleDTO.kt$ConversationAccessRoleDTO$NON_TEAM_MEMBER</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ConversationAccessRoleDTO.kt$ConversationAccessRoleDTO$SERVICE</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:CurrentSessionFlowUseCaseTest.kt$CurrentSessionFlowUseCaseTest$@Test fun givenAUserID_whenCurrentSessionFlowEmitsSameDataAgain_thenDoPropagateTheSameDataAgain()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:FetchLegalHoldForSelfUserFromRemoteUseCaseTest.kt$FetchLegalHoldForSelfUserFromRemoteUseCaseTest.Arrangement$@Mock val selfTeamIdProvider: SelfTeamIdProvider = mock(SelfTeamIdProvider::class)</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$@OptIn(ExperimentalCoroutinesApi::class) @Test fun givenNewMessageWithChangedLegalHoldStateAndSyncing_whenHandlingNewMessage_thenBufferAndHandleItWhenSyncStateIsLive()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$@Test fun givenConversationLegalHoldAlreadyDisabled_whenHandlingDisable_thenDoNotHandleDisabledForConversation()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$@Test fun givenConversationLegalHoldAlreadyEnabled_whenHandlingEnable_thenDoNotHandleEnabledForConversation()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$@Test fun givenConversationWithLegalHoldDisabled_whenNewMessageWithLegalHoldEnabled_thenHandleEnabledForConversation()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$@Test fun givenConversationWithLegalHoldEnabled_whenNewMessageWithLegalHoldDisabled_thenHandleDisabledForConversation()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$@Test fun givenConversationWithLegalHoldEnabled_whenNewMessageWithLegalHoldEnabled_thenDoNotHandleDisabledForConversation()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$@Test fun givenConversationWithStillUsersUnderLegalHold_whenHandlingDisable_thenDoNotHandleDisabledForConversation()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$@Test fun givenConversation_whenHandlingNewMessageWithChangedLegalHold_thenUseTimestampOfMessageMinus1msToCreateSystemMessage()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$@Test fun givenFirstUserUnderLegalHoldAppeared_whenHandlingEnable_thenHandleEnabledForConversation()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$@Test fun givenLegalHoldChangedForConversation_whenHandlingMessageSendFailure_thenUseTimestampOfMessageMinus1msForSystemMessage()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$@Test fun givenNewConnectionAcceptedAndUserNotUnderLegalHold_whenHandling_thenUpdateConversationLegalHoldStatusToDisabled()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$@Test fun givenNewConnectionAcceptedAndUserUnderLegalHold_whenHandling_thenUpdateConversationLegalHoldStatusToEnabled()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$@Test fun givenNextUsersUnderLegalHoldAppeared_whenHandlingEnable_thenDoNotHandleEnabledForConversation()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldStatusResponse.kt$LegalHoldStatusDTO$DISABLED</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldStatusResponse.kt$LegalHoldStatusDTO$NO_CONSENT</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldStatusResponse.kt$LegalHoldStatusDTO$PENDING</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldSystemMessageHandlerTest.kt$LegalHoldSystemMessagesHandlerTest$@Test fun givenConversationId_whenHandlingDisableForConversation_thenCreateNewSystemMessage()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldSystemMessageHandlerTest.kt$LegalHoldSystemMessagesHandlerTest$@Test fun givenConversationId_whenHandlingEnableForConversation_thenCreateNewSystemMessage()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldSystemMessageHandlerTest.kt$LegalHoldSystemMessagesHandlerTest$@Test fun givenLastLegalHoldDisabledMessageForConversation_whenHandlingDisableForUser_thenUpdateExistingSystemMessage()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldSystemMessageHandlerTest.kt$LegalHoldSystemMessagesHandlerTest$@Test fun givenLastLegalHoldEnabledMessageForConversation_whenHandlingEnableForUser_thenUpdateExistingSystemMessage()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldSystemMessageHandlerTest.kt$LegalHoldSystemMessagesHandlerTest$@Test fun givenNoLastLegalHoldDisabledMessageForConversation_whenHandlingDisableForUser_thenCreateNewSystemMessage()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:LegalHoldSystemMessageHandlerTest.kt$LegalHoldSystemMessagesHandlerTest$@Test fun givenNoLastLegalHoldEnabledMessageForConversation_whenHandlingEnableForUser_thenCreateNewSystemMessage()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:MLSMigrator.kt$MLSMigratorImpl : MLSMigrator</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:MarkLegalHoldChangeAsNotifiedForSelfUseCaseTest.kt$MarkLegalHoldChangeAsNotifiedForSelfUseCaseTest$@Test fun givenAFailure_whenSettingLegalHoldChangeAsNotified_thenReturnSuccess()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:MembersHavingLegalHoldClientUseCaseTest.kt$MembersHavingLegalHoldClientUseCaseTest$@Test fun givenConversationMemberDoesNotHaveLegalHoldClient_whenCheckingMembersHavingLegalHoldClient_thenReturnEmptyList()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:MembersHavingLegalHoldClientUseCaseTest.kt$MembersHavingLegalHoldClientUseCaseTest$@Test fun givenFailure_whenCheckingMembersHavingLegalHoldClient_thenReturnFailure()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:MessageEnvelopeCreatorTest.kt$MessageEnvelopeCreatorTest$@Test fun givenRecipients_whenCreatingBroadcastEnvelope_thenProteusClientShouldBeUsedToEncryptForEachClient()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:MessageMapperTest.kt$MessageMapperTest$@Test fun givenLegalHoldContentWithTypeDisabledForConversation_whenMappingToMessageContent_thenResultShouldHaveExpectedData()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:MessageMapperTest.kt$MessageMapperTest$@Test fun givenLegalHoldContentWithTypeDisabledForMembers_whenMappingToMessageContent_thenResultShouldHaveExpectedData()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:MessageMapperTest.kt$MessageMapperTest$@Test fun givenLegalHoldContentWithTypeEnabledForConversation_whenMappingToMessageContent_thenResultShouldHaveExpectedData()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:MessageMapperTest.kt$MessageMapperTest$@Test fun givenLegalHoldContentWithTypeEnabledForMembers_whenMappingToMessageContent_thenResultShouldHaveExpectedData()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:MessageMapperTest.kt$MessageMapperTest$@Test fun givenLegalHoldForConversationDisabled_whenMappingToMessageEntityContent_thenResultShouldHaveExpectedData()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:MessageMapperTest.kt$MessageMapperTest$@Test fun givenLegalHoldForConversationEnabled_whenMappingToMessageEntityContent_thenResultShouldHaveExpectedData()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:MessageMapperTest.kt$MessageMapperTest$@Test fun givenLegalHoldForMembersDisabled_whenMappingToMessageEntityContent_thenResultShouldHaveExpectedData()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:MessageRepositoryTest.kt$MessageRepositoryTest$@Test fun givenConversationIds_whenGettingLastMessagesForConversationIds_thenTheDAOShouldBeCalledWithProperValues()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:MessageRepositoryTest.kt$MessageRepositoryTest$@Test fun givenLegalHoldForMembersMessage_whenUpdatingMembers_thenTheDAOShouldBeCalledWithProperValues()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:MonkeyApplication.kt$MonkeyApplication$@Suppress("MagicNumber") private val delayPool by option( "-d", "--delay-pool", help = "Time in milliseconds it will wait for a conversation to be added to the pool." ).long().default(1000L)</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ObserveConversationInteractionAvailabilityUseCaseTest.kt$ObserveConversationInteractionAvailabilityUseCaseTest$@Test fun givenConversationLegalHoldIsDegraded_whenInvokingInteractionForConversation_thenInteractionShouldBeLegalHold()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ObserveConversationListDetailsUseCaseTest.kt$ObserveConversationListDetailsUseCaseTest$@Test fun givenSomeConversationsWithArchivedValues_whenFetchingOnlyNonArchived_thenTheseConversationsShouldNotBeReturned()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ObserveConversationUnderLegalHoldNotifiedUseCaseTest.kt$ObserveConversationUnderLegalHoldNotifiedUseCaseTest$@Test fun givenLegalHoldDisabledAndNotNotified_whenObserving_thenReturnFalse()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ObserveConversationUnderLegalHoldNotifiedUseCaseTest.kt$ObserveConversationUnderLegalHoldNotifiedUseCaseTest$@Test fun givenLegalHoldDisabledAndNotified_whenObserving_thenReturnTrue()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ObserveConversationUnderLegalHoldNotifiedUseCaseTest.kt$ObserveConversationUnderLegalHoldNotifiedUseCaseTest$@Test fun givenLegalHoldEnabledAndNotNotified_whenObserving_thenReturnFalse()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ObserveConversationUnderLegalHoldNotifiedUseCaseTest.kt$ObserveConversationUnderLegalHoldNotifiedUseCaseTest$@Test fun givenLegalHoldEnabledAndNotified_whenObserving_thenReturnTrue()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ObserveIsAppLockEditableUseCaseTest.kt$ObserveIsAppLockEditableUseCaseTest.Arrangement$@Mock val sessionRepository = mock(classOf&lt;SessionRepository>())</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ObserveLegalHoldChangeNotifiedForSelfUseCaseTest.kt$ObserveLegalHoldChangeNotifiedForSelfUseCaseTest$@Test fun givenLegalHoldForSelfDisabledAndAlreadyNotified_whenObserving_thenEmitAlreadyNotified()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ObserveLegalHoldChangeNotifiedForSelfUseCaseTest.kt$ObserveLegalHoldChangeNotifiedForSelfUseCaseTest$@Test fun givenLegalHoldForSelfDisabledAndNotYetNotified_whenObserving_thenEmitShouldNotifyWithLegalHoldDisabledState()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ObserveLegalHoldChangeNotifiedForSelfUseCaseTest.kt$ObserveLegalHoldChangeNotifiedForSelfUseCaseTest$@Test fun givenLegalHoldForSelfEnabledAndAlreadyNotified_whenObserving_thenEmitAlreadyNotified()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ObserveLegalHoldChangeNotifiedForSelfUseCaseTest.kt$ObserveLegalHoldChangeNotifiedForSelfUseCaseTest$@Test fun givenLegalHoldForSelfEnabledAndNotYetNotified_whenObserving_thenEmitShouldNotifyWithLegalHoldEnabledState()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ObserveLegalHoldChangeNotifiedForSelfUseCaseTest.kt$ObserveLegalHoldChangeNotifiedForSelfUseCaseTest$@Test fun givenStorageError_whenObserving_thenEmitFailure()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ObserveLegalHoldChangeNotifiedForSelfUseCaseTest.kt$ObserveLegalHoldChangeNotifiedForSelfUseCaseTest.Arrangement$@Mock val observeLegalHoldForUser = mock(ObserveLegalHoldStateForUserUseCase::class)</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ObserveLegalHoldChangeNotifiedForSelfUseCaseTest.kt$ObserveLegalHoldChangeNotifiedForSelfUseCaseTest.Arrangement$@Mock val userConfigRepository = mock(UserConfigRepository::class)</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ObserveNewClientsUseCaseTest.kt$ObserveNewClientsUseCaseTest$@Test fun givenNewClientForCurrentUser_whenUserIsBeingLoggedOut_thenChangeToEmptyResult()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ReplayApplication.kt$ReplayApplication$@Suppress("MagicNumber") private val delayPool by option( "-d", "--delay-pool", help = "Time in milliseconds it will wait for a conversation to be added to the pool." ).long().default(1000L)</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:SelfClientsUseCaseTest.kt$SelfClientsUseCaseTest$@Mock private val currentClientIdProvider = mock(classOf&lt;CurrentClientIdProvider>())</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:SendEditTextMessageUseCaseTest.kt$SendEditTextMessageUseCaseTest.Arrangement$@Mock val currentClientIdProvider = mock(classOf&lt;CurrentClientIdProvider>())</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:SendEditTextMessageUseCaseTest.kt$SendEditTextMessageUseCaseTest.Arrangement$@Mock val messageSendFailureHandler = configure(mock(classOf&lt;MessageSendFailureHandler>())) { stubsUnitByDefault = true }</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:SendEditTextMessageUseCaseTest.kt$SendEditTextMessageUseCaseTest.Arrangement$@Mock val messageSender = mock(classOf&lt;MessageSender>())</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:SendEditTextMessageUseCaseTest.kt$SendEditTextMessageUseCaseTest.Arrangement$@Mock val slowSyncRepository = mock(classOf&lt;SlowSyncRepository>())</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ServerModel.kt$ConversationIdRequest</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ServerModel.kt$CreateConversationRequest</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ServerModel.kt$RemoveMonkeyRequest</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ServerModel.kt$SendDMRequest</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:ServerModel.kt$SendMessageRequest</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:SimpleClientResponseTest.kt$SimpleClientResponseTest$@Test fun givenAJsonWithGibberishClass_whenDeserializingIt_thenHandleItByPuttingUnknownClass()</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:TeamsApi.kt$TeamsApi$PasswordRequest</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:UserDAO.kt$SupportedProtocolEntity$MLS</ID>
        <ID>SpacingBetweenDeclarationsWithAnnotations:UserEventReceiverTest.kt$UserEventReceiverTest$@Test fun givenNewConnectionEventWithStatusAcceptedAndPreviousStatusWasNotMissingConsent_thenCreateUnverifiedWarningMessage()</ID>
        <ID>SpacingBetweenDeclarationsWithComments:AcmeAuthorization.kt$AuthorizationChallengeType.OIDC$/** * OpenID Connect */</ID>
        <ID>SpacingBetweenDeclarationsWithComments:ClientModel.kt$/** * True if the client is considered to be in active use. * * A client is considered active if it has connected to the backend within * the `INACTIVE_DURATION`. */</ID>
        <ID>SpacingBetweenDeclarationsWithComments:EventGatherer.kt$EventGathererImpl$// TODO: Refactor so currentSource is emitted through the gatherEvents flow, instead of having two separated flows</ID>
        <ID>SpacingBetweenDeclarationsWithComments:LogoutReason.kt$LogoutReason.REMOVED_CLIENT$/** * User deleted this client from another client. */</ID>
        <ID>SpacingBetweenDeclarationsWithComments:TypingIndicatorSyncManager.kt$TypingIndicatorSyncManager$/** * Periodically clears and drop orphaned typing indicators, so we don't keep them forever. */</ID>
        <ID>TooGenericExceptionCaught:CoreFailure.kt$e: Exception</ID>
        <ID>TooGenericExceptionCaught:NetworkUtils.kt$e: Exception</ID>
        <ID>TooManyFunctions:Calling.kt$Calling : Library</ID>
        <ID>TooManyFunctions:ConversationDAO.kt$ConversationDAO</ID>
        <ID>TooManyFunctions:ConversationRepository.kt$ConversationRepository</ID>
        <ID>TooManyFunctions:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox</ID>
        <ID>TooManyFunctions:Decoder.module_@wireapp_cbor.kt$Decoder</ID>
        <ID>TooManyFunctions:Encoder.module_@wireapp_cbor.kt$Encoder</ID>
        <ID>TopLevelPropertyNaming:Uint32_t.kt$private const val integerSize = 4</ID>
        <ID>UnnecessaryParenthesesBeforeTrailingLambda:BackupConstantsTest.kt$BackupConstantsTest$()</ID>
        <ID>UnnecessaryParenthesesBeforeTrailingLambda:EncryptedSettingsBuilderTest.kt$EncryptedSettingsBuilderTest$()</ID>
        <ID>UnnecessaryParenthesesBeforeTrailingLambda:FetchLegalHoldForSelfUserFromRemoteUseCaseTest.kt$FetchLegalHoldForSelfUserFromRemoteUseCaseTest$()</ID>
        <ID>UnnecessaryParenthesesBeforeTrailingLambda:LegalHoldHandlerTest.kt$LegalHoldHandlerTest$()</ID>
        <ID>UnnecessaryParenthesesBeforeTrailingLambda:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest$()</ID>
        <ID>UnnecessaryParenthesesBeforeTrailingLambda:MessageSenderTest.kt$MessageSenderTest$()</ID>
        <ID>UnnecessaryParenthesesBeforeTrailingLambda:OnIncomingCallTest.kt$OnIncomingCallTest$()</ID>
        <ID>UnnecessaryParenthesesBeforeTrailingLambda:PendingProposalScheduler.kt$PendingProposalSchedulerImpl$()</ID>
        <ID>UnnecessaryParenthesesBeforeTrailingLambda:RegisterMLSClientUseCaseTest.kt$RegisterMLSClientUseCaseTest$()</ID>
        <ID>UnnecessaryParenthesesBeforeTrailingLambda:ServerConfigRepositoryTest.kt$ServerConfigRepositoryTest$()</ID>
        <ID>UnnecessaryParenthesesBeforeTrailingLambda:TeamRepositoryTest.kt$TeamRepositoryTest$()</ID>
        <ID>UnusedParameter:ClientResources.kt$ClientResources$@Valid request: SendSessionResetRequest</ID>
        <ID>UnusedParameter:ConsoleCommand.kt$ConsoleCommand$context: ConsoleContext</ID>
        <ID>UnusedParameter:ConsoleCommand.kt$ConsoleCommand$userSession: UserSessionScope</ID>
        <ID>UnusedParameter:ConversationMapper.kt$ConversationMapper$mlsProposalTimer: String?</ID>
        <ID>UnusedParameter:ConversationResources.kt$ConversationResources$@PathParam("id") id: String</ID>
        <ID>UnusedParameter:MessageExtensionsTest.kt$MessageExtensionsTest$prefix: String = ""</ID>
        <ID>UnusedParameter:MessageMapper.kt$MessageMapper$assetMimeType: String?</ID>
        <ID>UnusedParameter:MessageMapper.kt$MessageMapper$contentType: MessageEntity.ContentType</ID>
        <ID>UnusedParameter:MessageMapper.kt$MessageMapper$isEphemeral: Boolean</ID>
        <ID>UnusedParameter:MessageMapper.kt$MessageMapper$selfUserId: QualifiedIDEntity?</ID>
        <ID>UnusedParameter:MessageMapper.kt$MessageMapper$senderUserId: QualifiedIDEntity</ID>
        <ID>UnusedParameter:MessageMapper.kt$MessageMapper$visibility: MessageEntity.Visibility</ID>
        <ID>UnusedParameter:RestoreBackupUseCaseTest.kt$RestoreBackupUseCaseTest.Arrangement$userDBSecret: UserDBSecret? = null</ID>
        <ID>UnusedParameter:SelfServerConfigUseCaseTest.kt$SelfServerConfigUseCaseTest.Arrangement$serverConfig: ServerConfig</ID>
        <ID>UnusedParameter:TestEvent.kt$TestEvent$clientId: ClientId = ClientId("client")</ID>
        <ID>UnusedParameter:TestEvent.kt$TestEvent$members: List&lt;Member> = listOf()</ID>
        <ID>UnusedParameter:TestMessage.kt$TestMessage$assetId: String = TEST_MESSAGE_ID</ID>
        <ID>UnusedParameter:UserDAOImpl.kt$UserMapper$id: String?</ID>
        <ID>UnusedPrivateProperty:BaseProteusClientTest.kt$BaseProteusClientTest$private val testCoroutineScheduler = TestCoroutineScheduler()</ID>
        <ID>UnusedPrivateProperty:ClientResources.kt$ClientResources$private val log = LoggerFactory.getLogger(ClientResources::class.java.name)</ID>
        <ID>UnusedPrivateProperty:ConversationRepositoryTest.kt$ConversationRepositoryTest.Companion$private val TEST_QUALIFIED_ID_ENTITY = PersistenceQualifiedId("value", "domain")</ID>
        <ID>UnusedPrivateProperty:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$engine: CRUDEngineBaseCollection</ID>
        <ID>UnusedPrivateProperty:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$minimumAmountOfPreKeys: Number = definedExternally</ID>
        <ID>UnusedPrivateProperty:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$CryptoboxCRUDStore$engine: CRUDEngineBaseCollection</ID>
        <ID>UnusedPrivateProperty:Decoder.module_@wireapp_cbor.kt$Decoder$buffer: ArrayBuffer</ID>
        <ID>UnusedPrivateProperty:Decoder.module_@wireapp_cbor.kt$Decoder$config: DecoderConfig = definedExternally</ID>
        <ID>UnusedPrivateProperty:FlowManagerServiceImpl.kt$FlowManagerServiceImpl$appContext: PlatformContext</ID>
        <ID>UnusedPrivateProperty:GetNotificationsUseCaseTest.kt$GetNotificationsUseCaseTest.Companion$private const val TIME_EARLIER = "2000-01-23T01:23:30.678+09:00"</ID>
        <ID>UnusedPrivateProperty:GetNotificationsUseCaseTest.kt$GetNotificationsUseCaseTest.Companion$private val MY_ID = TestUser.USER_ID</ID>
        <ID>UnusedPrivateProperty:IdentityKey.module_@wireapp_proteus.kt$IdentityKey$publicKey: PublicKey</ID>
        <ID>UnusedPrivateProperty:IdentityKeyPair.module_@wireapp_proteus.kt$IdentityKeyPair$publicKey: IdentityKey = definedExternally</ID>
        <ID>UnusedPrivateProperty:IdentityKeyPair.module_@wireapp_proteus.kt$IdentityKeyPair$secretKey: SecretKey = definedExternally</ID>
        <ID>UnusedPrivateProperty:IdentityKeyPair.module_@wireapp_proteus.kt$IdentityKeyPair$version: Number = definedExternally</ID>
        <ID>UnusedPrivateProperty:JoinSubconversationUseCase.kt$JoinSubconversationUseCaseImpl$private val mlsMessageUnpacker: MLSMessageUnpacker</ID>
        <ID>UnusedPrivateProperty:KeyPair.module_@wireapp_proteus.kt$KeyPair$publicKey: PublicKey</ID>
        <ID>UnusedPrivateProperty:KeyPair.module_@wireapp_proteus.kt$KeyPair$secretKey: SecretKey</ID>
        <ID>UnusedPrivateProperty:ListUsersRequestJson.kt$ListUsersRequestJson$private val qualifiedHandlesProvider = { serializable: QualifiedHandleListRequest -> val handlesArrayContent = serializable.qualifiedHandles.joinToString(",") { """{"domain": "${it.domain}", "handle":"${it.handle}"""" } """{"qualified_ids": [$handlesArrayContent]}""" }</ID>
        <ID>UnusedPrivateProperty:LogResources.kt$LogResources$private val configuration: TestserviceConfiguration</ID>
        <ID>UnusedPrivateProperty:MLSConversationRepository.kt$MLSConversationDataSource$private val serverConfigLinks: ServerConfig.Links</ID>
        <ID>UnusedPrivateProperty:MarkAsReadCommand.kt$MarkAsReadCommand$val result = userSession.conversations.updateConversationReadDateUseCase( selectedConversation.id, DateTimeUtil.currentInstant() )</ID>
        <ID>UnusedPrivateProperty:MediaManagerServiceImpl.kt$MediaManagerServiceImpl$platformContext: PlatformContext</ID>
        <ID>UnusedPrivateProperty:NukeDBTest.kt$NukeDBTest$private val backupUserId = UserIDEntity("backup-selfValue", "selfDomain")</ID>
        <ID>UnusedPrivateProperty:PreKey.module_@wireapp_proteus.kt$PreKey$keyId: Number = definedExternally</ID>
        <ID>UnusedPrivateProperty:PreKey.module_@wireapp_proteus.kt$PreKey$keyPair: KeyPair = definedExternally</ID>
        <ID>UnusedPrivateProperty:PreKey.module_@wireapp_proteus.kt$PreKey$version: Number = definedExternally</ID>
        <ID>UnusedPrivateProperty:PreKeyBundle.module_@wireapp_proteus.kt$PreKeyBundle$preKey: PreKey</ID>
        <ID>UnusedPrivateProperty:PreKeyBundle.module_@wireapp_proteus.kt$PreKeyBundle$preKeyId: Number</ID>
        <ID>UnusedPrivateProperty:PreKeyBundle.module_@wireapp_proteus.kt$PreKeyBundle$publicIdentityKey: IdentityKey</ID>
        <ID>UnusedPrivateProperty:PreKeyBundle.module_@wireapp_proteus.kt$PreKeyBundle$publicKey: PublicKey</ID>
        <ID>UnusedPrivateProperty:PreKeyBundle.module_@wireapp_proteus.kt$PreKeyBundle$signature: Uint8Array? = definedExternally</ID>
        <ID>UnusedPrivateProperty:PreKeyBundle.module_@wireapp_proteus.kt$PreKeyBundle$version: Number = definedExternally</ID>
        <ID>UnusedPrivateProperty:ProteusClient.kt$ProteusClient$val payload: ByteArray = proteusClient.encrypt( messageData, CryptoSessionId(cryptoUserId, cryptoClientId) )</ID>
        <ID>UnusedPrivateProperty:ProteusClientSamples.kt$val proteusClient = ProteusClientCryptoBoxImpl( "rootDirectory" )</ID>
        <ID>UnusedPrivateProperty:PublicKey.module_@wireapp_proteus.kt$PublicKey$pubCurve: Uint8Array</ID>
        <ID>UnusedPrivateProperty:PublicKey.module_@wireapp_proteus.kt$PublicKey$pubEdward: Uint8Array</ID>
        <ID>UnusedPrivateProperty:ReceiptModeUpdateEventHandler.kt$ReceiptModeUpdateEventHandlerImpl$private val logger by lazy { kaliumLogger.withFeatureId(KaliumLogger.Companion.ApplicationFlow.EVENT_RECEIVER) }</ID>
        <ID>UnusedPrivateProperty:RegisterApiV0Test.kt$RegisterApiV0Test$val networkClient = mockUnauthenticatedNetworkClient( "", statusCode = HttpStatusCode.OK, assertion = { assertPost() assertJson() assertNoQueryParams() assertPathEqual("/activate") assertHttps() assertHostEqual(TEST_HOST) assertJsonBodyContent(VALID_ACTIVATE_EMAIL.rawJson) } )</ID>
        <ID>UnusedPrivateProperty:RegisterApiV0Test.kt$RegisterApiV0Test$val networkClient = mockUnauthenticatedNetworkClient( "", statusCode = HttpStatusCode.OK, assertion = { assertPost() assertJson() assertNoQueryParams() assertPathEqual("/activate/send") assertHttps() assertHostEqual(TEST_HOST) assertJsonBodyContent(VALID_PERSONAL_ACCOUNT_REQUEST.rawJson) } )</ID>
        <ID>UnusedPrivateProperty:RegisterApiV0Test.kt$RegisterApiV0Test$val networkClient = mockUnauthenticatedNetworkClient( ERROR_RESPONSE.rawJson, statusCode = HttpStatusCode.BadRequest, assertion = { assertPost() assertJson() assertNoQueryParams() assertPathEqual("/activate") assertHttps() assertHostEqual(TEST_HOST) assertJsonBodyContent(VALID_PERSONAL_ACCOUNT_REQUEST.rawJson) } )</ID>
        <ID>UnusedPrivateProperty:RegisterApiV0Test.kt$RegisterApiV0Test$val networkClient = mockUnauthenticatedNetworkClient( ERROR_RESPONSE.rawJson, statusCode = HttpStatusCode.BadRequest, assertion = { assertPost() assertJson() assertNoQueryParams() assertPathEqual("/activate/send") assertHttps() assertHostEqual(TEST_HOST) assertJsonBodyContent(VALID_PERSONAL_ACCOUNT_REQUEST.rawJson) } )</ID>
        <ID>UnusedPrivateProperty:RegisterApiV0Test.kt$RegisterApiV0Test$val networkClient = mockUnauthenticatedNetworkClient( ERROR_RESPONSE.rawJson, statusCode = HttpStatusCode.BadRequest, assertion = { assertPost() assertJson() assertNoQueryParams() assertPathEqual("/register") assertHttps() assertHostEqual(TEST_HOST) assertJsonBodyContent(VALID_PERSONAL_ACCOUNT_REQUEST.rawJson) } )</ID>
        <ID>UnusedPrivateProperty:RegisterApiV0Test.kt$RegisterApiV0Test$val networkClient = mockUnauthenticatedNetworkClient( VALID_REGISTER_RESPONSE.rawJson, statusCode = HttpStatusCode.OK, assertion = { assertPost() assertJson() assertNoQueryParams() assertPathEqual("/register") assertHttps() assertHostEqual(TEST_HOST) assertJsonBodyContent(VALID_PERSONAL_ACCOUNT_REQUEST.rawJson) } )</ID>
        <ID>UnusedPrivateProperty:SecretKey.module_@wireapp_proteus.kt$SecretKey$secCurve: Uint8Array</ID>
        <ID>UnusedPrivateProperty:SecretKey.module_@wireapp_proteus.kt$SecretKey$secEdward: Uint8Array</ID>
        <ID>UnusedPrivateProperty:SessionEstablisherTest.kt$SessionEstablisherTest$val userPreKeysResult = mapOf(TEST_USER_ID_1.domain to mapOf(TEST_USER_ID_1.value to mapOf(TEST_CLIENT_ID_1.value to preKey)))</ID>
        <ID>UnusedPrivateProperty:TestGlobalDatabase.kt$TestGlobalDatabase$private val dispatcher: TestDispatcher = StandardTestDispatcher()</ID>
        <ID>UnusedPrivateProperty:UpdateClientVerificationStatusUseCaseTest.kt$UpdateClientVerificationStatusUseCaseTest.Companion$private val OTHER_USER_CLIENT = OtherUserClient( deviceType = DeviceType.Phone, id = "some_id", isValid = true, isProteusVerified = true )</ID>
        <ID>UnusedPrivateProperty:UploadUserAvatarUseCaseTest.kt$UploadUserAvatarUseCaseTest.Arrangement$private val dummySelfUser = SelfUser( id = UserId("some_id", "some_domain"), name = "some_name", handle = "some_handle", email = "some_email", phone = null, accentId = 1, teamId = null, connectionStatus = ConnectionState.ACCEPTED, previewPicture = UserAssetId("value1", "domain"), completePicture = UserAssetId("value2", "domain"), userType = UserType.INTERNAL, availabilityStatus = UserAvailabilityStatus.NONE, expiresAt = null, supportedProtocols = setOf(SupportedProtocol.PROTEUS) )</ID>
        <ID>UnusedPrivateProperty:UserConfigStorage.kt$UserConfigStorageImpl$private val legalHoldRequestFlow = MutableSharedFlow&lt;Unit>( extraBufferCapacity = 1, onBufferOverflow = BufferOverflow.DROP_OLDEST )</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val androidMain by getting { addCommonKotlinJvmSourceDir() dependencies { api(libs.avs) api(libs.jna.map { project.dependencies.create(it, closureOf&lt;ExternalModuleDependency> { artifact { type = "aar" } }) }) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val androidMain by getting { addCommonKotlinJvmSourceDir() dependencies { implementation(libs.cryptoboxAndroid) implementation(libs.androidCrypto) implementation(libs.coreCryptoAndroid.get().let { "${it.module}:${it.versionConstraint.requiredVersion}" }) { exclude("androidx.core") exclude("androidx.appcompat") } } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val androidMain by getting { addCommonKotlinJvmSourceDir() dependencies { implementation(libs.ktor.okHttp) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val androidMain by getting { addCommonKotlinJvmSourceDir() dependencies { implementation(libs.work) implementation(libs.coreCryptoAndroid.get().let { "${it.module}:${it.versionConstraint.requiredVersion}" }) { exclude("androidx.core") exclude("androidx.appcompat") } } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val androidMain by getting { dependencies { implementation(libs.androidCrypto) implementation(libs.sqldelight.androidDriver) implementation(libs.sqlite.androidx) implementation(libs.sql.android.cipher) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val androidMain by getting { dependencies { implementation(libs.androidtest.runner) implementation(libs.androidtest.rules) implementation(libs.androidtest.core) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val androidMain by getting { dependencies { implementation(libs.annotation) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val androidMain by getting { dependencies { implementation(project(":logic")) implementation(project(":calling")) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val androidUnitTest by getting { dependencies { implementation(libs.androidtest.runner) implementation(libs.androidtest.rules) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val androidUnitTest by getting { dependencies { implementation(libs.robolectric) implementation(libs.core.ktx) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val appleMain by getting { dependencies { implementation(libs.coreCrypto) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val appleMain by getting { dependencies { implementation(libs.ktor.iosHttp) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val appleMain by getting { dependencies { implementation(libs.sqldelight.nativeDriver) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val appleMain by getting { dependencies { implementation(project(":logic")) implementation(project(":calling")) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val commonMain by getting { dependencies { // coroutines implementation(libs.coroutines.core) implementation(libs.sqldelight.runtime) implementation(libs.sqldelight.coroutinesExtension) implementation(libs.sqldelight.primitiveAdapters) implementation(libs.ktxSerialization) implementation(libs.settings.kmp) implementation(libs.ktxDateTime) implementation(libs.sqldelight.androidxPaging) implementation(project(":util")) api(project(":logger")) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val commonMain by getting { dependencies { api(libs.kermit) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val commonMain by getting { dependencies { api(project(":logger")) // coroutines implementation(libs.coroutines.core) api(libs.ktor.core) // KTX implementation(libs.ktxDateTime) // Okio implementation(libs.okio.core) // Libsodium implementation(libs.libsodiumBindingsMP) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val commonMain by getting { dependencies { api(project(":logger")) implementation(libs.coroutines.core) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val commonMain by getting { dependencies { implementation(libs.ktxSerialization) // coroutines implementation(libs.coroutines.core) implementation(libs.ktxDateTime) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val commonMain by getting { dependencies { implementation(project(":network")) api(project(":network-util")) implementation(project(":cryptography")) implementation(project(":persistence")) implementation(project(":protobuf")) api(project(":logger")) api(project(":calling")) implementation(project(":util")) // coroutines implementation(libs.coroutines.core) implementation(libs.ktxSerialization) implementation(libs.ktxDateTime) implementation(libs.benAsherUUID) // the Dependency is duplicated between here and persistence build.gradle.kts implementation(libs.settings.kmp) // Okio implementation(libs.okio.core) implementation(libs.sqldelight.androidxPaging) // Concurrent collections implementation(libs.concurrentCollections) implementation(libs.statelyCommons) configurations.all { exclude(group = "co.touchlab", module = "stately-strict-jvm") } } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val commonMain by getting { dependencies { implementation(project(":network")) implementation(project(":cryptography")) implementation(project(":persistence")) implementation(project(":protobuf")) implementation(project(":logger")) implementation(libs.coroutines.core) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val commonMain by getting { dependencies { implementation(project(":persistence")) implementation(libs.kotlin.test) // coroutines implementation(libs.coroutines.core) implementation(libs.coroutines.test) implementation(libs.settings.kmp) implementation(libs.settings.kmpTest) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val commonMain by getting { dependencies { implementation(project(":protobuf")) implementation(project(":util")) implementation(project(":network-util")) api(project(":logger")) // coroutines implementation(libs.coroutines.core) // ktor api(libs.ktor.core) implementation(libs.ktor.utils) implementation(libs.ktor.json) implementation(libs.ktor.serialization) implementation(libs.ktor.logging) implementation(libs.ktor.authClient) implementation(libs.ktor.webSocket) implementation(libs.ktor.contentNegotiation) implementation(libs.ktor.encoding) // KTX implementation(libs.ktxDateTime) implementation(libs.ktx.atomicfu) // Okio implementation(libs.okio.core) implementation(libs.okio.test) // UUIDs implementation(libs.benAsherUUID) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val commonMain by getting { kotlin.srcDir(generatedFilesBaseDir) dependencies { api(libs.pbandk.runtime.common) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val commonMain by sourceSets.getting { dependencies { implementation(project(":network")) implementation(project(":cryptography")) implementation(project(":logic")) implementation(project(":util")) implementation(libs.cliKt) implementation(libs.ktor.utils) implementation(libs.coroutines.core) implementation(libs.ktxDateTime) implementation(libs.mordant) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val commonTest by getting { dependencies { // coroutines implementation(libs.coroutines.test) // ktor test implementation(libs.ktor.mock) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val commonTest by getting { dependencies { // coroutines implementation(libs.coroutines.test) implementation(libs.turbine) // MultiplatformSettings implementation(libs.settings.kmpTest) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val commonTest by getting { dependencies { implementation(libs.coroutines.test) implementation(libs.okio.test) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val commonTest by getting { dependencies { implementation(libs.coroutines.test) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val commonTest by getting { dependencies { implementation(project(":persistence-test")) // coroutines implementation(libs.coroutines.test) implementation(libs.turbine) // mocking implementation(libs.mockative.runtime) implementation(libs.okio.test) implementation(libs.settings.kmpTest) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val commonTest by getting { dependencies { } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val iosArm64Main by getting { dependencies { api(libs.pbandk.runtime.iosArm64) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val iosSimulatorArm64Main by getting { dependencies { api(libs.pbandk.runtime.iosSimulatorArm64) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val iosX64Main by getting { dependencies { api(libs.pbandk.runtime.iosX64) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val jsMain by getting { dependencies { implementation(libs.sqldelight.jsDriver) implementation(npm("sql.js", "1.6.2")) implementation(devNpm("copy-webpack-plugin", "9.1.0")) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val jsMain by getting { dependencies { implementation(npm("@wireapp/cryptobox", "12.7.2", generateExternals = false)) implementation(npm("@wireapp/store-engine", "4.9.9", generateExternals = false)) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val jsTest by getting</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val jvmMain by getting { addCommonKotlinJvmSourceDir() dependencies { implementation(libs.cryptobox4j) implementation(libs.coreCryptoJvm) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val jvmMain by getting { addCommonKotlinJvmSourceDir() dependencies { implementation(libs.jna) implementation(libs.coreCryptoJvm) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val jvmMain by getting { addCommonKotlinJvmSourceDir() dependencies { implementation(libs.jna) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val jvmMain by getting { addCommonKotlinJvmSourceDir() dependencies { implementation(libs.ktor.okHttp) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val jvmMain by getting { dependencies { implementation(libs.apacheTika) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val jvmMain by getting { dependencies { implementation(libs.coroutines.core) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val jvmMain by getting { dependencies { implementation(libs.ktor.okHttp) implementation(libs.okhttp.loggingInterceptor) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val jvmMain by getting { dependencies { implementation(libs.sqldelight.jvmDriver) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val jvmMain by getting { dependencies { implementation(project(":logic")) implementation(project(":calling")) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val jvmTest by getting</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val jvmTest by getting { dependencies { implementation(libs.konsist) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val macosArm64Main by getting { dependencies { api(libs.pbandk.runtime.macArm64) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val macosMain by getting { dependencies { implementation(libs.ktor.iosHttp) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val macosX64Main by getting { dependencies { api(libs.pbandk.runtime.macX64) } }</ID>
        <ID>UnusedPrivateProperty:build.gradle.kts$val main by getting { dependencies { implementation(project(":network")) implementation(project(":cryptography")) implementation(project(":logic")) implementation(project(":util")) implementation(libs.cliKt) implementation(libs.ktor.utils) implementation(libs.coroutines.core) implementation(libs.ktxDateTime) implementation(libs.ktxReactive) implementation(libs.ktxSerialization) implementation(libs.ktor.serialization) implementation(libs.ktor.okHttp) implementation(libs.ktor.contentNegotiation) implementation(libs.ktor.json) implementation(libs.ktor.authClient) implementation(libs.ktor.server) implementation(libs.ktor.serverNetty) implementation(libs.ktor.serverLogging) implementation(libs.ktor.serverCallId) implementation(libs.ktor.serverMetrics) implementation(libs.ktor.serverContentNegotiation) implementation(libs.ktor.statusPages) implementation(libs.okhttp.loggingInterceptor) implementation(libs.micrometer) implementation(libs.slf4js) implementation(libs.faker) implementation(libs.concurrentCollections) implementation(libs.statelyCommons) implementation(libs.sqldelight.r2dbc) implementation(libs.sqldelight.async) implementation(libs.r2dbc.postgres) implementation(libs.r2dbc.spi) } }</ID>
        <ID>VariableNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open var create_last_resort_prekey: Any</ID>
        <ID>VariableNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open var create_new_identity: Any</ID>
        <ID>VariableNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open var get_prekey: Any</ID>
        <ID>VariableNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open var get_session_queue: Any</ID>
        <ID>VariableNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open var load_session_from_cache: Any</ID>
        <ID>VariableNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open var publish_event: Any</ID>
        <ID>VariableNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open var publish_prekeys: Any</ID>
        <ID>VariableNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open var publish_session_id: Any</ID>
        <ID>VariableNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open var refill_prekeys: Any</ID>
        <ID>VariableNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open var remove_session_from_cache: Any</ID>
        <ID>VariableNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open var save_identity: Any</ID>
        <ID>VariableNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open var save_session_in_cache: Any</ID>
        <ID>VariableNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open var session_from_message: Any</ID>
        <ID>VariableNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open var session_save: Any</ID>
        <ID>VariableNaming:Cryptobox.module_@wireapp_cryptobox.kt$Cryptobox$open var session_update: Any</ID>
        <ID>VariableNaming:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$CryptoboxCRUDStore$open var from_store: Any</ID>
        <ID>VariableNaming:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$CryptoboxCRUDStore$open var to_store: Any</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$Decoder$open var _advance: Any</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$Decoder$open var _bytes: Any</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$Decoder$open var _f32: Any</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$Decoder$open var _f64: Any</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$Decoder$open var _read: Any</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$Decoder$open var _read_length: Any</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$Decoder$open var _read_signed: Any</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$Decoder$open var _read_type_info: Any</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$Decoder$open var _read_unsigned: Any</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$Decoder$open var _skip_until_break: Any</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$Decoder$open var _skip_value: Any</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$Decoder$open var _type_info_with_assert: Any</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$Decoder$open var _u16: Any</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$Decoder$open var _u32: Any</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$Decoder$open var _u64: Any</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$Decoder$open var _u8: Any</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$DecoderConfig$var max_array_length: Number</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$DecoderConfig$var max_bytes_length: Number</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$DecoderConfig$var max_nesting: Number</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$DecoderConfig$var max_object_size: Number</ID>
        <ID>VariableNaming:Decoder.module_@wireapp_cbor.kt$DecoderConfig$var max_text_length: Number</ID>
        <ID>VariableNaming:Encoder.module_@wireapp_cbor.kt$Encoder$open var _advance: Any</ID>
        <ID>VariableNaming:Encoder.module_@wireapp_cbor.kt$Encoder$open var _bytes: Any</ID>
        <ID>VariableNaming:Encoder.module_@wireapp_cbor.kt$Encoder$open var _ensure: Any</ID>
        <ID>VariableNaming:Encoder.module_@wireapp_cbor.kt$Encoder$open var _f32: Any</ID>
        <ID>VariableNaming:Encoder.module_@wireapp_cbor.kt$Encoder$open var _f64: Any</ID>
        <ID>VariableNaming:Encoder.module_@wireapp_cbor.kt$Encoder$open var _grow_buffer: Any</ID>
        <ID>VariableNaming:Encoder.module_@wireapp_cbor.kt$Encoder$open var _new_buffer_length: Any</ID>
        <ID>VariableNaming:Encoder.module_@wireapp_cbor.kt$Encoder$open var _u16: Any</ID>
        <ID>VariableNaming:Encoder.module_@wireapp_cbor.kt$Encoder$open var _u32: Any</ID>
        <ID>VariableNaming:Encoder.module_@wireapp_cbor.kt$Encoder$open var _u64: Any</ID>
        <ID>VariableNaming:Encoder.module_@wireapp_cbor.kt$Encoder$open var _u8: Any</ID>
        <ID>VariableNaming:Encoder.module_@wireapp_cbor.kt$Encoder$open var _write: Any</ID>
        <ID>VariableNaming:Encoder.module_@wireapp_cbor.kt$Encoder$open var _write_type_and_len: Any</ID>
        <ID>VariableNaming:IdentityKey.module_@wireapp_proteus.kt$IdentityKey$open var public_key: PublicKey</ID>
        <ID>VariableNaming:IdentityKeyPair.module_@wireapp_proteus.kt$IdentityKeyPair$open var public_key: IdentityKey</ID>
        <ID>VariableNaming:IdentityKeyPair.module_@wireapp_proteus.kt$IdentityKeyPair$open var secret_key: SecretKey</ID>
        <ID>VariableNaming:KeyPair.module_@wireapp_proteus.kt$KeyPair$open var public_key: PublicKey</ID>
        <ID>VariableNaming:KeyPair.module_@wireapp_proteus.kt$KeyPair$open var secret_key: SecretKey</ID>
        <ID>VariableNaming:PreKey.module_@wireapp_proteus.kt$PreKey$open var key_id: Number</ID>
        <ID>VariableNaming:PreKey.module_@wireapp_proteus.kt$PreKey$open var key_pair: KeyPair</ID>
        <ID>VariableNaming:PreKeyBundle.module_@wireapp_proteus.kt$PreKeyBundle$open var identity_key: IdentityKey</ID>
        <ID>VariableNaming:PreKeyBundle.module_@wireapp_proteus.kt$PreKeyBundle$open var prekey_id: Number</ID>
        <ID>VariableNaming:PreKeyBundle.module_@wireapp_proteus.kt$PreKeyBundle$open var public_key: PublicKey</ID>
        <ID>VariableNaming:PublicKey.module_@wireapp_proteus.kt$PublicKey$open var pub_curve: Uint8Array</ID>
        <ID>VariableNaming:PublicKey.module_@wireapp_proteus.kt$PublicKey$open var pub_edward: Uint8Array</ID>
        <ID>VariableNaming:SecretKey.module_@wireapp_proteus.kt$SecretKey$open var sec_curve: Uint8Array</ID>
        <ID>VariableNaming:SecretKey.module_@wireapp_proteus.kt$SecretKey$open var sec_edward: Uint8Array</ID>
        <ID>WildcardImport:CRUDEngine.module_@wireapp_store-engine.kt$import kotlin.js.*</ID>
        <ID>WildcardImport:CRUDEngine.module_@wireapp_store-engine.kt$import org.khronos.webgl.*</ID>
        <ID>WildcardImport:CRUDEngine.module_@wireapp_store-engine.kt$import org.w3c.dom.*</ID>
        <ID>WildcardImport:CRUDEngine.module_@wireapp_store-engine.kt$import org.w3c.dom.events.*</ID>
        <ID>WildcardImport:CRUDEngine.module_@wireapp_store-engine.kt$import org.w3c.dom.parsing.*</ID>
        <ID>WildcardImport:CRUDEngine.module_@wireapp_store-engine.kt$import org.w3c.dom.svg.*</ID>
        <ID>WildcardImport:CRUDEngine.module_@wireapp_store-engine.kt$import org.w3c.dom.url.*</ID>
        <ID>WildcardImport:CRUDEngine.module_@wireapp_store-engine.kt$import org.w3c.fetch.*</ID>
        <ID>WildcardImport:CRUDEngine.module_@wireapp_store-engine.kt$import org.w3c.files.*</ID>
        <ID>WildcardImport:CRUDEngine.module_@wireapp_store-engine.kt$import org.w3c.notifications.*</ID>
        <ID>WildcardImport:CRUDEngine.module_@wireapp_store-engine.kt$import org.w3c.performance.*</ID>
        <ID>WildcardImport:CRUDEngine.module_@wireapp_store-engine.kt$import org.w3c.workers.*</ID>
        <ID>WildcardImport:CRUDEngine.module_@wireapp_store-engine.kt$import org.w3c.xhr.*</ID>
        <ID>WildcardImport:Cryptobox.module_@wireapp_cryptobox.kt$import kotlin.js.*</ID>
        <ID>WildcardImport:Cryptobox.module_@wireapp_cryptobox.kt$import org.khronos.webgl.*</ID>
        <ID>WildcardImport:Cryptobox.module_@wireapp_cryptobox.kt$import org.w3c.dom.*</ID>
        <ID>WildcardImport:Cryptobox.module_@wireapp_cryptobox.kt$import org.w3c.dom.events.*</ID>
        <ID>WildcardImport:Cryptobox.module_@wireapp_cryptobox.kt$import org.w3c.dom.parsing.*</ID>
        <ID>WildcardImport:Cryptobox.module_@wireapp_cryptobox.kt$import org.w3c.dom.svg.*</ID>
        <ID>WildcardImport:Cryptobox.module_@wireapp_cryptobox.kt$import org.w3c.dom.url.*</ID>
        <ID>WildcardImport:Cryptobox.module_@wireapp_cryptobox.kt$import org.w3c.fetch.*</ID>
        <ID>WildcardImport:Cryptobox.module_@wireapp_cryptobox.kt$import org.w3c.files.*</ID>
        <ID>WildcardImport:Cryptobox.module_@wireapp_cryptobox.kt$import org.w3c.notifications.*</ID>
        <ID>WildcardImport:Cryptobox.module_@wireapp_cryptobox.kt$import org.w3c.performance.*</ID>
        <ID>WildcardImport:Cryptobox.module_@wireapp_cryptobox.kt$import org.w3c.workers.*</ID>
        <ID>WildcardImport:Cryptobox.module_@wireapp_cryptobox.kt$import org.w3c.xhr.*</ID>
        <ID>WildcardImport:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$import kotlin.js.*</ID>
        <ID>WildcardImport:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$import org.khronos.webgl.*</ID>
        <ID>WildcardImport:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$import org.w3c.dom.*</ID>
        <ID>WildcardImport:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$import org.w3c.dom.events.*</ID>
        <ID>WildcardImport:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$import org.w3c.dom.parsing.*</ID>
        <ID>WildcardImport:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$import org.w3c.dom.svg.*</ID>
        <ID>WildcardImport:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$import org.w3c.dom.url.*</ID>
        <ID>WildcardImport:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$import org.w3c.fetch.*</ID>
        <ID>WildcardImport:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$import org.w3c.files.*</ID>
        <ID>WildcardImport:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$import org.w3c.notifications.*</ID>
        <ID>WildcardImport:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$import org.w3c.performance.*</ID>
        <ID>WildcardImport:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$import org.w3c.workers.*</ID>
        <ID>WildcardImport:CryptoboxCRUDStore.module_@wireapp_cryptobox.kt$import org.w3c.xhr.*</ID>
        <ID>WildcardImport:CryptoboxSession.module_@wireapp_cryptobox.kt$import kotlin.js.*</ID>
        <ID>WildcardImport:CryptoboxSession.module_@wireapp_cryptobox.kt$import org.khronos.webgl.*</ID>
        <ID>WildcardImport:CryptoboxSession.module_@wireapp_cryptobox.kt$import org.w3c.dom.*</ID>
        <ID>WildcardImport:CryptoboxSession.module_@wireapp_cryptobox.kt$import org.w3c.dom.events.*</ID>
        <ID>WildcardImport:CryptoboxSession.module_@wireapp_cryptobox.kt$import org.w3c.dom.parsing.*</ID>
        <ID>WildcardImport:CryptoboxSession.module_@wireapp_cryptobox.kt$import org.w3c.dom.svg.*</ID>
        <ID>WildcardImport:CryptoboxSession.module_@wireapp_cryptobox.kt$import org.w3c.dom.url.*</ID>
        <ID>WildcardImport:CryptoboxSession.module_@wireapp_cryptobox.kt$import org.w3c.fetch.*</ID>
        <ID>WildcardImport:CryptoboxSession.module_@wireapp_cryptobox.kt$import org.w3c.files.*</ID>
        <ID>WildcardImport:CryptoboxSession.module_@wireapp_cryptobox.kt$import org.w3c.notifications.*</ID>
        <ID>WildcardImport:CryptoboxSession.module_@wireapp_cryptobox.kt$import org.w3c.performance.*</ID>
        <ID>WildcardImport:CryptoboxSession.module_@wireapp_cryptobox.kt$import org.w3c.workers.*</ID>
        <ID>WildcardImport:CryptoboxSession.module_@wireapp_cryptobox.kt$import org.w3c.xhr.*</ID>
        <ID>WildcardImport:Decoder.module_@wireapp_cbor.kt$import kotlin.js.*</ID>
        <ID>WildcardImport:Decoder.module_@wireapp_cbor.kt$import org.khronos.webgl.*</ID>
        <ID>WildcardImport:Decoder.module_@wireapp_cbor.kt$import org.w3c.dom.*</ID>
        <ID>WildcardImport:Decoder.module_@wireapp_cbor.kt$import org.w3c.dom.events.*</ID>
        <ID>WildcardImport:Decoder.module_@wireapp_cbor.kt$import org.w3c.dom.parsing.*</ID>
        <ID>WildcardImport:Decoder.module_@wireapp_cbor.kt$import org.w3c.dom.svg.*</ID>
        <ID>WildcardImport:Decoder.module_@wireapp_cbor.kt$import org.w3c.dom.url.*</ID>
        <ID>WildcardImport:Decoder.module_@wireapp_cbor.kt$import org.w3c.fetch.*</ID>
        <ID>WildcardImport:Decoder.module_@wireapp_cbor.kt$import org.w3c.files.*</ID>
        <ID>WildcardImport:Decoder.module_@wireapp_cbor.kt$import org.w3c.notifications.*</ID>
        <ID>WildcardImport:Decoder.module_@wireapp_cbor.kt$import org.w3c.performance.*</ID>
        <ID>WildcardImport:Decoder.module_@wireapp_cbor.kt$import org.w3c.workers.*</ID>
        <ID>WildcardImport:Decoder.module_@wireapp_cbor.kt$import org.w3c.xhr.*</ID>
        <ID>WildcardImport:Encoder.module_@wireapp_cbor.kt$import kotlin.js.*</ID>
        <ID>WildcardImport:Encoder.module_@wireapp_cbor.kt$import org.khronos.webgl.*</ID>
        <ID>WildcardImport:Encoder.module_@wireapp_cbor.kt$import org.w3c.dom.*</ID>
        <ID>WildcardImport:Encoder.module_@wireapp_cbor.kt$import org.w3c.dom.events.*</ID>
        <ID>WildcardImport:Encoder.module_@wireapp_cbor.kt$import org.w3c.dom.parsing.*</ID>
        <ID>WildcardImport:Encoder.module_@wireapp_cbor.kt$import org.w3c.dom.svg.*</ID>
        <ID>WildcardImport:Encoder.module_@wireapp_cbor.kt$import org.w3c.dom.url.*</ID>
        <ID>WildcardImport:Encoder.module_@wireapp_cbor.kt$import org.w3c.fetch.*</ID>
        <ID>WildcardImport:Encoder.module_@wireapp_cbor.kt$import org.w3c.files.*</ID>
        <ID>WildcardImport:Encoder.module_@wireapp_cbor.kt$import org.w3c.notifications.*</ID>
        <ID>WildcardImport:Encoder.module_@wireapp_cbor.kt$import org.w3c.performance.*</ID>
        <ID>WildcardImport:Encoder.module_@wireapp_cbor.kt$import org.w3c.workers.*</ID>
        <ID>WildcardImport:Encoder.module_@wireapp_cbor.kt$import org.w3c.xhr.*</ID>
        <ID>WildcardImport:IdentityKey.module_@wireapp_proteus.kt$import kotlin.js.*</ID>
        <ID>WildcardImport:IdentityKey.module_@wireapp_proteus.kt$import org.khronos.webgl.*</ID>
        <ID>WildcardImport:IdentityKey.module_@wireapp_proteus.kt$import org.w3c.dom.*</ID>
        <ID>WildcardImport:IdentityKey.module_@wireapp_proteus.kt$import org.w3c.dom.events.*</ID>
        <ID>WildcardImport:IdentityKey.module_@wireapp_proteus.kt$import org.w3c.dom.parsing.*</ID>
        <ID>WildcardImport:IdentityKey.module_@wireapp_proteus.kt$import org.w3c.dom.svg.*</ID>
        <ID>WildcardImport:IdentityKey.module_@wireapp_proteus.kt$import org.w3c.dom.url.*</ID>
        <ID>WildcardImport:IdentityKey.module_@wireapp_proteus.kt$import org.w3c.fetch.*</ID>
        <ID>WildcardImport:IdentityKey.module_@wireapp_proteus.kt$import org.w3c.files.*</ID>
        <ID>WildcardImport:IdentityKey.module_@wireapp_proteus.kt$import org.w3c.notifications.*</ID>
        <ID>WildcardImport:IdentityKey.module_@wireapp_proteus.kt$import org.w3c.performance.*</ID>
        <ID>WildcardImport:IdentityKey.module_@wireapp_proteus.kt$import org.w3c.workers.*</ID>
        <ID>WildcardImport:IdentityKey.module_@wireapp_proteus.kt$import org.w3c.xhr.*</ID>
        <ID>WildcardImport:IdentityKeyPair.module_@wireapp_proteus.kt$import kotlin.js.*</ID>
        <ID>WildcardImport:IdentityKeyPair.module_@wireapp_proteus.kt$import org.khronos.webgl.*</ID>
        <ID>WildcardImport:IdentityKeyPair.module_@wireapp_proteus.kt$import org.w3c.dom.*</ID>
        <ID>WildcardImport:IdentityKeyPair.module_@wireapp_proteus.kt$import org.w3c.dom.events.*</ID>
        <ID>WildcardImport:IdentityKeyPair.module_@wireapp_proteus.kt$import org.w3c.dom.parsing.*</ID>
        <ID>WildcardImport:IdentityKeyPair.module_@wireapp_proteus.kt$import org.w3c.dom.svg.*</ID>
        <ID>WildcardImport:IdentityKeyPair.module_@wireapp_proteus.kt$import org.w3c.dom.url.*</ID>
        <ID>WildcardImport:IdentityKeyPair.module_@wireapp_proteus.kt$import org.w3c.fetch.*</ID>
        <ID>WildcardImport:IdentityKeyPair.module_@wireapp_proteus.kt$import org.w3c.files.*</ID>
        <ID>WildcardImport:IdentityKeyPair.module_@wireapp_proteus.kt$import org.w3c.notifications.*</ID>
        <ID>WildcardImport:IdentityKeyPair.module_@wireapp_proteus.kt$import org.w3c.performance.*</ID>
        <ID>WildcardImport:IdentityKeyPair.module_@wireapp_proteus.kt$import org.w3c.workers.*</ID>
        <ID>WildcardImport:IdentityKeyPair.module_@wireapp_proteus.kt$import org.w3c.xhr.*</ID>
        <ID>WildcardImport:KeyPair.module_@wireapp_proteus.kt$import kotlin.js.*</ID>
        <ID>WildcardImport:KeyPair.module_@wireapp_proteus.kt$import org.khronos.webgl.*</ID>
        <ID>WildcardImport:KeyPair.module_@wireapp_proteus.kt$import org.w3c.dom.*</ID>
        <ID>WildcardImport:KeyPair.module_@wireapp_proteus.kt$import org.w3c.dom.events.*</ID>
        <ID>WildcardImport:KeyPair.module_@wireapp_proteus.kt$import org.w3c.dom.parsing.*</ID>
        <ID>WildcardImport:KeyPair.module_@wireapp_proteus.kt$import org.w3c.dom.svg.*</ID>
        <ID>WildcardImport:KeyPair.module_@wireapp_proteus.kt$import org.w3c.dom.url.*</ID>
        <ID>WildcardImport:KeyPair.module_@wireapp_proteus.kt$import org.w3c.fetch.*</ID>
        <ID>WildcardImport:KeyPair.module_@wireapp_proteus.kt$import org.w3c.files.*</ID>
        <ID>WildcardImport:KeyPair.module_@wireapp_proteus.kt$import org.w3c.notifications.*</ID>
        <ID>WildcardImport:KeyPair.module_@wireapp_proteus.kt$import org.w3c.performance.*</ID>
        <ID>WildcardImport:KeyPair.module_@wireapp_proteus.kt$import org.w3c.workers.*</ID>
        <ID>WildcardImport:KeyPair.module_@wireapp_proteus.kt$import org.w3c.xhr.*</ID>
        <ID>WildcardImport:MemoryEngine.module_@wireapp_store-engine.kt$import kotlin.js.*</ID>
        <ID>WildcardImport:MemoryEngine.module_@wireapp_store-engine.kt$import org.khronos.webgl.*</ID>
        <ID>WildcardImport:MemoryEngine.module_@wireapp_store-engine.kt$import org.w3c.dom.*</ID>
        <ID>WildcardImport:MemoryEngine.module_@wireapp_store-engine.kt$import org.w3c.dom.events.*</ID>
        <ID>WildcardImport:MemoryEngine.module_@wireapp_store-engine.kt$import org.w3c.dom.parsing.*</ID>
        <ID>WildcardImport:MemoryEngine.module_@wireapp_store-engine.kt$import org.w3c.dom.svg.*</ID>
        <ID>WildcardImport:MemoryEngine.module_@wireapp_store-engine.kt$import org.w3c.dom.url.*</ID>
        <ID>WildcardImport:MemoryEngine.module_@wireapp_store-engine.kt$import org.w3c.fetch.*</ID>
        <ID>WildcardImport:MemoryEngine.module_@wireapp_store-engine.kt$import org.w3c.files.*</ID>
        <ID>WildcardImport:MemoryEngine.module_@wireapp_store-engine.kt$import org.w3c.notifications.*</ID>
        <ID>WildcardImport:MemoryEngine.module_@wireapp_store-engine.kt$import org.w3c.performance.*</ID>
        <ID>WildcardImport:MemoryEngine.module_@wireapp_store-engine.kt$import org.w3c.workers.*</ID>
        <ID>WildcardImport:MemoryEngine.module_@wireapp_store-engine.kt$import org.w3c.xhr.*</ID>
        <ID>WildcardImport:PreKey.module_@wireapp_proteus.kt$import kotlin.js.*</ID>
        <ID>WildcardImport:PreKey.module_@wireapp_proteus.kt$import org.khronos.webgl.*</ID>
        <ID>WildcardImport:PreKey.module_@wireapp_proteus.kt$import org.w3c.dom.*</ID>
        <ID>WildcardImport:PreKey.module_@wireapp_proteus.kt$import org.w3c.dom.events.*</ID>
        <ID>WildcardImport:PreKey.module_@wireapp_proteus.kt$import org.w3c.dom.parsing.*</ID>
        <ID>WildcardImport:PreKey.module_@wireapp_proteus.kt$import org.w3c.dom.svg.*</ID>
        <ID>WildcardImport:PreKey.module_@wireapp_proteus.kt$import org.w3c.dom.url.*</ID>
        <ID>WildcardImport:PreKey.module_@wireapp_proteus.kt$import org.w3c.fetch.*</ID>
        <ID>WildcardImport:PreKey.module_@wireapp_proteus.kt$import org.w3c.files.*</ID>
        <ID>WildcardImport:PreKey.module_@wireapp_proteus.kt$import org.w3c.notifications.*</ID>
        <ID>WildcardImport:PreKey.module_@wireapp_proteus.kt$import org.w3c.performance.*</ID>
        <ID>WildcardImport:PreKey.module_@wireapp_proteus.kt$import org.w3c.workers.*</ID>
        <ID>WildcardImport:PreKey.module_@wireapp_proteus.kt$import org.w3c.xhr.*</ID>
        <ID>WildcardImport:PreKeyBundle.module_@wireapp_proteus.kt$import kotlin.js.*</ID>
        <ID>WildcardImport:PreKeyBundle.module_@wireapp_proteus.kt$import org.khronos.webgl.*</ID>
        <ID>WildcardImport:PreKeyBundle.module_@wireapp_proteus.kt$import org.w3c.dom.*</ID>
        <ID>WildcardImport:PreKeyBundle.module_@wireapp_proteus.kt$import org.w3c.dom.events.*</ID>
        <ID>WildcardImport:PreKeyBundle.module_@wireapp_proteus.kt$import org.w3c.dom.parsing.*</ID>
        <ID>WildcardImport:PreKeyBundle.module_@wireapp_proteus.kt$import org.w3c.dom.svg.*</ID>
        <ID>WildcardImport:PreKeyBundle.module_@wireapp_proteus.kt$import org.w3c.dom.url.*</ID>
        <ID>WildcardImport:PreKeyBundle.module_@wireapp_proteus.kt$import org.w3c.fetch.*</ID>
        <ID>WildcardImport:PreKeyBundle.module_@wireapp_proteus.kt$import org.w3c.files.*</ID>
        <ID>WildcardImport:PreKeyBundle.module_@wireapp_proteus.kt$import org.w3c.notifications.*</ID>
        <ID>WildcardImport:PreKeyBundle.module_@wireapp_proteus.kt$import org.w3c.performance.*</ID>
        <ID>WildcardImport:PreKeyBundle.module_@wireapp_proteus.kt$import org.w3c.workers.*</ID>
        <ID>WildcardImport:PreKeyBundle.module_@wireapp_proteus.kt$import org.w3c.xhr.*</ID>
        <ID>WildcardImport:PreKeyStore.module_@wireapp_proteus.kt$import kotlin.js.*</ID>
        <ID>WildcardImport:PreKeyStore.module_@wireapp_proteus.kt$import org.khronos.webgl.*</ID>
        <ID>WildcardImport:PreKeyStore.module_@wireapp_proteus.kt$import org.w3c.dom.*</ID>
        <ID>WildcardImport:PreKeyStore.module_@wireapp_proteus.kt$import org.w3c.dom.events.*</ID>
        <ID>WildcardImport:PreKeyStore.module_@wireapp_proteus.kt$import org.w3c.dom.parsing.*</ID>
        <ID>WildcardImport:PreKeyStore.module_@wireapp_proteus.kt$import org.w3c.dom.svg.*</ID>
        <ID>WildcardImport:PreKeyStore.module_@wireapp_proteus.kt$import org.w3c.dom.url.*</ID>
        <ID>WildcardImport:PreKeyStore.module_@wireapp_proteus.kt$import org.w3c.fetch.*</ID>
        <ID>WildcardImport:PreKeyStore.module_@wireapp_proteus.kt$import org.w3c.files.*</ID>
        <ID>WildcardImport:PreKeyStore.module_@wireapp_proteus.kt$import org.w3c.notifications.*</ID>
        <ID>WildcardImport:PreKeyStore.module_@wireapp_proteus.kt$import org.w3c.performance.*</ID>
        <ID>WildcardImport:PreKeyStore.module_@wireapp_proteus.kt$import org.w3c.workers.*</ID>
        <ID>WildcardImport:PreKeyStore.module_@wireapp_proteus.kt$import org.w3c.xhr.*</ID>
        <ID>WildcardImport:PublicKey.module_@wireapp_proteus.kt$import kotlin.js.*</ID>
        <ID>WildcardImport:PublicKey.module_@wireapp_proteus.kt$import org.khronos.webgl.*</ID>
        <ID>WildcardImport:PublicKey.module_@wireapp_proteus.kt$import org.w3c.dom.*</ID>
        <ID>WildcardImport:PublicKey.module_@wireapp_proteus.kt$import org.w3c.dom.events.*</ID>
        <ID>WildcardImport:PublicKey.module_@wireapp_proteus.kt$import org.w3c.dom.parsing.*</ID>
        <ID>WildcardImport:PublicKey.module_@wireapp_proteus.kt$import org.w3c.dom.svg.*</ID>
        <ID>WildcardImport:PublicKey.module_@wireapp_proteus.kt$import org.w3c.dom.url.*</ID>
        <ID>WildcardImport:PublicKey.module_@wireapp_proteus.kt$import org.w3c.fetch.*</ID>
        <ID>WildcardImport:PublicKey.module_@wireapp_proteus.kt$import org.w3c.files.*</ID>
        <ID>WildcardImport:PublicKey.module_@wireapp_proteus.kt$import org.w3c.notifications.*</ID>
        <ID>WildcardImport:PublicKey.module_@wireapp_proteus.kt$import org.w3c.performance.*</ID>
        <ID>WildcardImport:PublicKey.module_@wireapp_proteus.kt$import org.w3c.workers.*</ID>
        <ID>WildcardImport:PublicKey.module_@wireapp_proteus.kt$import org.w3c.xhr.*</ID>
        <ID>WildcardImport:SecretKey.module_@wireapp_proteus.kt$import kotlin.js.*</ID>
        <ID>WildcardImport:SecretKey.module_@wireapp_proteus.kt$import org.khronos.webgl.*</ID>
        <ID>WildcardImport:SecretKey.module_@wireapp_proteus.kt$import org.w3c.dom.*</ID>
        <ID>WildcardImport:SecretKey.module_@wireapp_proteus.kt$import org.w3c.dom.events.*</ID>
        <ID>WildcardImport:SecretKey.module_@wireapp_proteus.kt$import org.w3c.dom.parsing.*</ID>
        <ID>WildcardImport:SecretKey.module_@wireapp_proteus.kt$import org.w3c.dom.svg.*</ID>
        <ID>WildcardImport:SecretKey.module_@wireapp_proteus.kt$import org.w3c.dom.url.*</ID>
        <ID>WildcardImport:SecretKey.module_@wireapp_proteus.kt$import org.w3c.fetch.*</ID>
        <ID>WildcardImport:SecretKey.module_@wireapp_proteus.kt$import org.w3c.files.*</ID>
        <ID>WildcardImport:SecretKey.module_@wireapp_proteus.kt$import org.w3c.notifications.*</ID>
        <ID>WildcardImport:SecretKey.module_@wireapp_proteus.kt$import org.w3c.performance.*</ID>
        <ID>WildcardImport:SecretKey.module_@wireapp_proteus.kt$import org.w3c.workers.*</ID>
        <ID>WildcardImport:SecretKey.module_@wireapp_proteus.kt$import org.w3c.xhr.*</ID>
        <ID>Wrapping:ACMEApi.kt$ACMEApiImpl$( ACMEAuthorizationResponse( nonce = nonce, location = challengeResponse.headers[LOCATION_HEADER_KEY], response = challengeResponse.value.encodeToByteArray(), challengeType = type ), challengeResponse.headers, challengeResponse.httpCode )</ID>
        <ID>Wrapping:ACMEApi.kt$ACMEApiImpl$( ACMEResponse( nonce, response = httpResponse.body(), location = httpResponse.headers[LOCATION_HEADER_KEY].toString() ), httpResponse )</ID>
        <ID>Wrapping:ACMEApi.kt$ACMEApiImpl$( ChallengeResponse( type = challengeResponse.value.type, url = challengeResponse.value.url, status = challengeResponse.value.status, token = challengeResponse.value.token, target = challengeResponse.value.target, nonce = nonce ), challengeResponse.headers, challengeResponse.httpCode )</ID>
        <ID>Wrapping:AccessTokenDTOJson.kt$AccessTokenDTOJson$( AccessTokenDTO( userId = "user_id", value = "Nlrhltkj-NgJUjEVevHz8Ilgy_pyWCT2b0kQb-GlnamyswanghN9DcC3an5RUuA7sh1_nC3hv2ZzMRlIhPM7Ag==.v=1.k=1.d=1637254939." + "t=a.l=.u=75ebeb16-a860-4be4-84a7-157654b492cf.c=18401233206926541098", expiresIn = 900, tokenType = "Bearer" ), jsonProvider )</ID>
        <ID>Wrapping:AddAuthenticatedUserUseCaseTest.kt$AddAuthenticatedUserUseCaseTest.Arrangement$result</ID>
        <ID>Wrapping:AddAuthenticatedUserUseCaseTest.kt$AddAuthenticatedUserUseCaseTest.Arrangement$storeSession(serverConfigId, ssoId, accountTokens, proxyCredentials)</ID>
        <ID>Wrapping:AddUserToConversationEventAction.kt$AddUserToConversationEventAction$</ID>
        <ID>Wrapping:ApiTest.kt$ApiTest$(</ID>
        <ID>Wrapping:ApproveLegalHoldRequestUseCaseTest.kt$ApproveLegalHoldRequestUseCaseTest.Arrangement$ApproveLegalHoldRequestUseCaseImpl(teamRepository, selfTeamIdProvider)</ID>
        <ID>Wrapping:AssetMessageHandlerTest.kt$AssetMessageHandlerTest$(</ID>
        <ID>Wrapping:AssetMessageHandlerTest.kt$AssetMessageHandlerTest.Arrangement$(</ID>
        <ID>Wrapping:AssetRepository.kt$AssetDataSource$( assetId, assetName.fileExtension() ?: getExtensionFromMimeType(mimeType) )</ID>
        <ID>Wrapping:AssetRepositoryTest.kt$AssetRepositoryTest$(</ID>
        <ID>Wrapping:AssetRepositoryTest.kt$AssetRepositoryTest.Arrangement$(</ID>
        <ID>Wrapping:AssetRepositoryTest.kt$AssetRepositoryTest.Arrangement$(any(), any(), any(), matching { val buffer = Buffer() buffer.write(assetData) it.write(buffer, assetData.size.toLong()) true })</ID>
        <ID>Wrapping:AssetRepositoryTest.kt$AssetRepositoryTest.Arrangement$(any(), anything(), eq(null), matching { val buffer = Buffer() buffer.write(assetData) it.write(buffer, assetData.size.toLong()) true })</ID>
        <ID>Wrapping:AuthenticationScope.kt$AuthenticationScopeProvider$&lt;Pair&lt;ServerConfig, ProxyCredentials?>, AuthenticationScope></ID>
        <ID>Wrapping:BaseDatabaseTest.kt$BaseDatabaseTest$(</ID>
        <ID>Wrapping:CodeDeletedHandlerTest.kt$CodeDeletedHandlerTest$(</ID>
        <ID>Wrapping:CodeUpdateHandlerTest.kt$CodeUpdateHandlerTest$(</ID>
        <ID>Wrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(</ID>
        <ID>Wrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(anything(), matching { it.containsAll(expectedInitialUsers) })</ID>
        <ID>Wrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(anything(), matching { it.containsAll(expectedInitialUsersNotFromUnreachableInformed) })</ID>
        <ID>Wrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(anything(), matching { it.size == expectedFullUserIdsForRequestCount })</ID>
        <ID>Wrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(anything(), matching { it.size == expectedValidUsersWithKeyPackagesCount &amp;&amp; it.first() == TestConversation.USER_1 })</ID>
        <ID>Wrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(anything(), matching { it.size == initialCountUsers - 1 // removed 1 failed users with key packages })</ID>
        <ID>Wrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(anything(), matching { it.size == initialCountUsers - 2 // removed 1 failed user with commit bundle federated error })</ID>
        <ID>Wrapping:ConversationGroupRepositoryTest.kt$ConversationGroupRepositoryTest$(anything(), matching { it.size == initialCountUsers })</ID>
        <ID>Wrapping:ConversationMessageTimerEventHandlerTest.kt$ConversationMessageTimerEventHandlerTest$(</ID>
        <ID>Wrapping:ConversationRepository.kt$ConversationDataSource$(</ID>
        <ID>Wrapping:ConversationRepository.kt$ConversationRepository.Companion$(</ID>
        <ID>Wrapping:ConversationRepository.kt$ConversationRepository.Companion$-></ID>
        <ID>Wrapping:ConversationRepositoryTest.kt$ConversationRepositoryTest$(</ID>
        <ID>Wrapping:ConversationRepositoryTest.kt$ConversationRepositoryTest.Companion$( UpdateConversationProtocolResponse.ProtocolUpdated( EventContentDTO.Conversation.ProtocolUpdate( TestConversation.NETWORK_ID, ConversationProtocolDTO(ConvProtocol.MIXED), TestUser.NETWORK_ID ) ), emptyMap(), 200 )</ID>
        <ID>Wrapping:CreateBackupUseCase.kt$CreateBackupUseCaseImpl$(</ID>
        <ID>Wrapping:DeleteClientUseCase.kt$DeleteClientUseCaseImpl$(</ID>
        <ID>Wrapping:DeleteEphemeralMessageForSelfUserAsReceiverUseCaseTest.kt$DeleteEphemeralMessageForSelfUserAsReceiverUseCaseTest$(</ID>
        <ID>Wrapping:DeleteEphemeralMessageForSelfUserAsReceiverUseCaseTest.kt$DeleteEphemeralMessageForSelfUserAsReceiverUseCaseTest$( matching { it.conversationId == SELF_CONVERSION_ID.first() &amp;&amp; it.content == MessageContent.DeleteForMe(messageId, conversationId) }, matching { it == MessageTarget.Conversation() })</ID>
        <ID>Wrapping:DeleteEphemeralMessageForSelfUserAsReceiverUseCaseTest.kt$DeleteEphemeralMessageForSelfUserAsReceiverUseCaseTest$( matching { it.conversationId == conversationId &amp;&amp; it.content == MessageContent.DeleteMessage(messageId) }, matching { it == MessageTarget.Users(listOf(senderUserID)) })</ID>
        <ID>Wrapping:EnrollE2EICertificateUseCaseTest.kt$EnrollE2EICertificateUseCaseTest.Companion$( "keyauth" to JsonObject( mapOf("essential" to JsonPrimitive(true), "value" to JsonPrimitive(OIDC_AUTHZ.keyAuth)) ), "acme_aud" to JsonObject( mapOf("essential" to JsonPrimitive(true), "value" to JsonPrimitive(OIDC_AUTHZ.challenge.url)) ) )</ID>
        <ID>Wrapping:EnvelopeProtoMapper.kt$EnvelopeProtoMapperImpl$(</ID>
        <ID>Wrapping:EnvelopeProtoMapperTest.kt$EnvelopeProtoMapperTest$( user, mapOf( Pair("241b5be49179d81b", ByteArray(0)), Pair("8bdacec7398a982e", ByteArray(0)), Pair("e47d908549239b72", ByteArray(0)), Pair("4c8346ce67fa0d7", ByteArray(0)) ) )</ID>
        <ID>Wrapping:FeatureConfigEventReceiverTest.kt$FeatureConfigEventReceiverTest$(</ID>
        <ID>Wrapping:FeatureConfigEventReceiverTest.kt$FeatureConfigEventReceiverTest$( SelfDeletingMessagesConfigModel( enforcedTimeoutSeconds = null ), Status.DISABLED )</ID>
        <ID>Wrapping:FeatureConfigMapperTest.kt$FeatureConfigMapperTest.Arrangement$( MLSConfigDTO( SupportedProtocolDTO.MLS, listOf(SupportedProtocolDTO.MLS), emptyList(), 1 ), FeatureFlagStatusDTO.ENABLED )</ID>
        <ID>Wrapping:FeatureConfigRepositoryTest.kt$FeatureConfigRepositoryTest.Arrangement$( MLSConfigDTO( SupportedProtocolDTO.PROTEUS, listOf(SupportedProtocolDTO.PROTEUS), emptyList(), 1 ), FeatureFlagStatusDTO.ENABLED )</ID>
        <ID>Wrapping:FederationEventReceiverTest.kt$FederationEventReceiverTest$UserId(value = "defIdTwo$it", domain = defederatedDomainTwo)</ID>
        <ID>Wrapping:GetNotificationsUseCaseTest.kt$GetNotificationsUseCaseTest$(</ID>
        <ID>Wrapping:GetOrCreateOneToOneConversationUseCase.kt$GetOrCreateOneToOneConversationUseCaseImpl$(</ID>
        <ID>Wrapping:GetUserInfoUseCase.kt$GetUserInfoUseCaseImpl$(</ID>
        <ID>Wrapping:HandleExternalRequestAction.kt$( """ Hey there, I hope you're doing well. I've got a bit of a craving for bananas, and I was wondering if you might be able to share a few with me? It would mean a lot.  Thanks a bunch, A friendly monkey  """.trimIndent(), """ Yo, I'm in need of some bananas, my friend. Can you hook me up? I'd appreciate it big time. Respect, A neutral monkey  """.trimIndent(), """ Listen up, I ain't messin' around. I want them bananas, and I want 'em now. You better deliver or there'll be consequences. No games, An evil monkey  """.trimIndent() )</ID>
        <ID>Wrapping:InstanceLifecycle.kt$InstanceLifecycle$(</ID>
        <ID>Wrapping:InstanceService.kt$InstanceService$(</ID>
        <ID>Wrapping:InstanceServiceTest.kt$InstanceServiceTest$(</ID>
        <ID>Wrapping:IsEligibleToStartCallUseCase.kt$IsEligibleToStartCallUseCaseImpl$(</ID>
        <ID>Wrapping:JoinConversationViaCodeUseCaseTest.kt$JoinConversationViaCodeUseCaseTest$( code, key, null, password, Either.Left( NetworkFailure.ServerMiscommunication( KaliumException.InvalidRequestError( ErrorResponse(403, "wrong password", "invalid-conversation-password") ) ) ) )</ID>
        <ID>Wrapping:JoinExistingMLSConversationUseCaseTest.kt$JoinExistingMLSConversationUseCaseTest.Arrangement$;</ID>
        <ID>Wrapping:JoinSubconversationUseCaseTest.kt$JoinSubconversationUseCaseTest.Arrangement$;</ID>
        <ID>Wrapping:KaliumHttpLogger.kt$KaliumHttpLogger$"""</ID>
        <ID>Wrapping:KaliumKtorCustomLogging.kt$KaliumKtorCustomLogging$"""</ID>
        <ID>Wrapping:KeyingMaterialsManager.kt$KeyingMaterialsManagerImpl$(</ID>
        <ID>Wrapping:LeaveSubconversationUseCase.kt$LeaveSubconversationUseCaseImpl$conversationApi.fetchSubconversationDetails(conversationId.toApi(), subconversationId.toApi())</ID>
        <ID>Wrapping:LegalHoldHandlerTest.kt$LegalHoldHandlerTest.Arrangement$stubsUnitByDefault = true</ID>
        <ID>Wrapping:LegalHoldSystemMessageHandlerTest.kt$LegalHoldSystemMessagesHandlerTest$(</ID>
        <ID>Wrapping:ListUsersRequestJson.kt$ListUsersRequestJson$( QualifiedUserIdListRequest( listOf( QualifiedID("id1", "domain1"), QualifiedID("id11", "domain1"), QualifiedID("id2", "domain2") ) ), qualifiedIdsProvider )</ID>
        <ID>Wrapping:LoginWithEmailRequestJson.kt$LoginWithEmailRequestJson$( LoginApi.LoginParam.LoginWithEmail( email = "user@email.de", label = "label", password = "password", verificationCode = "verificationCode" ), jsonProvider )</ID>
        <ID>Wrapping:LoginWithEmailRequestJson.kt$LoginWithEmailRequestJson$( LoginApi.LoginParam.LoginWithHandle( handle = "cool_user_name", label = "label", password = "password", ), jsonProvider )</ID>
        <ID>Wrapping:MLSConfigHandlerTest.kt$MLSConfigHandlerTest$(</ID>
        <ID>Wrapping:MLSConfigHandlerTest.kt$MLSConfigHandlerTest$(MLS_CONFIG.copy( status = Status.DISABLED ), duringSlowSync = false)</ID>
        <ID>Wrapping:MLSConfigHandlerTest.kt$MLSConfigHandlerTest$(MLS_CONFIG.copy( status = Status.DISABLED, defaultProtocol = SupportedProtocol.MLS ), duringSlowSync = false)</ID>
        <ID>Wrapping:MLSConfigHandlerTest.kt$MLSConfigHandlerTest$(MLS_CONFIG.copy( status = Status.ENABLED, defaultProtocol = SupportedProtocol.MLS ), duringSlowSync = false)</ID>
        <ID>Wrapping:MLSConfigHandlerTest.kt$MLSConfigHandlerTest$(MLS_CONFIG.copy( status = Status.ENABLED, defaultProtocol = SupportedProtocol.PROTEUS ), duringSlowSync = false)</ID>
        <ID>Wrapping:MLSConfigHandlerTest.kt$MLSConfigHandlerTest$(MLS_CONFIG.copy( status = Status.ENABLED, supportedProtocols = setOf(SupportedProtocol.PROTEUS, SupportedProtocol.MLS) ), duringSlowSync = false)</ID>
        <ID>Wrapping:MLSConfigHandlerTest.kt$MLSConfigHandlerTest$(MLS_CONFIG.copy( status = Status.ENABLED, supportedProtocols = setOf(SupportedProtocol.PROTEUS, SupportedProtocol.MLS) ), duringSlowSync = true)</ID>
        <ID>Wrapping:MLSConversationRepositoryTest.kt$MLSConversationRepositoryTest.Arrangement$;</ID>
        <ID>Wrapping:MLSConversationsVerificationStatusesHandler.kt$MLSConversationsVerificationStatusesHandlerImpl$(</ID>
        <ID>Wrapping:MLSKeyPackageCountUseCase.kt$MLSKeyPackageCountUseCaseImpl$(</ID>
        <ID>Wrapping:MLSMessageUnpacker.kt$MLSMessageUnpackerImpl$( KaliumLogLevel.DEBUG, "Decrypting MLS for Conversation", mapOf( "conversationId" to messageEvent.conversationId.toLogString(), "groupID" to protocolInfo.groupId.toLogString(), "protocolInfo" to protocolInfo.toLogMap() ) )</ID>
        <ID>Wrapping:MLSMessageUnpacker.kt$MLSMessageUnpackerImpl$( KaliumLogLevel.DEBUG, "Decrypting MLS for SubConversation", mapOf( "conversationId" to messageEvent.conversationId.toLogString(), "subConversationId" to subConversationId.toLogString(), "groupID" to groupID.toLogString() ) )</ID>
        <ID>Wrapping:MLSMigrationConfigHandlerTest.kt$MLSMigrationConfigHandlerTest$(</ID>
        <ID>Wrapping:MLSMigrationConfigHandlerTest.kt$MLSMigrationConfigHandlerTest$(MIGRATION_CONFIG.copy( startTime = Instant.DISTANT_PAST, endTime = Instant.DISTANT_PAST ), duringSlowSync = false)</ID>
        <ID>Wrapping:MLSMigrationConfigHandlerTest.kt$MLSMigrationConfigHandlerTest$(MIGRATION_CONFIG.copy( startTime = Instant.DISTANT_PAST, endTime = Instant.DISTANT_PAST ), duringSlowSync = true)</ID>
        <ID>Wrapping:MLSMigrationWorker.kt$MLSMigrationWorkerImpl$configurations.mlsMigrationModel?.let { mlsMigrationConfigHandler.handle(configurations.mlsMigrationModel, duringSlowSync = false) } ?: Either.Right(Unit)</ID>
        <ID>Wrapping:MemberLeaveEventHandlerTest.kt$MemberLeaveEventHandlerTest$(</ID>
        <ID>Wrapping:MemberLeaveEventHandlerTest.kt$MemberLeaveEventHandlerTest.Arrangement$UserRepositoryArrangement by UserRepositoryArrangementImpl(), PersistMessageUseCaseArrangement by PersistMessageUseCaseArrangementImpl(), MemberDAOArrangement by MemberDAOArrangementImpl(), SelfTeamIdProviderArrangement by SelfTeamIdProviderArrangementImpl()</ID>
        <ID>Wrapping:MessageContentEncoderTest.kt$MessageContentEncoderTest.TestData$(</ID>
        <ID>Wrapping:MessageDraftMapper.kt$(</ID>
        <ID>Wrapping:MessageEnvelope.kt$ClientPayload$(</ID>
        <ID>Wrapping:MessageEnvelope.kt$MessageEnvelope$(</ID>
        <ID>Wrapping:MessageEnvelopeCreatorTest.kt$MessageEnvelopeCreatorTest$CryptoSessionId(recipient.id.toCrypto(), CryptoClientId((it.value)))</ID>
        <ID>Wrapping:MessageMapper.kt$MessageMapperImpl$(</ID>
        <ID>Wrapping:MessageRepository.kt$MessageDataSource$it.toApi()</ID>
        <ID>Wrapping:MessageRepositoryExtensionsTest.kt$MessageRepositoryExtensionsTest$(</ID>
        <ID>Wrapping:MessageRepositoryExtensionsTest.kt$MessageRepositoryExtensionsTest$(eq(CONVERSATION_ID_ENTITY), matching { val list = it.toList() list.size == 1 &amp;&amp; list[0] == MessageEntity.Visibility.VISIBLE }, eq(pagingConfig))</ID>
        <ID>Wrapping:MessageRepositoryTest.kt$MessageRepositoryTest$(</ID>
        <ID>Wrapping:MessageRepositoryTest.kt$MessageRepositoryTest$( matching { (it.messageOption is MessageApi.QualifiedMessageOption.ReportSome) &amp;&amp; ((it.messageOption as MessageApi.QualifiedMessageOption.ReportSome) .userIDs == recipient.map { it.id }) }, anything() )</ID>
        <ID>Wrapping:MessageRepositoryTest.kt$MessageRepositoryTest$( matching { it.recipients.isEmpty() &amp;&amp; it.messageOption == MessageApi.QualifiedMessageOption.IgnoreAll }, anything() )</ID>
        <ID>Wrapping:MessageRepositoryTest.kt$MessageRepositoryTest$( matching { it.recipients.isEmpty() &amp;&amp; it.messageOption == MessageApi.QualifiedMessageOption.ReportAll }, anything() )</ID>
        <ID>Wrapping:MessageSenderTest.kt$MessageSenderTest.Arrangement$;</ID>
        <ID>Wrapping:MigrationDAO.kt$MigrationDAOImpl$MigrationDAO, MessageInsertExtension by MessageInsertExtensionImpl( messagesQueries, unreadEventsQueries, conversationsQueries, buttonContentQueries, selfUserIDEntity )</ID>
        <ID>Wrapping:MockUnboundNetworkClient.kt$MockUnboundNetworkClient$(</ID>
        <ID>Wrapping:MonkeyPool.kt$MonkeyPool$ConcurrentHashMap()</ID>
        <ID>Wrapping:NewConversationMembersRepositoryTest.kt$NewConversationMembersRepositoryTest.Arrangement$(</ID>
        <ID>Wrapping:NewGroupConversationSystemMessagesCreatorTest.kt$NewGroupConversationSystemMessagesCreatorTest$(</ID>
        <ID>Wrapping:NewGroupConversationSystemMessagesCreatorTest.kt$NewGroupConversationSystemMessagesCreatorTest$( ConversationMemberDTO.Self( TestUser.SELF.id.toApi(), "wire_admin" ), emptyList() )</ID>
        <ID>Wrapping:NewMessageEventHandlerTest.kt$NewMessageEventHandlerTest$(</ID>
        <ID>Wrapping:NotificationTokenRepository.kt$NotificationTokenDataSource$tokenStorage.getToken()</ID>
        <ID>Wrapping:ObfuscateUtil.kt$listOf("qualified_id", "qualified_ids", "qualified_users", "content", "payload")</ID>
        <ID>Wrapping:ObserveClientDetailsUseCase.kt$ObserveClientDetailsUseCaseImpl$(</ID>
        <ID>Wrapping:ObserveConversationAssetStatusesUseCase.kt$ObserveAssetStatusesUseCaseImpl$(</ID>
        <ID>Wrapping:ObserveConversationMembersUseCaseTest.kt$ObserveConversationMembersUseCaseTest$(</ID>
        <ID>Wrapping:ObserveMessageReceiptsUseCase.kt$ObserveMessageReceiptsUseCaseImpl$(</ID>
        <ID>Wrapping:ObserveNewClientsUseCaseTest.kt$ObserveNewClientsUseCaseTest$( NewClientResult.InOtherAccount( listOf(TestClient.CLIENT), TestUser.OTHER_USER_ID, TestUser.SELF.name, TestUser.SELF.handle ), awaitItem() )</ID>
        <ID>Wrapping:ObserveNewClientsUseCaseTest.kt$ObserveNewClientsUseCaseTest.Arrangement$stubsUnitByDefault = true</ID>
        <ID>Wrapping:ObserveSecurityClassificationLabelUseCaseTest.kt$ObserveSecurityClassificationLabelUseCaseTest.Arrangement$( TestUser.OTHER.copy( UserId(uuid4().toString(), domain), expiresAt = expiresAt ), Conversation.Member.Role.Member )</ID>
        <ID>Wrapping:OnCloseCall.kt$OnCloseCall$(</ID>
        <ID>Wrapping:OnlyAffectedTestTask.kt$OnlyAffectedTestTask$(</ID>
        <ID>Wrapping:OnlyAffectedTestTask.kt$OnlyAffectedTestTask$computeModulesPredicate(hasToRunAllTests, affectedModules.contains(it.name) &amp;&amp; !ignoredModules.contains(it.name))</ID>
        <ID>Wrapping:PersistMigratedMessagesUseCase.kt$PersistMigratedMessagesUseCaseImpl$(</ID>
        <ID>Wrapping:PocIntegrationTest.kt$PocIntegrationTest.Companion$( rootPath = "$HOME_DIRECTORY/.kalium/accounts-test", kaliumConfigs = KaliumConfigs( developmentApiEnabled = true, encryptProteusStorage = true, isMLSSupportEnabled = true, wipeOnDeviceRemoval = true, kaliumMockEngine = KaliumMockEngine(mockEngine = mockEngine), mockNetworkStateObserver = TestNetworkStateObserver.DEFAULT_TEST_NETWORK_STATE_OBSERVER ), "Wire Integration Tests" )</ID>
        <ID>Wrapping:PreKeyListMapper.kt$PreKeyListMapper$(</ID>
        <ID>Wrapping:PreKeyListMapperTest.kt$PreKeyListMapperTest$( "domA" to mapOf( "userA" to mapOf( "clientA" to PreKeyDTO(1, "keyA") ), "userB" to mapOf( "clientB" to PreKeyDTO(32, "key") ) ), "domB" to mapOf( "userB" to mapOf( "clientB" to PreKeyDTO(22, "keyC") ) ) )</ID>
        <ID>Wrapping:PreKeyListMapperTest.kt$PreKeyListMapperTest$( "userA" to mapOf( "clientA" to PreKeyDTO(1, "keyA") ), "userB" to mapOf( "clientB" to PreKeyDTO(32, "key") ) )</ID>
        <ID>Wrapping:PreKeyListMapperTest.kt$PreKeyListMapperTest$( "userA" to mapOf( firstKeySet.clientId to firstKeySet.response, secondKeySet.clientId to secondKeySet.response ), "userB" to mapOf(thirdKeySet.clientId to thirdKeySet.response) )</ID>
        <ID>Wrapping:ProteusClientCoreCryptoImpl.kt$ProteusClientCoreCryptoImpl$coreCrypto.proteusSessionFromPrekey(sessionId.value, toUByteList(preKeyCrypto.encodedData.decodeBase64Bytes()))</ID>
        <ID>Wrapping:ProteusMessageUnpackerTest.kt$ProteusMessageUnpackerTest$(</ID>
        <ID>Wrapping:ProteusMessageUnpackerTest.kt$ProteusMessageUnpackerTest$(any(), ProtoContent.Readable( "uuid", MessageContent.Unknown(), false, Conversation.LegalHoldStatus.DISABLED ))</ID>
        <ID>Wrapping:ProtoContentMapper.kt$ProtoContentMapperImpl$(</ID>
        <ID>Wrapping:ProtoContentMapper.kt$ProtoContentMapperImpl$( type = when (receiptContent.type) { ReceiptType.DELIVERED -> Confirmation.Type.DELIVERED ReceiptType.READ -> Confirmation.Type.READ }, firstMessageId = firstMessage, moreMessageIds = restOfMessageIds )</ID>
        <ID>Wrapping:ProtoContentMapperTest.kt$ProtoContentMapperTest$( TEST_MESSAGE_UUID, GenericMessage.Content.Asset( Asset( original = Asset.Original( mimeType = "file/binary", size = mockedAsset.size.toLong(), name = assetName, ), status = Asset.Status.NotUploaded(Asset.NotUploaded.CANCELLED), ) ) )</ID>
        <ID>Wrapping:QualifiedSendMessageRequestJson.kt$QualifiedSendMessageRequestJson$( MessageApi.Parameters.QualifiedDefaultParameters( sender = USER_1_CLIENT_1, externalBlob = "blob-id".toByteArray(), nativePush = true, recipients = mapOf(), transient = false, priority = MessagePriority.HIGH, messageOption = MessageApi.QualifiedMessageOption.IgnoreAll ), defaultParametersProvider )</ID>
        <ID>Wrapping:ReceiptModeUpdateEventHandlerTest.kt$ReceiptModeUpdateEventHandlerTest$(</ID>
        <ID>Wrapping:RegisterTokenJson.kt$RegisterTokenJson$( PushTokenBody( "8218398", "123456", "oaisjdoiasjd", "GCM" ), jsonProvider )</ID>
        <ID>Wrapping:RemoteMonkey.kt$RemoteMonkey$(</ID>
        <ID>Wrapping:ReplayApplication.kt$ReplayApplication$"-e and -t must be provided for the file type"</ID>
        <ID>Wrapping:RequestResponseEventAction.kt$RequestResponseEventAction$</ID>
        <ID>Wrapping:RetryFailedMessageUseCaseTest.kt$RetryFailedMessageUseCaseTest$(</ID>
        <ID>Wrapping:RetryFailedMessageUseCaseTest.kt$RetryFailedMessageUseCaseTest$( matching { it is Message.Signaling // message edits are sent as signaling messages &amp;&amp; it.id != message.id // when editing we need to generate and set a new id &amp;&amp; it.content is MessageContent.TextEdited &amp;&amp; (it.content as MessageContent.TextEdited).editMessageId == message.id // original id in edited content }, anything() )</ID>
        <ID>Wrapping:RetryFailedMessageUseCaseTest.kt$RetryFailedMessageUseCaseTest$(matching { it.id == message.id &amp;&amp; it.content is MessageContent.Asset &amp;&amp; (it.content as MessageContent.Asset).value.remoteData.assetId == uploadedAssetId.key &amp;&amp; (it.content as MessageContent.Asset).value.remoteData.assetDomain == uploadedAssetId.domain &amp;&amp; (it.content as MessageContent.Asset).value.remoteData.assetToken == uploadedAssetId.assetToken }, anything())</ID>
        <ID>Wrapping:SSOLoginRepositoryTest.kt$SSOLoginRepositoryTest$( DomainLookupResult( networkResponse.configJsonUrl, networkResponse.webappWelcomeUrl ), actual.value )</ID>
        <ID>Wrapping:ScheduleNewAssetMessageUseCaseTest.kt$ScheduleNewAssetMessageUseCaseTest$(</ID>
        <ID>Wrapping:SearchDAOTest.kt$SearchDAOTest$( MemberEntity( connectedPartOfConversation1.id, MemberEntity.Role.Member ), conversationToExclude.id )</ID>
        <ID>Wrapping:SearchDAOTest.kt$SearchDAOTest$( MemberEntity( connectedPartOfConversation2.id, MemberEntity.Role.Member ), conversationToExclude.id )</ID>
        <ID>Wrapping:SearchDAOTest.kt$SearchDAOTest$( MemberEntity( connectedUser1.id, MemberEntity.Role.Member ), conversation.id )</ID>
        <ID>Wrapping:SearchUserRepositoryTest.kt$SearchUserRepositoryTest.Arrangement$SelfTeamIdProviderArrangement by SelfTeamIdProviderArrangementImpl(), SearchDAOArrangement by SearchDAOArrangementImpl()</ID>
        <ID>Wrapping:SendButtonActionConfirmationMessageTest.kt$SendButtonActionConfirmationMessageTest$(</ID>
        <ID>Wrapping:SendButtonActionConfirmationMessageTest.kt$SendButtonActionConfirmationMessageTest$(any(), matching { it is MessageTarget.Users &amp;&amp; it.userId == listOf(buttonActionSender) })</ID>
        <ID>Wrapping:SendButtonActionMessageTest.kt$SendButtonActionMessageTest$(</ID>
        <ID>Wrapping:SendButtonActionMessageTest.kt$SendButtonActionMessageTest$(any(), matching { it is MessageTarget.Users &amp;&amp; it.userId == listOf(originalSender) })</ID>
        <ID>Wrapping:SendDirectMessageEventAction.kt$SendDirectMessageEventAction$(</ID>
        <ID>Wrapping:SendDirectMessageEventAction.kt$SendDirectMessageEventAction$(ActionType.SendMessage( UserCount.single(), 1u, 1u ), {})</ID>
        <ID>Wrapping:SendEditTextMessageUseCase.kt$SendEditTextMessageUseCase$messageSendFailureHandler.handleFailureAndUpdateMessageStatus(it, conversationId, originalMessageId, TYPE)</ID>
        <ID>Wrapping:SendKnockUseCase.kt$SendKnockUseCase$messageSendFailureHandler.handleFailureAndUpdateMessageStatus(it, conversationId, generatedMessageUuid, TYPE)</ID>
        <ID>Wrapping:SendKnockUserCaseTest.kt$SendKnockUserCaseTest$(</ID>
        <ID>Wrapping:SendKnockUserCaseTest.kt$SendKnockUserCaseTest$(matching { assertIs&lt;Message.Regular>(it) it.expirationData?.expireAfter == expectedDuration }, any())</ID>
        <ID>Wrapping:SendLocationUseCase.kt$SendLocationUseCase$messageSendFailureHandler.handleFailureAndUpdateMessageStatus(it, conversationId, generatedMessageUuid, TYPE)</ID>
        <ID>Wrapping:SendLocationUseCaseTest.kt$SendLocationUseCaseTest$(</ID>
        <ID>Wrapping:SendLocationUseCaseTest.kt$SendLocationUseCaseTest$(matching { assertIs&lt;Message.Regular>(it) it.expirationData?.expireAfter == expectedDuration }, any())</ID>
        <ID>Wrapping:SendMessageAction.kt$SendMessageAction$(</ID>
        <ID>Wrapping:SendMessageEventAction.kt$SendMessageEventAction$(</ID>
        <ID>Wrapping:SendMessageEventAction.kt$SendMessageEventAction$(ActionType.SendMessage( UserCount.single(), 1u, 1u ), {})</ID>
        <ID>Wrapping:SendMessagePartialFailureMapperTest.kt$SendMessagePartialFailureMapperTest$(</ID>
        <ID>Wrapping:SendMessageRequestJson.kt$SendMessageRequestJson$( MessageApi.Parameters.DefaultParameters( sender = "sender-client-it", data = null, nativePush = true, recipients = recipients, transient = false, priority = MessagePriority.LOW ), defaultParametersProvider )</ID>
        <ID>Wrapping:SlowSyncManagerTest.kt$SlowSyncManagerTest.Arrangement$stubsUnitByDefault = true</ID>
        <ID>Wrapping:StoreServerConfigUseCaseTest.kt$StoreServerConfigUseCaseTest.Arrangement$(</ID>
        <ID>Wrapping:SyncFeatureConfigsUseCaseTest.kt$SyncFeatureConfigsUseCaseTest$(</ID>
        <ID>Wrapping:SyncMigrationStep_6_7_Test.kt$SyncMigrationStep_6_7_Test.Arrangement$AccountRepositoryArrangement by AccountRepositoryArrangementImpl(), SelfTeamIdProviderArrangement by SelfTeamIdProviderArrangementImpl()</ID>
        <ID>Wrapping:SyncMigrationStepsProviderTest.kt$SyncMigrationStepsProviderTest.Arrangement$AccountRepositoryArrangement by AccountRepositoryArrangementImpl(), SelfTeamIdProviderArrangement by SelfTeamIdProviderArrangementImpl()</ID>
        <ID>Wrapping:TeamRepositoryTest.kt$TeamRepositoryTest$(</ID>
        <ID>Wrapping:TestAsset.kt$TestAsset$(</ID>
        <ID>Wrapping:TestDataImporter.kt$( "config" to mapOf( "allowedCipherSuites" to listOf(1), "defaultCipherSuite" to 1, "defaultProtocol" to "proteus", "protocolToggleUsers" to listOf&lt;String>(), "supportedProtocols" to listOf("mls", "proteus") ), "status" to "enabled" )</ID>
        <ID>Wrapping:TestDataImporter.kt$( "email" to email, "name" to ownerName, "password" to backendConfig.passwordForUsers, "email_code" to code, "team" to mapOf( "name" to backendConfig.teamName, "icon" to "default", "binding" to true ) )</ID>
        <ID>Wrapping:TestDataImporter.kt$TestDataImporter$(</ID>
        <ID>Wrapping:TestDataImporter.kt$TestDataImporter$("id" to team.id, "owner" to mapOf( "email" to team.owner.email, "id" to team.owner.userId.value ), "users" to users.map { mapOf( "email" to it.email, "id" to it.userId.value ) })</ID>
        <ID>Wrapping:TestDataImporter.kt$token</ID>
        <ID>Wrapping:ToggleReactionUseCaseTest.kt$ToggleReactionUseCaseTest$(</ID>
        <ID>Wrapping:ToggleReactionUseCaseTest.kt$ToggleReactionUseCaseTest$(matching { val content = it.content as MessageContent.Reaction content.emojiSet.isEmpty() &amp;&amp; content.messageId == TEST_MESSAGE_ID }, any())</ID>
        <ID>Wrapping:ToggleReactionUseCaseTest.kt$ToggleReactionUseCaseTest$(matching { val content = it.content as MessageContent.Reaction content.emojiSet.size == 1 &amp;&amp; content.emojiSet.first() == emojiReaction &amp;&amp; content.messageId == TEST_MESSAGE_ID }, any())</ID>
        <ID>Wrapping:UnreadEventMapper.kt$UnreadEventMapper$(</ID>
        <ID>Wrapping:UpdateConversationMutedStatusUseCase.kt$UpdateConversationMutedStatusUseCaseImpl$(</ID>
        <ID>Wrapping:UpdateConversationReceiptModeUseCaseTest.kt$UpdateConversationReceiptModeUseCaseTest$(</ID>
        <ID>Wrapping:UpdateSelfUserSupportedProtocolsUseCase.kt$UpdateSelfUserSupportedProtocolsUseCaseImpl$(</ID>
        <ID>Wrapping:UpdateSupportedProtocolsUseCaseTest.kt$UpdateSupportedProtocolsUseCaseTest$(</ID>
        <ID>Wrapping:UserConversationDAOIntegrationTest.kt$UserConversationDAOIntegrationTest$( conversationId, listOf( MemberEntity( user = QualifiedIDEntity( "3", "someDomain" ), role = MemberEntity.Role.Admin ) ) )</ID>
        <ID>Wrapping:UserConversationDAOIntegrationTest.kt$UserConversationDAOIntegrationTest$( conversationId, listOf( MemberEntity( user = user1.id, role = MemberEntity.Role.Admin ), MemberEntity( user = user2.id, role = MemberEntity.Role.Member ), ) )</ID>
        <ID>Wrapping:UserConversationDAOIntegrationTest.kt$UserConversationDAOIntegrationTest$( user = QualifiedIDEntity( "3", "someDomain" ), role = MemberEntity.Role.Admin )</ID>
        <ID>Wrapping:UserDTOJson.kt$UserDTOJson$( SelfUserDTO( id = UserId("user_id", "domain.com"), name = "user_name_123", accentId = 2, assets = listOf(), deleted = null, email = null, handle = null, service = null, teamId = null, expiresAt = "", nonQualifiedId = "", locale = "", managedByDTO = null, phone = null, ssoID = null, supportedProtocols = null ), jsonProvider )</ID>
        <ID>Wrapping:UserEventReceiverTest.kt$UserEventReceiverTest$(</ID>
        <ID>Wrapping:UserMapper.kt$UserMapperImpl$( name = newName, accentId = newAccent, assets = if (newAssetId != null) { listOf( UserAssetDTO(newAssetId, AssetSizeDTO.COMPLETE, UserAssetTypeDTO.IMAGE), UserAssetDTO(newAssetId, AssetSizeDTO.PREVIEW, UserAssetTypeDTO.IMAGE) ) } else { null } )</ID>
        <ID>Wrapping:UserRepository.kt$UserDataSource$(</ID>
        <ID>Wrapping:UserRepository.kt$UserDataSource$it.id.value</ID>
        <ID>Wrapping:UserRepository.kt$UserDataSource$it.isTeamMember(selfUserTeamId?.value, selfUserDomain)</ID>
        <ID>Wrapping:UserRepositoryTest.kt$UserRepositoryTest$(</ID>
        <ID>Wrapping:UserSearchApiWrapperTest.kt$UserSearchApiWrapperTest$( ConversationMemberExcludedOptions.ConversationExcluded( ConversationId( "someValue", "someDomain" ) ), selfUserIncluded = false )</ID>
        <ID>Wrapping:UserSearchApiWrapperTest.kt$UserSearchApiWrapperTest$( ConversationMemberExcludedOptions.ConversationExcluded( ConversationId( "someValue", "someDomain" ) ), selfUserIncluded = true )</ID>
        <ID>Wrapping:UserSearchApiWrapperTest.kt$UserSearchApiWrapperTest$( user = QualifiedIDEntity( "value3", "someDomain" ), role = MemberEntity.Role.Member )</ID>
        <ID>Wrapping:UserSearchApiWrapperTest.kt$UserSearchApiWrapperTest$( user = QualifiedIDEntity( selfUser.id.value, selfUser.id.domain ), role = MemberEntity.Role.Member )</ID>
        <ID>Wrapping:UserSessionScope.kt$UserSessionScope$(</ID>
        <ID>Wrapping:ValidateEmailUseCase.kt$ValidateEmailUseCaseImpl.Companion$(</ID>
        <ID>Wrapping:ValidatePasswordUseCase.kt$ValidatePasswordUseCaseImpl.Companion$(</ID>
        <ID>Wrapping:ValidatePasswordUseCaseTest.kt$ValidatePasswordUseCaseTest$it is ValidatePasswordResult.Invalid &amp;&amp; it.missingLowercaseCharacter</ID>
        <ID>Wrapping:ValidatePasswordUseCaseTest.kt$ValidatePasswordUseCaseTest$it is ValidatePasswordResult.Invalid &amp;&amp; it.missingSpecialCharacter</ID>
        <ID>Wrapping:ValidatePasswordUseCaseTest.kt$ValidatePasswordUseCaseTest$it is ValidatePasswordResult.Invalid &amp;&amp; it.missingUppercaseCharacter</ID>
        <ID>Wrapping:ValidatePasswordUseCaseTest.kt$ValidatePasswordUseCaseTest$validatePasswordUseCase("A1@3.").let { it is ValidatePasswordResult.Invalid &amp;&amp; it.missingLowercaseCharacter }</ID>
        <ID>Wrapping:ValidatePasswordUseCaseTest.kt$ValidatePasswordUseCaseTest$validatePasswordUseCase("a1@3.").let { it is ValidatePasswordResult.Invalid &amp;&amp; it.missingUppercaseCharacter }</ID>
        <ID>Wrapping:ValidatePasswordUseCaseTest.kt$ValidatePasswordUseCaseTest$validatePasswordUseCase("aA13").let { it is ValidatePasswordResult.Invalid &amp;&amp; it.missingSpecialCharacter }</ID>
        <ID>Wrapping:ValidateUserHandleUseCaseTest.kt$ValidateUserHandleUseCaseTest$validateUserHandleUseCase( "1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890" + "1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890" + "123456789012345678901234567890123456789012345678901234567890" ) is ValidateUserHandleResult.Invalid.TooLong</ID>
        <ID>Wrapping:VerifyBackupUseCaseTest.kt$VerifyBackupUseCaseTest.Arrangement$(</ID>
        <ID>Wrapping:VerifyBackupUseCaseTest.kt$VerifyBackupUseCaseTest.Arrangement$(data.map { source(it.second) to it.second.name }, outputSink)</ID>
        <ID>Wrapping:build.gradle.kts$(</ID>
        <ID>Wrapping:build.gradle.kts$(it, closureOf&lt;ExternalModuleDependency> { artifact { type = "aar" } })</ID>
        <ID>Wrapping:homeDirectory.kt$( rootPath, kaliumConfigs = KaliumConfigs( developmentApiEnabled = true, encryptProteusStorage = true, isMLSSupportEnabled = true, wipeOnDeviceRemoval = true, ), userAgent = "Wire Infinite Monkeys", useInMemoryStorage = true )</ID>
    </CurrentIssues>
</SmellBaseline>
