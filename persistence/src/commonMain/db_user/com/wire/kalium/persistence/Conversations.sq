import com.wire.kalium.persistence.dao.QualifiedIDEntity;
import com.wire.kalium.persistence.dao.ConversationEntity;
import kotlin.collections.List;

CREATE TABLE Conversation (
    qualified_id TEXT AS QualifiedIDEntity NOT NULL PRIMARY KEY,
    name TEXT,
    type TEXT AS ConversationEntity.Type NOT NULL,
    team_id TEXT,
    mls_group_id TEXT,
    mls_group_state TEXT AS ConversationEntity.GroupState NOT NULL,
    mls_epoch INTEGER DEFAULT 0 NOT NULL,
    protocol TEXT AS ConversationEntity.Protocol NOT NULL,
    muted_status TEXT AS ConversationEntity.MutedStatus DEFAULT "ALL_ALLOWED" NOT NULL,
    muted_time INTEGER DEFAULT 0 NOT NULL,
    removed_by TEXT AS QualifiedIDEntity,
    creator_id TEXT NOT NULL,
    last_modified_date TEXT NOT NULL,
    last_notified_message_date TEXT,
    last_read_date TEXT DEFAULT "1970-01-01T00:00:00.000Z" NOT NULL,
    access_list TEXT AS List<ConversationEntity.Access> NOT NULL,
    access_role_list TEXT AS List<ConversationEntity.AccessRole> NOT NULL,
    mls_last_keying_material_update INTEGER DEFAULT 0 NOT NULL
);

deleteAllConversations:
DELETE FROM Conversation;

deleteConversation:
DELETE FROM Conversation WHERE qualified_id = ?;

insertConversation:
INSERT INTO Conversation(qualified_id, name, type, team_id, mls_group_id, mls_group_state, mls_epoch, protocol, muted_status, muted_time, removed_by, creator_id, last_modified_date, last_notified_message_date, access_list, access_role_list, last_read_date, mls_last_keying_material_update)
VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(qualified_id) DO UPDATE SET
name = excluded.name,
type = excluded.type,
team_id = excluded.team_id,
mls_group_id = excluded.mls_group_id,
mls_epoch = excluded.mls_epoch,
protocol = excluded.protocol,
muted_status = excluded.muted_status,
muted_time = excluded.muted_time,
removed_by = excluded.removed_by,
creator_id = excluded.creator_id,
access_list = excluded.access_list,
access_role_list = excluded.access_role_list,
last_modified_date = last_modified_date,
last_notified_message_date = last_notified_message_date,
last_read_date = last_read_date,
mls_last_keying_material_update  = excluded.mls_last_keying_material_update;

updateConversation:
UPDATE Conversation
SET name = ?, type = ?, team_id = ?
WHERE qualified_id = ?;

updateConversationGroupState:
UPDATE Conversation
SET mls_group_state = ?
WHERE mls_group_id = ?;

updateConversationNotificationsDate:
UPDATE Conversation
SET last_notified_message_date = ?
WHERE qualified_id = ?;

updateConversationModifiedDate:
UPDATE Conversation
SET last_modified_date = ?
WHERE qualified_id = ?;

updateConversationReadDate:
UPDATE Conversation
SET last_read_date = :last_read_date
WHERE qualified_id = :qualified_id;

updateConversationRemovedBy:
UPDATE Conversation
SET removed_by = :removed_by
WHERE qualified_id = :qualified_id;

selectAllConversations:
SELECT * FROM Conversation WHERE type IS NOT 'CONNECTION_PENDING' ORDER BY last_modified_date DESC;

selectByQualifiedId:
SELECT * FROM Conversation WHERE qualified_id = ?;

selectByGroupId:
SELECT * FROM Conversation WHERE mls_group_id = ?;

selectByGroupState:
SELECT * FROM Conversation WHERE mls_group_state = ? AND protocol = ?;

getConversationIdByGroupId:
SELECT qualified_id FROM Conversation WHERE mls_group_id = ?;

getRemovedBy:
SELECT removed_by FROM Conversation WHERE qualified_id = ?;

selectConversationsWithUnnotifiedMessages:
SELECT * FROM Conversation WHERE muted_status != 'ALL_MUTED' AND (last_notified_message_date ISNULL OR DateTime(last_modified_date) > DateTime(last_notified_message_date));

updateConversationMutingStatus:
UPDATE Conversation
SET muted_status = ?, muted_time = ?
WHERE qualified_id = ?;

getUnreadMessageCount:
SELECT COUNT() FROM Message AS message
WHERE message.conversation_id
IS :conversation_id AND (DateTime(message.date) > (SELECT DateTime(last_read_date) FROM Conversation WHERE qualified_id IS :conversation_id));

getUnreadConversationCount:
SELECT COUNT() FROM Conversation AS conversation
 WHERE DateTime(conversation.last_modified_date) > DateTime(conversation.last_read_date)
 AND conversation.type IS NOT "SELF";

updateAccess:
UPDATE Conversation SET access_list= ?, access_role_list = ? WHERE qualified_id = ?;

getLastUnreadMessage:
SELECT message.id FROM Message AS message
WHERE message.conversation_id
IS :conversation_id AND (DateTime(message.date) > (SELECT DateTime(last_read_date) FROM Conversation WHERE qualified_id IS :conversation_id))
ORDER BY message.date ASC
LIMIT  1;

updateKeyingMaterialDate:
UPDATE Conversation SET mls_last_keying_material_update= ? WHERE mls_group_id = ?;

selectByKeyingMaterialUpdate:
SELECT mls_group_id FROM Conversation WHERE mls_group_state = ? AND protocol = ? AND mls_last_keying_material_update - ? <0 AND mls_group_id IS NOT NULL;
