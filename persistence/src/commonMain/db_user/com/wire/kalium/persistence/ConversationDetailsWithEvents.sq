CREATE VIEW IF NOT EXISTS ConversationDetailsWithEvents AS
SELECT
    ConversationDetails.*,
    -- unread events
    UnreadEventCountsGrouped.knocksCount AS unreadKnocksCount,
    UnreadEventCountsGrouped.missedCallsCount AS unreadMissedCallsCount,
    UnreadEventCountsGrouped.mentionsCount AS unreadMentionsCount,
    UnreadEventCountsGrouped.repliesCount AS unreadRepliesCount,
    UnreadEventCountsGrouped.messagesCount AS unreadMessagesCount,
    -- Simplify nested CASE expressions for better performance
    CASE
        WHEN (ConversationDetails.callStatus = 'STILL_ONGOING' AND ConversationDetails.type = 'GROUP') THEN 1
        WHEN (ConversationDetails.mutedStatus = 'ALL_ALLOWED' AND ((UnreadEventCountsGrouped.knocksCount + UnreadEventCountsGrouped.missedCallsCount + UnreadEventCountsGrouped.mentionsCount + UnreadEventCountsGrouped.repliesCount + UnreadEventCountsGrouped.messagesCount) > 0)) THEN 1
        WHEN (ConversationDetails.mutedStatus = 'ALL_ALLOWED' AND ConversationDetails.type = 'CONNECTION_PENDING' AND ConversationDetails.connectionStatus = 'PENDING') THEN 1
        WHEN (ConversationDetails.mutedStatus = 'ONLY_MENTIONS_AND_REPLIES_ALLOWED' AND ((UnreadEventCountsGrouped.mentionsCount + UnreadEventCountsGrouped.repliesCount) > 0)) THEN 1
        WHEN (ConversationDetails.mutedStatus = 'ONLY_MENTIONS_AND_REPLIES_ALLOWED' AND ConversationDetails.type = 'CONNECTION_PENDING' AND ConversationDetails.connectionStatus = 'PENDING') THEN 1
        ELSE 0
    END AS hasNewActivitiesToShow,
    -- draft message
    MessageDraft.text AS messageDraftText,
    MessageDraft.edit_message_id AS messageDraftEditMessageId,
    MessageDraft.quoted_message_id AS messageDraftQuotedMessageId,
    MessageDraft.mention_list AS messageDraftMentionList,
    -- last message
    Message.id AS lastMessageId,
    Message.content_type AS lastMessageContentType,
    Message.creation_date AS lastMessageDate,
    Message.visibility AS lastMessageVisibility,
    Message.sender_user_id AS lastMessageSenderUserId,
    (Message.expire_after_millis IS NOT NULL) AS lastMessageIsEphemeral,
    User.name AS lastMessageSenderName,
    User.connection_status AS lastMessageSenderConnectionStatus,
    User.deleted AS lastMessageSenderIsDeleted,
    (Message.sender_user_id IS NOT NULL AND Message.sender_user_id == ConversationDetails.selfUserId) AS lastMessageIsSelfMessage,
    MemberChangeContent.member_change_list AS lastMessageMemberChangeList,
    MemberChangeContent.member_change_type AS lastMessageMemberChangeType,
    ConversationNameChangedContent.conversation_name AS lastMessageUpdateConversationName,
    COUNT(Mention.user_id) > 0 AS lastMessageIsMentioningSelfUser,
    TextContent.is_quoting_self AS lastMessageIsQuotingSelfUser,
    TextContent.text_body AS lastMessageText,
    AssetContent.asset_mime_type AS lastMessageAssetMimeType
FROM ConversationDetails
LEFT JOIN UnreadEventCountsGrouped
    ON UnreadEventCountsGrouped.conversationId = ConversationDetails.qualifiedId
LEFT JOIN MessageDraft
    ON ConversationDetails.qualifiedId = MessageDraft.conversation_id AND ConversationDetails.archived = 0 -- only return message draft for non-archived conversations
LEFT JOIN LastMessage
    ON LastMessage.conversation_id = ConversationDetails.qualifiedId AND ConversationDetails.archived = 0 -- only return last message for non-archived conversations
LEFT JOIN Message
    ON LastMessage.message_id = Message.id AND LastMessage.conversation_id = Message.conversation_id
LEFT JOIN User
    ON Message.sender_user_id = User.qualified_id
LEFT JOIN MessageMemberChangeContent AS MemberChangeContent
    ON LastMessage.message_id = MemberChangeContent.message_id AND LastMessage.conversation_id = MemberChangeContent.conversation_id
LEFT JOIN MessageMention AS Mention
    ON LastMessage.message_id == Mention.message_id AND ConversationDetails.selfUserId == Mention.user_id
LEFT JOIN MessageConversationChangedContent AS ConversationNameChangedContent
    ON LastMessage.message_id = ConversationNameChangedContent.message_id AND LastMessage.conversation_id = ConversationNameChangedContent.conversation_id
LEFT JOIN MessageAssetContent AS AssetContent
    ON LastMessage.message_id = AssetContent.message_id AND LastMessage.conversation_id = AssetContent.conversation_id
LEFT JOIN MessageTextContent AS TextContent
    ON LastMessage.message_id = TextContent.message_id AND LastMessage.conversation_id = TextContent.conversation_id
WHERE
    ConversationDetails.type IS NOT 'SELF'
    AND (
        ConversationDetails.type IS 'GROUP'
        OR (ConversationDetails.type IS 'ONE_ON_ONE' AND (ConversationDetails.name IS NOT NULL AND ConversationDetails.otherUserId IS NOT NULL)) -- show 1:1 convos if they have user metadata
        OR (ConversationDetails.type IS 'ONE_ON_ONE' AND ConversationDetails.userDeleted = 1) -- show deleted 1:1 convos to maintain prev, logic
        OR (ConversationDetails.type IS 'CONNECTION_PENDING' AND ConversationDetails.otherUserId IS NOT NULL) -- show connection requests even without metadata
    )
    AND (ConversationDetails.protocol IS 'PROTEUS' OR ConversationDetails.protocol IS 'MIXED' OR (ConversationDetails.protocol IS 'MLS' AND ConversationDetails.mls_group_state IS 'ESTABLISHED'))
    AND ConversationDetails.isActive
GROUP BY ConversationDetails.qualifiedId;

selectAllConversationDetailsWithEvents:
SELECT * FROM ConversationDetailsWithEvents
WHERE archived = :fromArchive
    AND (:onlyInteractionsEnabled = 0 OR interactionEnabled = 1)
ORDER BY
    (CASE WHEN :newActivitiesOnTop THEN hasNewActivitiesToShow ELSE 0 END) DESC,
    lastModifiedDate DESC,
    name IS NULL,
    name COLLATE NOCASE ASC;

-- Optimized query with separate execution paths for different filter types
selectConversationDetailsWithEvents:
WITH filtered_conversations AS (
    SELECT * FROM ConversationDetailsWithEvents WHERE archived = :fromArchive
    AND CASE
        WHEN :conversationFilter = 'ALL' THEN 1
        WHEN :conversationFilter = 'GROUPS' AND type = 'GROUP' AND is_channel = 0 THEN 1
        WHEN :conversationFilter = 'ONE_ON_ONE' AND type = 'ONE_ON_ONE' THEN 1
        WHEN :conversationFilter = 'CHANNELS' AND type = 'GROUP' AND is_channel = 1 THEN 1
        ELSE 0
    END = 1
    AND (:onlyInteractionsEnabled = 0 OR interactionEnabled = 1)
)
SELECT * FROM filtered_conversations
ORDER BY
    (CASE WHEN :newActivitiesOnTop = 1 THEN hasNewActivitiesToShow ELSE 0 END) DESC,
    lastModifiedDate DESC,
    name IS NULL,
    name COLLATE NOCASE ASC
LIMIT :limit
OFFSET :offset;

-- Optimized search query using CTE for better query planning
selectConversationDetailsWithEventsFromSearch:
WITH filtered_conversations AS (
    SELECT * FROM ConversationDetailsWithEvents 
    WHERE archived = :fromArchive
    AND CASE
        WHEN :conversationFilter = 'ALL' THEN 1
        WHEN :conversationFilter = 'GROUPS' AND type = 'GROUP' AND is_channel = 0 THEN 1
        WHEN :conversationFilter = 'ONE_ON_ONE' AND type = 'ONE_ON_ONE' THEN 1
        WHEN :conversationFilter = 'CHANNELS' AND type = 'GROUP' AND is_channel = 1 THEN 1
        ELSE 0
    END = 1
    AND (:onlyInteractionsEnabled = 0 OR interactionEnabled = 1)
    AND name LIKE ('%' || :searchQuery || '%')
)
SELECT * FROM filtered_conversations
ORDER BY
    (CASE WHEN :newActivitiesOnTop = 1 THEN hasNewActivitiesToShow ELSE 0 END) DESC,
    lastModifiedDate DESC,
    name IS NULL,
    name COLLATE NOCASE ASC
LIMIT :limit
OFFSET :offset;

countConversationDetailsWithEvents:
SELECT COUNT(*) FROM ConversationDetails
WHERE
    ConversationDetails.type IS NOT 'SELF'
    AND (
        ConversationDetails.type IS 'GROUP'
        OR (ConversationDetails.type IS 'ONE_ON_ONE' AND (ConversationDetails.name IS NOT NULL AND ConversationDetails.otherUserId IS NOT NULL)) -- show 1:1 convos if they have user metadata
        OR (ConversationDetails.type IS 'ONE_ON_ONE' AND ConversationDetails.userDeleted = 1) -- show deleted 1:1 convos to maintain prev, logic
        OR (ConversationDetails.type IS 'CONNECTION_PENDING' AND ConversationDetails.otherUserId IS NOT NULL) -- show connection requests even without metadata
    )
    AND (ConversationDetails.protocol IS 'PROTEUS' OR ConversationDetails.protocol IS 'MIXED' OR (ConversationDetails.protocol IS 'MLS' AND ConversationDetails.mls_group_state IS 'ESTABLISHED'))
    AND ConversationDetails.isActive
    AND archived = :fromArchive
    AND (
        (:conversationFilter = 'ALL') OR
        (:conversationFilter = 'GROUPS' AND type = 'GROUP' AND is_channel = 0) OR
        (:conversationFilter = 'ONE_ON_ONE' AND type = 'ONE_ON_ONE') OR
        (:conversationFilter = 'CHANNELS' AND type = 'GROUP' AND is_channel = 1)
        -- FAVORITES filter will be implemented here
    )
    AND (:onlyInteractionsEnabled = 0 OR interactionEnabled = 1);

countConversationDetailsWithEventsFromSearch:
SELECT COUNT(*) FROM ConversationDetails
WHERE
    ConversationDetails.type IS NOT 'SELF'
    AND (
        ConversationDetails.type IS 'GROUP'
        OR (ConversationDetails.type IS 'ONE_ON_ONE' AND (ConversationDetails.name IS NOT NULL AND ConversationDetails.otherUserId IS NOT NULL)) -- show 1:1 convos if they have user metadata
        OR (ConversationDetails.type IS 'ONE_ON_ONE' AND ConversationDetails.userDeleted = 1) -- show deleted 1:1 convos to maintain prev, logic
        OR (ConversationDetails.type IS 'CONNECTION_PENDING' AND ConversationDetails.otherUserId IS NOT NULL) -- show connection requests even without metadata
    )
    AND (ConversationDetails.protocol IS 'PROTEUS' OR ConversationDetails.protocol IS 'MIXED' OR (ConversationDetails.protocol IS 'MLS' AND ConversationDetails.mls_group_state IS 'ESTABLISHED'))
    AND ConversationDetails.isActive
    AND archived = :fromArchive
    AND (
        (:conversationFilter = 'ALL') OR
        (:conversationFilter = 'GROUPS' AND type = 'GROUP' AND is_channel = 0) OR
        (:conversationFilter = 'ONE_ON_ONE' AND type = 'ONE_ON_ONE') OR
        (:conversationFilter = 'CHANNELS' AND type = 'GROUP' AND is_channel = 1)
        -- FAVORITES filter will be implemented here
    )
    AND (:onlyInteractionsEnabled = 0 OR interactionEnabled = 1)
    AND name LIKE ('%' || :searchQuery || '%');
