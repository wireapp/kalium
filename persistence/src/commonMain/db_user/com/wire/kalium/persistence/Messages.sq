import com.wire.kalium.persistence.dao.QualifiedIDEntity;
import com.wire.kalium.persistence.dao.message.MessageEntity.ContentType;
import com.wire.kalium.persistence.dao.message.MessageEntity;
import kotlin.Int;

CREATE TABLE Message (
      id TEXT NOT NULL,

      -- Text message field
      text_body TEXT,

      -- Asset message fields
      asset_mime_type TEXT,
      asset_size INTEGER,
      asset_name TEXT,
      asset_image_width INTEGER AS Int,
      asset_image_height INTEGER AS Int,
      asset_otr_key BLOB,
      asset_sha256 BLOB,
      asset_id TEXT,
      asset_token TEXT,
      asset_domain TEXT,
      asset_encryption_algorithm TEXT,

      -- Base message fields
      content_type TEXT AS ContentType NOT NULL,
      conversation_id TEXT AS QualifiedIDEntity NOT NULL,
      date TEXT NOT NULL,
      sender_user_id TEXT AS QualifiedIDEntity NOT NULL,
      sender_client_id TEXT NOT NULL,
      status TEXT AS MessageEntity.Status NOT NULL,
      visibility TEXT AS MessageEntity.Visibility NOT NULL DEFAULT 'visible',
      FOREIGN KEY (conversation_id) REFERENCES Conversation(qualified_id),
      FOREIGN KEY (sender_user_id) REFERENCES User(qualified_id),
      PRIMARY KEY (id, conversation_id)
);

deleteAllMessages:
DELETE FROM Message;

deleteMessage:
DELETE FROM Message WHERE  id = ? AND conversation_id = ?;

deleteMessageById:
DELETE FROM Message WHERE  id = ?;

markMessageAsDeleted:
UPDATE Message
SET visibility = 'DELETED', text_body = NULL
WHERE id = ?;

insertMessage:
INSERT INTO Message(id, text_body, asset_mime_type, asset_size, asset_name, asset_image_width, asset_image_height, asset_otr_key, asset_sha256, asset_id, asset_token, asset_domain, asset_encryption_algorithm, content_type, conversation_id, date, sender_user_id, sender_client_id, visibility, status)
VALUES(?, ?, ?, ?, ? ,?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id, conversation_id) DO UPDATE SET
id = excluded.id,
text_body = excluded.text_body,
asset_mime_type = excluded.asset_mime_type,
asset_size = excluded.asset_size,
asset_name = excluded.asset_name,
asset_image_width = excluded.asset_image_width,
asset_image_height = excluded.asset_image_height,
asset_otr_key = excluded.asset_otr_key,
asset_sha256 = excluded.asset_sha256,
asset_id = excluded.asset_id,
asset_token = excluded.asset_token,
asset_domain = excluded.asset_domain,
asset_encryption_algorithm = excluded.asset_encryption_algorithm,
content_type = excluded.content_type,
text_body = excluded.text_body,
date = excluded.date,
sender_user_id = excluded.sender_user_id,
sender_client_id = excluded.sender_client_id,
visibility = excluded.visibility,
status = excluded.status;

updateMessages:
UPDATE Message
SET text_body = ?, asset_mime_type = ?, asset_size = ?, asset_name = ?, asset_image_width = ?, asset_image_height = ?, asset_otr_key = ?, asset_sha256 = ?, asset_id = ?, asset_token = ?, asset_domain = ?, asset_encryption_algorithm = ?, content_type = ?, date = ?, sender_user_id = ?, sender_client_id = ?, visibility = ?, status = ?
WHERE id = ? AND conversation_id = ?;

updateMessageStatus:
UPDATE Message
SET status = ?
WHERE id = ? AND conversation_id = ?;

updateMessageDate:
UPDATE Message
SET date = ?
WHERE id = ? AND conversation_id = ?;

updateMessagesAddMillisToDate:
UPDATE Message
SET date = strftime('%Y-%m-%dT%H:%M:%fZ', date, '+' || ROUND(CAST(? AS REAL)/1000, 3) || ' seconds')
WHERE conversation_id = ? AND status = ?;

selectAllMessages:
SELECT * FROM Message ORDER BY Datetime(date) DESC LIMIT ? OFFSET ?;

selectById:
SELECT * FROM Message WHERE id = ? AND conversation_id = ?;

selectByConversationId:
SELECT * FROM Message WHERE conversation_id = ? ORDER BY Datetime(date) DESC LIMIT ? OFFSET ?;

selectMessagesByConversationIdAfterDate:
SELECT * FROM Message WHERE conversation_id = ? AND Datetime(date) > Datetime(?) ORDER BY Datetime(date) DESC;

selectMessagesFromUserByStatus:
SELECT * FROM Message WHERE sender_user_id = ? AND status = ?;
