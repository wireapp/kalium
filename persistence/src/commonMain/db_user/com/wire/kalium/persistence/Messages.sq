import com.wire.kalium.persistence.dao.QualifiedIDEntity;
import com.wire.kalium.persistence.dao.message.MessageEntity.ContentType;
import com.wire.kalium.persistence.dao.message.MessageEntity.MemberChangeType;
import com.wire.kalium.persistence.dao.message.MessageEntity;
import kotlin.Int;
import kotlin.collections.List;

CREATE TABLE Message (
      id TEXT NOT NULL,
      content_type TEXT AS ContentType NOT NULL,
      conversation_id TEXT AS QualifiedIDEntity NOT NULL,
      date TEXT NOT NULL,
      sender_user_id TEXT AS QualifiedIDEntity NOT NULL,
      sender_client_id TEXT,
      status TEXT AS MessageEntity.Status NOT NULL,
      last_edit_timestamp TEXT ,
      visibility TEXT AS MessageEntity.Visibility NOT NULL DEFAULT 'visible',

      FOREIGN KEY (conversation_id) REFERENCES Conversation(qualified_id) ON DELETE CASCADE,
      FOREIGN KEY (sender_user_id) REFERENCES User(qualified_id),
      PRIMARY KEY (id, conversation_id)
);

-- Allows optimized querying of messages sorting by date.
CREATE INDEX message_date_index ON Message(date);

CREATE TABLE MessageMention (
      message_id TEXT NOT NULL,
      conversation_id TEXT AS QualifiedIDEntity NOT NULL,

      start INTEGER AS Int NOT NULL,
      length INTEGER AS Int NOT NULL,
      user_id TEXT AS QualifiedIDEntity NOT NULL,

      FOREIGN KEY (message_id, conversation_id) REFERENCES Message(id, conversation_id) ON DELETE CASCADE ON UPDATE CASCADE,
      PRIMARY KEY (message_id, conversation_id, start) -- there should not be any overlapping mentions
);

CREATE TABLE MessageTextContent (
      message_id TEXT NOT NULL,
      conversation_id TEXT AS QualifiedIDEntity NOT NULL,

      text_body TEXT,

      FOREIGN KEY (message_id, conversation_id) REFERENCES Message(id, conversation_id) ON DELETE CASCADE ON UPDATE CASCADE,
      PRIMARY KEY (message_id, conversation_id)
);

CREATE TABLE MessageRestrictedAssetContent (
      message_id TEXT NOT NULL,
      conversation_id TEXT AS QualifiedIDEntity NOT NULL,

      asset_mime_type TEXT NOT NULL,
      asset_size INTEGER NOT NULL,
      asset_name TEXT NOT NULL,

      FOREIGN KEY (message_id, conversation_id) REFERENCES Message(id, conversation_id) ON DELETE CASCADE,
      PRIMARY KEY (message_id, conversation_id)
);

CREATE TABLE MessageAssetContent (
      message_id TEXT NOT NULL,
      conversation_id TEXT AS QualifiedIDEntity NOT NULL,

      asset_size INTEGER NOT NULL,
      asset_name TEXT,
      asset_mime_type TEXT NOT NULL,
      asset_upload_status TEXT AS MessageEntity.UploadStatus,
      asset_download_status TEXT AS MessageEntity.DownloadStatus,

      -- remote data fields
      asset_otr_key BLOB NOT NULL,
      asset_sha256 BLOB NOT NULL,
      asset_id TEXT NOT NULL,
      asset_token TEXT,
      asset_domain TEXT,
      asset_encryption_algorithm TEXT,

      -- metadata fields
      asset_width INTEGER AS Int,
      asset_height INTEGER AS Int,
      asset_duration_ms INTEGER,
      asset_normalized_loudness BLOB,

      FOREIGN KEY (message_id, conversation_id) REFERENCES Message(id, conversation_id) ON DELETE CASCADE ON UPDATE CASCADE,
      PRIMARY KEY (message_id, conversation_id)
);

CREATE TABLE MessageMemberChangeContent (
      message_id TEXT NOT NULL,
      conversation_id TEXT AS QualifiedIDEntity NOT NULL,

      member_change_list TEXT AS List<QualifiedIDEntity> NOT NULL,
      member_change_type TEXT AS MemberChangeType NOT NULL,

      FOREIGN KEY (message_id, conversation_id) REFERENCES Message(id, conversation_id) ON DELETE CASCADE ON UPDATE CASCADE,
      PRIMARY KEY (message_id, conversation_id)
);

CREATE TABLE MessageUnknownContent (
      message_id TEXT NOT NULL,
      conversation_id TEXT AS QualifiedIDEntity NOT NULL,

      unknown_type_name TEXT,
      unknown_encoded_data BLOB,

      FOREIGN KEY (message_id, conversation_id) REFERENCES Message(id, conversation_id) ON DELETE CASCADE ON UPDATE CASCADE,
      PRIMARY KEY (message_id, conversation_id)
);

CREATE TABLE MessageFailedToDecryptContent (
      message_id TEXT NOT NULL,
      conversation_id TEXT AS QualifiedIDEntity NOT NULL,

      unknown_encoded_data BLOB,

      FOREIGN KEY (message_id, conversation_id) REFERENCES Message(id, conversation_id) ON DELETE CASCADE ON UPDATE CASCADE,
      PRIMARY KEY (message_id, conversation_id)
);

CREATE TABLE MessageMissedCallContent (
      message_id TEXT NOT NULL,
      conversation_id TEXT AS QualifiedIDEntity NOT NULL,

      caller_id TEXT AS QualifiedIDEntity NOT NULL,

      FOREIGN KEY (message_id, conversation_id) REFERENCES Message(id, conversation_id) ON DELETE CASCADE ON UPDATE CASCADE,
      PRIMARY KEY (message_id, conversation_id)
);

CREATE TABLE MessageConversationChangedContent (
      message_id TEXT NOT NULL,
      conversation_id TEXT AS QualifiedIDEntity NOT NULL,

      conversation_name TEXT NOT NULL,

      FOREIGN KEY (message_id, conversation_id) REFERENCES Message(id, conversation_id) ON DELETE CASCADE ON UPDATE CASCADE,
      PRIMARY KEY (message_id, conversation_id)
);

CREATE VIEW IF NOT EXISTS MessageDetailsView
AS SELECT
Message.id AS id,
Message.conversation_id AS conversationId,
Message.content_type AS contentType,
Message.date AS date,
Message.sender_user_id AS senderUserId,
Message.sender_client_id AS senderClientId,
Message.status AS status,
Message.last_edit_timestamp AS lastEditTimestamp,
Message.visibility AS visibility,
User.name AS senderName,
User.handle AS senderHandle,
User.email AS senderEmail,
User.phone AS senderPhone,
User.accent_id AS senderAccentId,
User.team AS senderTeamId,
User.connection_status AS senderConnectionStatus,
User.preview_asset_id AS senderPreviewAssetId,
User.complete_asset_id AS senderCompleteAssetId,
User.user_availability_status AS senderAvailabilityStatus,
User.user_type AS senderUserType,
User.bot_service AS senderBotService,
User.deleted AS senderIsDeleted,
TextContent.text_body AS text,
AssetContent.asset_size AS assetSize,
AssetContent.asset_name AS assetName,
AssetContent.asset_mime_type AS assetMimeType,
AssetContent.asset_upload_status AS assetUploadStatus,
AssetContent.asset_download_status AS assetDownloadStatus,
AssetContent.asset_otr_key AS assetOtrKey,
AssetContent.asset_sha256 AS assetSha256,
AssetContent.asset_id AS assetId,
AssetContent.asset_token AS assetToken,
AssetContent.asset_domain AS assetDomain,
AssetContent.asset_encryption_algorithm AS assetEncryptionAlgorithm,
AssetContent.asset_width AS assetWidth,
AssetContent.asset_height AS assetHeight,
AssetContent.asset_duration_ms AS assetDuration,
AssetContent.asset_normalized_loudness AS assetNormalizedLoudness,
MissedCallContent.caller_id AS callerId,
MemberChangeContent.member_change_list AS memberChangeList,
MemberChangeContent.member_change_type AS memberChangeType,
UnknownContent.unknown_type_name AS unknownContentTypeName,
UnknownContent.unknown_encoded_data AS unknownContentData,
RestrictedAssetContent.asset_mime_type AS restrictedAssetMimeType,
RestrictedAssetContent.asset_size AS restrictedAssetSize,
RestrictedAssetContent.asset_name AS restrictedAssetName,
FailedToDecryptContent.unknown_encoded_data AS failedToDecryptData,
ConversationNameChangedContent.conversation_name AS conversationName,
IFNULL(
'{' || GROUP_CONCAT(
   DISTINCT '"' || Reaction.emoji || '":' ||
       (SELECT COUNT(emoji)
           FROM Reaction
           WHERE Reaction.message_id = Message.id
               AND Reaction.conversation_id = Message.conversation_id
               AND emoji = emoji)
       )
|| '}', '{}') AS allReactionsJson,
IFNULL((SELECT '[' || GROUP_CONCAT('"' || Reaction.emoji || '"') || ']'
    FROM Reaction
    WHERE Reaction.sender_id = SelfUser.id
        AND Reaction.message_id = Message.id
        AND Reaction.conversation_id = Message.conversation_id),
'[]') AS selfReactionsJson
FROM Message
LEFT JOIN User ON Message.sender_user_id = User.qualified_id
LEFT JOIN MessageTextContent AS TextContent ON Message.id = TextContent.message_id AND Message.conversation_id = TextContent.conversation_id
LEFT JOIN MessageAssetContent AS AssetContent ON Message.id = AssetContent.message_id AND Message.conversation_id = AssetContent.conversation_id
LEFT JOIN MessageMissedCallContent AS MissedCallContent ON Message.id = MissedCallContent.message_id AND Message.conversation_id = MissedCallContent.conversation_id
LEFT JOIN MessageMemberChangeContent AS MemberChangeContent ON Message.id = MemberChangeContent.message_id AND Message.conversation_id = MemberChangeContent.conversation_id
LEFT JOIN MessageUnknownContent AS UnknownContent ON Message.id = UnknownContent.message_id AND Message.conversation_id = UnknownContent.conversation_id
LEFT JOIN MessageRestrictedAssetContent AS RestrictedAssetContent ON Message.id = RestrictedAssetContent.message_id AND RestrictedAssetContent.conversation_id = RestrictedAssetContent.conversation_id
LEFT JOIN MessageFailedToDecryptContent AS FailedToDecryptContent ON Message.id = FailedToDecryptContent.message_id AND Message.conversation_id = FailedToDecryptContent.conversation_id
LEFT JOIN MessageConversationChangedContent AS ConversationNameChangedContent ON Message.id = ConversationNameChangedContent.message_id AND Message.conversation_id = ConversationNameChangedContent.conversation_id
LEFT JOIN Reaction AS Reaction ON Message.id = Reaction.message_id AND Message.conversation_id = Reaction.conversation_id
LEFT JOIN SelfUser
GROUP BY Message.id;

-- TODO: Remove IFNULL functions above if we can force SQLDelight to not unpack as notnull

deleteAllMessages:
DELETE FROM Message;

deleteMessage:
DELETE FROM Message WHERE id = ? AND conversation_id = ?;

deleteMessageMentions:
DELETE FROM MessageMention WHERE  message_id = ? AND conversation_id = ?;

deleteMessageById:
DELETE FROM Message WHERE id = ?;

markMessageAsDeleted {
   UPDATE Message
   SET visibility = 'DELETED'
   WHERE id = :message_id AND conversation_id = :conversation_id;

   DELETE FROM MessageTextContent WHERE message_id = :message_id AND conversation_id = :conversation_id;
   DELETE FROM MessageAssetContent WHERE message_id = :message_id AND conversation_id = :conversation_id;
   DELETE FROM MessageMemberChangeContent WHERE message_id = :message_id AND conversation_id = :conversation_id;
   DELETE FROM MessageUnknownContent WHERE message_id = :message_id AND conversation_id = :conversation_id;
   DELETE FROM MessageRestrictedAssetContent WHERE message_id = :message_id AND conversation_id = :conversation_id;

   INSERT INTO MessageTextContent(message_id, conversation_id, text_body) VALUES(:message_id, :conversation_id, NULL);
}

markMessageAsEdited:
UPDATE Message
SET last_edit_timestamp = ?
WHERE id = ? AND conversation_id = ?;

insertMessage:
INSERT INTO Message(id, content_type, conversation_id, date, sender_user_id, sender_client_id, status, visibility)
VALUES(?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(id, conversation_id) DO UPDATE SET
id = excluded.id,
content_type = excluded.content_type,
date = excluded.date,
sender_user_id = excluded.sender_user_id,
sender_client_id = excluded.sender_client_id,
status = excluded.status,
visibility = excluded.visibility;

insertMessageMention:
INSERT INTO MessageMention(message_id, conversation_id, start, length, user_id)
VALUES (?, ?, ?, ?, ?)
ON CONFLICT(message_id, conversation_id, start) DO UPDATE SET
message_id = excluded.message_id,
start = excluded.start,
length = excluded.length,
user_id = excluded.user_id;

insertMessageTextContent:
INSERT INTO MessageTextContent(message_id, conversation_id, text_body)
VALUES(?, ?, ?)
ON CONFLICT(message_id, conversation_id) DO UPDATE SET
message_id = excluded.message_id,
text_body = excluded.text_body;

insertMessageRestrictedAssetContent:
INSERT INTO MessageRestrictedAssetContent(message_id, conversation_id, asset_mime_type,asset_size,asset_name)
VALUES(?, ?, ?,?,?)
ON CONFLICT(message_id, conversation_id) DO UPDATE SET
message_id = excluded.message_id,
asset_mime_type = excluded.asset_mime_type;

insertMessageAssetContent:
INSERT INTO MessageAssetContent(message_id, conversation_id, asset_size, asset_name, asset_mime_type, asset_upload_status, asset_download_status, asset_otr_key, asset_sha256, asset_id, asset_token, asset_domain, asset_encryption_algorithm, asset_width, asset_height, asset_duration_ms, asset_normalized_loudness)
VALUES(?, ?, ?, ?, ?, ? ,?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
ON CONFLICT(message_id, conversation_id) DO UPDATE SET
message_id = excluded.message_id,
asset_size = excluded.asset_size,
asset_name = excluded.asset_name,
asset_mime_type = excluded.asset_mime_type,
asset_upload_status = excluded.asset_upload_status,
asset_download_status = excluded.asset_download_status,
asset_otr_key = excluded.asset_otr_key,
asset_sha256 = excluded.asset_sha256,
asset_id = excluded.asset_id,
asset_token = excluded.asset_token,
asset_domain = excluded.asset_domain,
asset_encryption_algorithm = excluded.asset_encryption_algorithm,
asset_width = excluded.asset_width,
asset_height = excluded.asset_height,
asset_duration_ms = excluded.asset_duration_ms,
asset_normalized_loudness = excluded.asset_normalized_loudness;

insertMemberChangeMessage:
INSERT INTO MessageMemberChangeContent(message_id, conversation_id, member_change_list, member_change_type)
VALUES(?, ?, ?, ?)
ON CONFLICT(message_id, conversation_id) DO UPDATE SET
message_id = excluded.message_id,
member_change_list = excluded.member_change_list,
member_change_type = excluded.member_change_type;

insertMessageUnknownContent:
INSERT INTO MessageUnknownContent(message_id, conversation_id, unknown_type_name, unknown_encoded_data)
VALUES(?, ?, ?, ?)
ON CONFLICT(message_id, conversation_id) DO UPDATE SET
message_id = excluded.message_id,
unknown_type_name = excluded.unknown_type_name,
unknown_encoded_data = excluded.unknown_encoded_data;

insertFailedDecryptionMessageContent:
INSERT INTO MessageFailedToDecryptContent(message_id, conversation_id, unknown_encoded_data)
VALUES(?, ?, ?)
ON CONFLICT(message_id, conversation_id) DO UPDATE SET
message_id = excluded.message_id,
unknown_encoded_data = excluded.unknown_encoded_data;

insertMissedCallMessage:
INSERT INTO MessageMissedCallContent(message_id, conversation_id, caller_id)
VALUES(?, ?, ?)
ON CONFLICT(message_id, conversation_id) DO UPDATE SET
caller_id = excluded.caller_id;

insertConversationRenamedMessage:
INSERT INTO MessageConversationChangedContent(message_id, conversation_id, conversation_name)
VALUES(?, ?, ?)
ON CONFLICT(message_id, conversation_id) DO UPDATE SET
conversation_name = excluded.conversation_name;

updateMessageStatus:
UPDATE Message
SET status = ?
WHERE id = ? AND conversation_id = ?;

updateAssetUploadStatus:
UPDATE MessageAssetContent
SET asset_upload_status = ?
WHERE message_id = ? AND conversation_id = ?;

updateAssetDownloadStatus:
UPDATE MessageAssetContent
SET asset_download_status = ?
WHERE message_id = ? AND conversation_id = ?;

updateMessageDate:
UPDATE Message
SET date = ?
WHERE id = ? AND conversation_id = ?;

updateMessagesAddMillisToDate:
UPDATE Message
SET date = strftime('%Y-%m-%dT%H:%M:%fZ', date, '+' || ROUND(CAST(? AS REAL)/1000, 3) || ' seconds')
WHERE conversation_id = ? AND status = ?;

updateMessageTextContent:
UPDATE MessageTextContent
SET text_body = ?
WHERE message_id = ? AND conversation_id = ?;

updateMessageId:
UPDATE Message
SET id = ?
WHERE id = ? AND conversation_id = ?;

selectAllMessages:
SELECT * FROM Message ORDER BY Datetime(date) DESC LIMIT ? OFFSET ?;

selectById:
SELECT * FROM MessageDetailsView WHERE id = ? AND conversationId = ?;

countByConversationIdAndVisibility:
SELECT count(*) FROM Message WHERE conversation_id = ? AND visibility IN ? ORDER BY Datetime(date) DESC;

selectByConversationIdAndVisibility:
SELECT * FROM MessageDetailsView WHERE MessageDetailsView.conversationId = ? AND visibility IN ? ORDER BY Datetime(date) DESC LIMIT ? OFFSET ?;

selectMessagesByConversationIdAndVisibilityAfterDate:
SELECT * FROM MessageDetailsView WHERE MessageDetailsView.conversationId = ? AND visibility IN ? AND Datetime(date) > Datetime(?) ORDER BY Datetime(date) DESC;

selectMessagesFromUserByStatus:
SELECT * FROM MessageDetailsView WHERE senderUserId = ? AND status = ?;

getConversationMessagesByContentType:
SELECT * FROM MessageDetailsView
WHERE MessageDetailsView.conversationId = :conversation_id AND contentType = :content_type;

deleteAllConversationMessages:
DELETE FROM Message
WHERE conversation_id IS :conversation_id;

getLastUnreadMessage:
SELECT * FROM MessageDetailsView AS message
WHERE message.conversationId
IS :conversation_id AND (DateTime(message.date) > (SELECT DateTime(last_read_date) FROM Conversation WHERE qualified_id IS :conversation_id))
ORDER BY message.date ASC
LIMIT  1;

selectByConversationIdAndSenderIdAndTimeAndType:
SELECT * FROM MessageDetailsView WHERE conversationId = ? AND senderUserId = ? AND date = ? AND contentType = ?;

getUnreadMessageCount:
SELECT COUNT() FROM Message AS message
WHERE message.conversation_id IS :conversation_id
AND (DateTime(message.date) > (SELECT DateTime(last_read_date) FROM Conversation WHERE qualified_id IS :conversation_id))
AND message.sender_user_id != :self_user_id
AND message.content_type IN ('TEXT', 'ASSET', 'KNOCK', 'MISSED_CALL');

getUnreadMentionsCount:
SELECT COUNT(DISTINCT message.id) FROM Message AS message
WHERE message.conversation_id IS :conversation_id
AND (DateTime(message.date) > (SELECT DateTime(last_read_date) FROM Conversation WHERE qualified_id IS :conversation_id))
AND message.content_type IN ('TEXT')
AND message.id IN (SELECT message_id FROM MessageMention WHERE user_id = :self_user_id);
