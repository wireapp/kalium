import com.wire.kalium.persistence.dao.member.MemberEntity.Role;
import com.wire.kalium.persistence.dao.QualifiedIDEntity;

CREATE TABLE Member (
    user TEXT AS QualifiedIDEntity NOT NULL,
    conversation TEXT AS QualifiedIDEntity NOT NULL,
    role TEXT AS Role NOT NULL,
    CONSTRAINT member_conv PRIMARY KEY (user, conversation) ON CONFLICT IGNORE,
    FOREIGN KEY (conversation) REFERENCES Conversation(qualified_id)  ON DELETE CASCADE,
    FOREIGN KEY (user) REFERENCES User(qualified_id) ON DELETE CASCADE
);

CREATE INDEX member_conversation_index ON Member(conversation);

insertMember:
INSERT OR IGNORE INTO Member(user, conversation, role)
VALUES (?, ?, ?);

deleteMember:
DELETE FROM Member WHERE conversation = ? AND user = ?;

deleteMembersFromConversation:
DELETE FROM Member WHERE conversation = ?;

selectAllMembersByConversation:
SELECT * FROM Member WHERE conversation = :conversation;

selectConversationsByMember:
SELECT
    qualified_id,
    name,
    type,
    team_id,
    mls_group_id,
    mls_group_state,
    mls_epoch,
    mls_proposal_timer,
    protocol,
    muted_status,
    muted_time,
    creator_id,
    last_modified_date,
    last_notified_date,
    last_read_date,
    access_list,
    access_role_list,
    mls_last_keying_material_update_date,
    mls_cipher_suite,
    receipt_mode,
    message_timer,
    user_message_timer,
    archived,
    archived_date_time,
    verification_status,
    proteus_verification_status
FROM Member
JOIN Conversation ON Conversation.qualified_id = Member.conversation
WHERE Member.user = ?;

updateMemberRole:
UPDATE Member
SET role = ?
WHERE user = ? AND conversation = ?;

deleteUserFromGroupConversations:
DELETE FROM Member
WHERE conversation IN (
    SELECT conversation FROM Member
    JOIN Conversation ON Conversation.qualified_id = Member.conversation
    WHERE Member.user = ? AND Conversation.type = 'GROUP'
) AND Member.user = ?;

isUserMember:
SELECT user FROM Member WHERE conversation = :conversationId AND user = :userId;

selectFederatedMembersWithOneOfDomainsFromGroupConversation:
SELECT mem.* FROM Member AS mem
JOIN Conversation AS con ON con.qualified_id = mem.conversation
WHERE con.type == 'GROUP' AND (user LIKE ('%@' || :firstDomain) OR user LIKE ('%@' || :secondDomain));

selectFederatedMembersFromOneOnOneConversations:
SELECT mem.* FROM Member AS mem
JOIN Conversation AS con ON con.qualified_id = mem.conversation
JOIN User AS usr ON usr.qualified_id = mem.user
WHERE con.type == 'ONE_ON_ONE' AND user LIKE ('%@' || :domain) AND usr.defederated == 0;
